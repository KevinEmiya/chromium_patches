diff --git a/src/build/common.gypi b/src/build/common.gypi
index 1aad5054..48ee2b0 100644
--- a/src/build/common.gypi
+++ b/src/build/common.gypi
@@ -98,6 +98,9 @@
           # if packaging for a linux distro)
           'use_sysroot%': 1,
 
+          # sysroot name where it can be overridden (assumed to be in build/linux)
+          'sysroot_name%': '',
+
           # Override buildtype to select the desired build flavor.
           # Dev - everyday build for development/testing
           # Official - release build (generally implies additional processing)
@@ -181,6 +184,7 @@
         'host_arch%': '<(host_arch)',
         'target_arch%': '<(target_arch)',
         'use_sysroot%': '<(use_sysroot)',
+        'sysroot_name%': '<(sysroot_name)',
 
         # Set to true to instrument the code with function call logger.
         # See src/third_party/cygprofile/cyg-profile.cc for details.
@@ -334,6 +338,10 @@
               ['target_arch=="mipsel"', {
                 'sysroot%': '<!(cd <(DEPTH) && pwd -P)/build/linux/debian_wheezy_mips-sysroot',
               }],
+              # Will override above sysroot if sysroot_name is set
+              ['sysroot_name!=""', {
+                'sysroot%': '<!(cd <(DEPTH) && pwd -P)/build/linux/<(sysroot_name)-sysroot',
+              }],
             ],
           }, {
             'sysroot%': ''
@@ -378,6 +386,7 @@
       'arm_version%': '<(arm_version)',
       'sysroot%': '<(sysroot)',
       'use_sysroot%': '<(use_sysroot)',
+      'sysroot_name%': '<(sysroot_name)',
       'chroot_cmd%': '<(chroot_cmd)',
       'system_libdir%': '<(system_libdir)',
       'order_profiling%': '<(order_profiling)',
@@ -1200,6 +1209,7 @@
     'arm_neon_optional%': '<(arm_neon_optional)',
     'sysroot%': '<(sysroot)',
     'use_sysroot%': '<(use_sysroot)',
+    'sysroot_name%': '<(sysroot_name)',
     'pkg-config%': '<(pkg-config)',
     'chroot_cmd%': '<(chroot_cmd)',
     'system_libdir%': '<(system_libdir)',
@@ -3922,6 +3932,11 @@
           ['target_arch=="arm"', {
             'target_conditions': [
               ['_toolset=="target"', {
+                  'ldflags': [
+                    '-L<(sysroot)/opt/vc/lib',
+                    '-Wl,-rpath=/opt/vc/lib,-rpath-link=<(sysroot)/opt/vc/lib',
+                    '-Wl,--start-group -lbcm_host -lmmal -lmmal_util -lmmal_core -lmmal_vc_client -lvcos -lvcsm -lvchostif -lvchiq_arm -Wl,--end-group',
+                  ],
                 'conditions': [
                   ['clang==0', {
                     'cflags_cc': [
diff --git a/src/cc/layers/video_layer_impl.cc b/src/cc/layers/video_layer_impl.cc
index f22860c..57c789a 100644
--- a/src/cc/layers/video_layer_impl.cc
+++ b/src/cc/layers/video_layer_impl.cc
@@ -107,6 +107,12 @@ bool VideoLayerImpl::WillDraw(DrawMode draw_mode,
                                  layer_tree_impl()->resource_provider()));
   }
 
+  if (!frame_->mmal_resize_cb_.is_null()) {
+//    LOG(ERROR) << "vis:" << visible_layer_rect().ToString() << ", clip:" << clip_rect().ToString() <<
+//      ", drawable:" << drawable_content_rect().ToString() << ", bounds:" << bounds().ToString();
+    frame_->mmal_resize_cb_.Run(bounds());
+  }
+
   VideoFrameExternalResources external_resources =
       updater_->CreateExternalResourcesFromVideoFrame(frame_);
   frame_resource_type_ = external_resources.type;
diff --git a/src/cc/resources/video_resource_updater.cc b/src/cc/resources/video_resource_updater.cc
index e77cd75..359d70d 100644
--- a/src/cc/resources/video_resource_updater.cc
+++ b/src/cc/resources/video_resource_updater.cc
@@ -81,6 +81,7 @@ VideoFrameExternalResources::ResourceType ResourceTypeForVideoFrame(
     case media::PIXEL_FORMAT_YUV420P10:
     case media::PIXEL_FORMAT_YUV422P10:
     case media::PIXEL_FORMAT_YUV444P10:
+    case media::PIXEL_FORMAT_MMAL_BUFFER:
     case media::PIXEL_FORMAT_UNKNOWN:
       break;
   }
@@ -297,6 +298,7 @@ VideoFrameExternalResources VideoResourceUpdater::CreateForSoftwarePlanes(
     case media::PIXEL_FORMAT_RGB32:
     case media::PIXEL_FORMAT_MJPEG:
     case media::PIXEL_FORMAT_MT21:
+    case media::PIXEL_FORMAT_MMAL_BUFFER:
       bits_per_channel = 8;
       break;
     case media::PIXEL_FORMAT_YUV420P9:
@@ -312,7 +314,8 @@ VideoFrameExternalResources VideoResourceUpdater::CreateForSoftwarePlanes(
   }
 
   // Only YUV software video frames are supported.
-  if (!media::IsYuvPlanar(input_frame_format)) {
+  // Also allow our mmal buffer through
+  if (!media::IsYuvPlanar(input_frame_format) && input_frame_format != media::PIXEL_FORMAT_MMAL_BUFFER) {
     NOTREACHED() << media::VideoPixelFormatToString(input_frame_format);
     return VideoFrameExternalResources();
   }
diff --git a/src/chrome/browser/ui/startup/bad_flags_prompt.cc b/src/chrome/browser/ui/startup/bad_flags_prompt.cc
index ecab673..8141a7e 100644
--- a/src/chrome/browser/ui/startup/bad_flags_prompt.cc
+++ b/src/chrome/browser/ui/startup/bad_flags_prompt.cc
@@ -50,8 +50,10 @@ void ShowBadFlagsPrompt(Browser* browser) {
 #if !defined(DISABLE_NACL)
     switches::kNaClDangerousNoSandboxNonSfi,
 #endif
+#if 0
     switches::kNoSandbox,
     switches::kSingleProcess,
+#endif
 
     // These flags disable or undermine the Same Origin Policy.
     translate::switches::kTranslateSecurityOrigin,
diff --git a/src/content/browser/compositor/software_output_device_x11.cc b/src/content/browser/compositor/software_output_device_x11.cc
old mode 100644
new mode 100755
index 7bf743f..4c5aa8d
--- a/src/content/browser/compositor/software_output_device_x11.cc
+++ b/src/content/browser/compositor/software_output_device_x11.cc
@@ -19,8 +19,152 @@
 
 namespace content {
 
+int SoftwareOutputDeviceX11::ShmDesc::attach(XDisplay * const display, const XWindowAttributes& attributes, const int stride, const int h)
+{
+  XImage *img;
+
+  if ((img = XShmCreateImage(display, attributes.visual, attributes.depth,
+                          ZPixmap, NULL, &shminfo_, stride, h)) == NULL) {
+      LOG(ERROR) << "XShmCreateImage failed!";
+      goto fail0;
+  }
+
+//   LOG(ERROR) << "shmget";
+
+   if ((shminfo_.shmid = shmget(IPC_PRIVATE,
+        img->bytes_per_line * img->height, IPC_CREAT|0777 )) < 0)
+   {
+     LOG(ERROR) << "alloc_back_buffer: Shared memory error (shmget), disabling.";
+     goto fail;
+   }
+
+//   LOG(ERROR) << "shmat";
+
+   shminfo_.shmaddr = img->data =
+     (char*)shmat(shminfo_.shmid, 0, 0);
+   if (shminfo_.shmaddr == (char *) -1) {
+     goto fail;
+   }
+
+   shminfo_.readOnly = False;
+   /* This may trigger the X protocol error we're ready to catch: */
+   XShmAttach(display, &shminfo_);
+
+//   LOG(ERROR) << "shmctl";
+
+   shmctl(shminfo_.shmid, IPC_RMID, 0); /* nobody else needs it */
+
+   shmimg_ = img;
+   display_ = display;
+   window_attributes_ = attributes;
+   return 0;
+
+fail:
+    XDestroyImage(img);
+fail0:
+    return -1;
+}
+
+void SoftwareOutputDeviceX11::ShmDesc::detach()
+{
+  if (display_ != NULL) {
+    XShmDetach(display_, &shminfo_);
+    display_ = NULL;
+  }
+}
+
+void SoftwareOutputDeviceX11::ShmDesc::destroy()
+{
+  detach();
+  if (shmimg_ != NULL) {
+    XDestroyImage(shmimg_);
+    shmdt(shminfo_.shmaddr);
+  }
+}
+
+
+Bool SoftwareOutputDeviceX11::ShmDesc::put_image(Drawable drawable, GC gc, const gfx::Rect& rect)
+{
+  return XShmPutImage(display_, drawable, gc, shmimg_,
+      rect.x(), rect.y(), rect.x(), rect.y(),
+      rect.width(), rect.height(), false);
+}
+
+void SoftwareOutputDeviceX11::ShmDesc::resize(const SkImageInfo& info)
+{
+//  LOG(ERROR) << "resize req:" << info.width() << "x" << info.height();
+  req_ii_ = info;
+}
+
+sk_sp<SkSurface> SoftwareOutputDeviceX11::ShmDesc::use_surface()
+{
+  if (req_ii_ != cur_ii_) {
+    // Remember display - we kill it when we detach
+    // window_attributes_ survive destruction
+    XDisplay* const display = display_;
+
+//    LOG(ERROR) << "resize set:" << req_ii_.width() << "x" << req_ii_.height();
+
+    // Kill all current stuff
+    surface_.reset();
+    destroy();
+
+    // Rebuild
+    if (attach(display, window_attributes_, req_ii_.minRowBytes(), req_ii_.height()) != 0)
+    {
+      LOG(ERROR) << "Failed to make new XImage";
+    }
+    // Build a surface on it
+    else if (!(surface_ = SkSurface::MakeRasterDirect(req_ii_, shminfo_.shmaddr, shmimg_->bytes_per_line)))
+    {
+      LOG(ERROR) << "Failed to make new SkSurface";
+    }
+    else
+    {
+      // Success
+      cur_ii_ = req_ii_;
+    }
+  }
+  return surface_;
+}
+
+
+SoftwareOutputDeviceX11::ShmDesc::ShmDesc() :
+  shmimg_(NULL),
+  display_(NULL)
+{
+  // Empty
+}
+
+SoftwareOutputDeviceX11::ShmDesc::~ShmDesc() {
+  destroy();
+}
+
+
+/*
+ * Check if the X Shared Memory extension is available.
+ * Return:  0 = not available
+ *          1 = shared XImage support available
+ *          2 = shared Pixmap support available also
+ */
+static int check_for_xshm(Display * const display)
+{
+   int major, minor, ignore;
+   Bool pixmaps;
+
+   if (XQueryExtension(display, "MIT-SHM", &ignore, &ignore, &ignore)) {
+      if (XShmQueryVersion(display, &major, &minor, &pixmaps)) {
+        return pixmaps ? 2 : 1;
+      }
+   }
+   return 0;
+}
+
+
+
 SoftwareOutputDeviceX11::SoftwareOutputDeviceX11(ui::Compositor* compositor)
-    : compositor_(compositor), display_(gfx::GetXDisplay()), gc_(NULL) {
+    : compositor_(compositor), display_(gfx::GetXDisplay()), gc_(NULL),
+      shm_n_(0) {
   // TODO(skaslev) Remove this when crbug.com/180702 is fixed.
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
 
@@ -30,6 +174,29 @@ SoftwareOutputDeviceX11::SoftwareOutputDeviceX11(ui::Compositor* compositor)
                << compositor_->widget();
     return;
   }
+
+  if (!(gfx::BitsPerPixelForPixmapDepth(display_, attributes_.depth) == 32 &&
+        attributes_.visual->red_mask == 0xff0000 &&
+        attributes_.visual->green_mask == 0xff00 &&
+        attributes_.visual->blue_mask == 0xff &&
+        check_for_xshm(display_) != 0))
+  {
+    LOG(WARNING) << "Display attributes incompatible with SHM";
+    shm_n_ = -1;
+  }
+  else
+  {
+    for (int i = 0; i != 2; ++i) {
+      // Pick any old initial shape - it will be freed as soon as we start
+      // know what size we actually want (even if it is 1024x768!)
+      // This also allows us to check here that SHM actually works
+      if (shm_descs_[i].attach(display_, attributes_, 1024, 768) != 0)
+      {
+        shm_n_ = -1;
+        break;
+      }
+    }
+  }
 }
 
 SoftwareOutputDeviceX11::~SoftwareOutputDeviceX11() {
@@ -38,6 +205,32 @@ SoftwareOutputDeviceX11::~SoftwareOutputDeviceX11() {
   XFreeGC(display_, gc_);
 }
 
+
+void SoftwareOutputDeviceX11::Resize(const gfx::Size& viewport_pixel_size,
+                                  float scale_factor) {
+  scale_factor_ = scale_factor;
+
+  if (viewport_pixel_size_ == viewport_pixel_size)
+    return;
+
+  const SkImageInfo info(SkImageInfo::MakeN32(viewport_pixel_size.width(),
+                                          viewport_pixel_size.height(),
+                                          kOpaque_SkAlphaType));
+  viewport_pixel_size_ = viewport_pixel_size;
+
+  if (shm_n_ < 0) {
+    surface_ = SkSurface::MakeRaster(info);
+  }
+  else
+  {
+    for (int i = 0; i != 2; ++i) {
+      shm_descs_[i].resize(info);
+    }
+
+    surface_ = shm_descs_[shm_n_].use_surface();
+  }
+}
+
 void SoftwareOutputDeviceX11::EndPaint() {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
 
@@ -115,15 +308,26 @@ void SoftwareOutputDeviceX11::EndPaint() {
     return;
   }
 
-  // TODO(jbauman): Switch to XShmPutImage since it's async.
-  SkImageInfo info;
-  size_t rowBytes;
-  const void* addr = surface_->peekPixels(&info, &rowBytes);
-  gfx::PutARGBImage(
-      display_, attributes_.visual, attributes_.depth, compositor_->widget(),
-      gc_, static_cast<const uint8_t*>(addr), viewport_pixel_size_.width(),
-      viewport_pixel_size_.height(), rect.x(), rect.y(), rect.x(), rect.y(),
-      rect.width(), rect.height());
+  if (shm_n_ >= 0) {
+    shm_descs_[shm_n_].put_image(compositor_->widget(), static_cast<GC>(gc_), rect);
+    // Swap to other surface for next draw
+    // Could use sync if we only want 1 surface but that wastes time
+    //  XSync(display_, false);
+    shm_n_ = (shm_n_ + 1) % 2;
+    surface_ = shm_descs_[shm_n_].use_surface();
+  }
+  else
+  {
+    // TODO(jbauman): Switch to XShmPutImage since it's async.
+    SkImageInfo info;
+    size_t rowBytes;
+    const void* addr = surface_->peekPixels(&info, &rowBytes);
+    gfx::PutARGBImage(
+        display_, attributes_.visual, attributes_.depth, compositor_->widget(),
+        gc_, static_cast<const uint8_t*>(addr), viewport_pixel_size_.width(),
+        viewport_pixel_size_.height(), rect.x(), rect.y(), rect.x(), rect.y(),
+        rect.width(), rect.height());
+  }
 }
 
 }  // namespace content
diff --git a/src/content/browser/compositor/software_output_device_x11.h b/src/content/browser/compositor/software_output_device_x11.h
index 9fe571d..7dea7f8 100644
--- a/src/content/browser/compositor/software_output_device_x11.h
+++ b/src/content/browser/compositor/software_output_device_x11.h
@@ -6,11 +6,15 @@
 #define CONTENT_BROWSER_COMPOSITOR_SOFTWARE_OUTPUT_DEVICE_X11_H_
 
 #include <X11/Xlib.h>
+#include <X11/extensions/XShm.h>
 
 #include "base/macros.h"
 #include "cc/output/software_output_device.h"
 #include "ui/gfx/x/x11_types.h"
 
+#include <sys/ipc.h>
+#include <sys/shm.h>
+
 namespace ui {
 class Compositor;
 }
@@ -24,13 +28,38 @@ class SoftwareOutputDeviceX11 : public cc::SoftwareOutputDevice {
   ~SoftwareOutputDeviceX11() override;
 
   void EndPaint() override;
+  void Resize(const gfx::Size& viewport_pixel_size, float scale_factor) override;
 
  private:
   ui::Compositor* compositor_;
-  XDisplay* display_;
+  XDisplay* const display_;
   GC gc_;
   XWindowAttributes attributes_;
 
+  // Shared memory stuff
+
+  int shm_n_;
+  class ShmDesc
+  {
+      XShmSegmentInfo shminfo_;
+      XImage * shmimg_;
+      XDisplay* display_;
+      XWindowAttributes window_attributes_;
+      sk_sp<SkSurface> surface_;
+      SkImageInfo req_ii_;
+      SkImageInfo cur_ii_;
+
+public:
+      ShmDesc();
+      virtual ~ShmDesc();
+      int attach(XDisplay * const display, const XWindowAttributes& attributes, const int stride, const int h);
+      void detach();
+      void destroy();
+      void resize(const SkImageInfo& info);
+      Bool put_image(Drawable drawable, GC gc, const gfx::Rect& rect);
+      sk_sp<SkSurface> use_surface();
+  } shm_descs_[2];
+
   DISALLOW_COPY_AND_ASSIGN(SoftwareOutputDeviceX11);
 };
 
diff --git a/src/content/browser/renderer_host/render_process_host_impl.cc b/src/content/browser/renderer_host/render_process_host_impl.cc
index d565491..7edd263 100644
--- a/src/content/browser/renderer_host/render_process_host_impl.cc
+++ b/src/content/browser/renderer_host/render_process_host_impl.cc
@@ -1565,6 +1565,9 @@ void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
 #if defined(OS_CHROMEOS)
     switches::kDisableVaapiAcceleratedVideoEncode,
 #endif
+    switches::kMmalFrameBuffers, switches::kMmalZeroCopy,
+    switches::kMmalFrameCopy, switches::kMmalSliceCopy,
+    switches::kMmalRedPixel, switches::kMmalDecoders,
   };
   renderer_cmd->CopySwitchesFrom(browser_cmd, kSwitchNames,
                                  arraysize(kSwitchNames));
diff --git a/src/content/browser/renderer_host/sandbox_ipc_linux.cc b/src/content/browser/renderer_host/sandbox_ipc_linux.cc
index 94a34b5..4afd1d8 100644
--- a/src/content/browser/renderer_host/sandbox_ipc_linux.cc
+++ b/src/content/browser/renderer_host/sandbox_ipc_linux.cc
@@ -156,6 +156,12 @@ void SandboxIPCHandler::HandleRequestFromRenderer(int fd) {
     HandleMakeSharedMemorySegment(fd, iter, fds);
   } else if (kind == LinuxSandbox::METHOD_MATCH_WITH_FALLBACK) {
     HandleMatchWithFallback(fd, iter, fds);
+  } else if (kind == LinuxSandbox::METHOD_OPEN_DEV_VCHIQ) {
+    HandleOpenDevVchiq(fd, iter, fds);
+  }
+  else
+  {
+    LOG(ERROR) << "Unexpected kind=" << kind;
   }
 }
 
@@ -349,6 +355,27 @@ void SandboxIPCHandler::HandleMakeSharedMemorySegment(
   SendRendererReply(fds, reply, shm_fd);
 }
 
+void SandboxIPCHandler::HandleOpenDevVchiq(
+    int fd,
+    base::PickleIterator iter,
+    const std::vector<base::ScopedFD>& fds) {
+
+  int vchiq_fd = IGNORE_EINTR(open("/dev/vchiq", O_RDWR));
+
+  if (vchiq_fd == -1) {
+    int e = errno;
+    LOG(ERROR) << "Failed to open vchiq: errno=" << e;
+  }
+
+  base::Pickle reply;
+  SendRendererReply(fds, reply, vchiq_fd);
+
+  if (vchiq_fd >= 0) {
+    if (IGNORE_EINTR(close(vchiq_fd)) < 0)
+      PLOG(ERROR) << "close";
+  }
+}
+
 void SandboxIPCHandler::HandleMatchWithFallback(
     int fd,
     base::PickleIterator iter,
diff --git a/src/content/browser/renderer_host/sandbox_ipc_linux.h b/src/content/browser/renderer_host/sandbox_ipc_linux.h
index f1a6bd5..42f8345 100644
--- a/src/content/browser/renderer_host/sandbox_ipc_linux.h
+++ b/src/content/browser/renderer_host/sandbox_ipc_linux.h
@@ -61,6 +61,10 @@ class SandboxIPCHandler : public base::DelegateSimpleThread::Delegate {
                                base::PickleIterator iter,
                                const std::vector<base::ScopedFD>& fds);
 
+  void HandleOpenDevVchiq(int fd,
+                               base::PickleIterator iter,
+                               const std::vector<base::ScopedFD>& fds);
+
   void SendRendererReply(const std::vector<base::ScopedFD>& fds,
                          const base::Pickle& reply,
                          int reply_fd);
diff --git a/src/content/common/sandbox_linux/sandbox_linux.h b/src/content/common/sandbox_linux/sandbox_linux.h
index 7ce723b..5b2c013 100644
--- a/src/content/common/sandbox_linux/sandbox_linux.h
+++ b/src/content/common/sandbox_linux/sandbox_linux.h
@@ -52,6 +52,7 @@ class LinuxSandbox {
     METHOD_GET_STYLE_FOR_STRIKE = 35,
     METHOD_MAKE_SHARED_MEMORY_SEGMENT = 36,
     METHOD_MATCH_WITH_FALLBACK = 37,
+    METHOD_OPEN_DEV_VCHIQ,
   };
 
   // Get our singleton instance.
diff --git a/src/media/audio/alsa/alsa_output.cc b/src/media/audio/alsa/alsa_output.cc
index 9216def..f9ab901 100644
--- a/src/media/audio/alsa/alsa_output.cc
+++ b/src/media/audio/alsa/alsa_output.cc
@@ -134,7 +134,10 @@ const char AlsaPcmOutputStream::kPlugPrefix[] = "plug:";
 
 // We use 40ms as our minimum required latency. If it is needed, we may be able
 // to get it down to 20ms.
-const uint32_t AlsaPcmOutputStream::kMinLatencyMicros = 40 * 1000;
+// ** When life gets hard we don't seem to cycle fast enough for 40ms to be
+// long enough (actually it is approx half that as we put off reload until
+// half full)
+const uint32_t AlsaPcmOutputStream::kMinLatencyMicros = 200 * 1000;
 
 AlsaPcmOutputStream::AlsaPcmOutputStream(const std::string& device_name,
                                          const AudioParameters& params,
@@ -480,26 +483,28 @@ void AlsaPcmOutputStream::WritePacket() {
 void AlsaPcmOutputStream::WriteTask() {
   DCHECK(IsOnAudioThread());
 
-  if (stop_stream_)
-    return;
+  bool source_exhausted;
 
-  if (state() == kIsStopped)
-    return;
+  do
+  {
+    if (stop_stream_)
+      return;
 
-  bool source_exhausted;
-  BufferPacket(&source_exhausted);
-  WritePacket();
+    if (state() == kIsStopped)
+      return;
 
-  ScheduleNextWrite(source_exhausted);
+    BufferPacket(&source_exhausted);
+    WritePacket();
+  } while (ScheduleNextWrite(source_exhausted));
 }
 
-void AlsaPcmOutputStream::ScheduleNextWrite(bool source_exhausted) {
+bool AlsaPcmOutputStream::ScheduleNextWrite(bool source_exhausted) {
   DCHECK(IsOnAudioThread());
 
   if (stop_stream_ || state() != kIsPlaying)
-    return;
+    return false;
 
-  const uint32_t kTargetFramesAvailable = alsa_buffer_frames_ / 2;
+  const uint32_t kTargetFramesAvailable = frames_per_packet_;
   uint32_t available_frames = GetAvailableFrames();
 
   base::TimeDelta next_fill_time;
@@ -527,9 +532,14 @@ void AlsaPcmOutputStream::ScheduleNextWrite(bool source_exhausted) {
     next_fill_time = base::TimeDelta::FromMilliseconds(10);
   }
 
+  if (next_fill_time.is_zero()) {
+    return true;
+  }
+
   message_loop_->PostDelayedTask(FROM_HERE, base::Bind(
       &AlsaPcmOutputStream::WriteTask, weak_factory_.GetWeakPtr()),
       next_fill_time);
+  return false;
 }
 
 // static
diff --git a/src/media/audio/alsa/alsa_output.h b/src/media/audio/alsa/alsa_output.h
index e67253f..9586477 100644
--- a/src/media/audio/alsa/alsa_output.h
+++ b/src/media/audio/alsa/alsa_output.h
@@ -126,7 +126,7 @@ class MEDIA_EXPORT AlsaPcmOutputStream : public AudioOutputStream {
   void BufferPacket(bool* source_exhausted);
   void WritePacket();
   void WriteTask();
-  void ScheduleNextWrite(bool source_exhausted);
+  bool ScheduleNextWrite(bool source_exhausted);
 
   // Utility functions for talking with the ALSA API.
   static base::TimeDelta FramesToTimeDelta(int frames, double sample_rate);
diff --git a/src/media/base/media_switches.cc b/src/media/base/media_switches.cc
index baa93f9..6a53320 100644
--- a/src/media/base/media_switches.cc
+++ b/src/media/base/media_switches.cc
@@ -114,6 +114,13 @@ const char kVideoUnderflowThresholdMs[] = "video-underflow-threshold-ms";
 const char kDisableRTCSmoothnessAlgorithm[] =
     "disable-rtc-smoothness-algorithm";
 
+const char kMmalFrameBuffers[]              = "mmal-frame-buffers";
+const char kMmalZeroCopy[]                  = "mmal-zero-copy";
+const char kMmalFrameCopy[]                 = "mmal-frame-copy";
+const char kMmalSliceCopy[]                 = "mmal-slice-copy";
+const char kMmalRedPixel[]                  = "mmal-red-pixel";
+const char kMmalDecoders[]                  = "mmal-decoders";
+
 }  // namespace switches
 
 namespace media {
diff --git a/src/media/base/media_switches.h b/src/media/base/media_switches.h
index 2fbbb4f..aa48c8b 100644
--- a/src/media/base/media_switches.h
+++ b/src/media/base/media_switches.h
@@ -61,6 +61,13 @@ MEDIA_EXPORT extern const char kVideoUnderflowThresholdMs[];
 
 MEDIA_EXPORT extern const char kDisableRTCSmoothnessAlgorithm[];
 
+MEDIA_EXPORT extern const char kMmalFrameBuffers[];
+MEDIA_EXPORT extern const char kMmalZeroCopy[];
+MEDIA_EXPORT extern const char kMmalFrameCopy[];
+MEDIA_EXPORT extern const char kMmalSliceCopy[];
+MEDIA_EXPORT extern const char kMmalRedPixel[];
+MEDIA_EXPORT extern const char kMmalDecoders[];
+
 }  // namespace switches
 
 namespace media {
diff --git a/src/media/base/video_frame.cc b/src/media/base/video_frame.cc
index b4a8392f..1770163 100644
--- a/src/media/base/video_frame.cc
+++ b/src/media/base/video_frame.cc
@@ -121,7 +121,7 @@ bool VideoFrame::IsValidConfig(VideoPixelFormat format,
     return true;
 
   // Make sure new formats are properly accounted for in the method.
-  static_assert(PIXEL_FORMAT_MAX == 21,
+  static_assert(PIXEL_FORMAT_MAX == 22,
                 "Added pixel format, please review IsValidConfig()");
 
   if (format == PIXEL_FORMAT_UNKNOWN) {
@@ -521,6 +521,7 @@ size_t VideoFrame::NumPlanes(VideoPixelFormat format) {
     case PIXEL_FORMAT_RGB24:
     case PIXEL_FORMAT_RGB32:
     case PIXEL_FORMAT_MJPEG:
+    case PIXEL_FORMAT_MMAL_BUFFER:
       return 1;
     case PIXEL_FORMAT_NV12:
     case PIXEL_FORMAT_NV21:
@@ -799,14 +800,6 @@ scoped_refptr<VideoFrame> VideoFrame::WrapExternalStorage(
     size_t data_offset) {
   DCHECK(IsStorageTypeMappable(storage_type));
 
-  // TODO(miu): This function should support any pixel format.
-  // http://crbug.com/555909
-  if (format != PIXEL_FORMAT_I420) {
-    LOG(DFATAL) << "Only PIXEL_FORMAT_I420 format supported: "
-                << VideoPixelFormatToString(format);
-    return nullptr;
-  }
-
   if (!IsValidConfig(format, storage_type, coded_size, visible_rect,
                      natural_size)) {
     LOG(DFATAL) << __FUNCTION__ << " Invalid config."
@@ -823,16 +816,33 @@ scoped_refptr<VideoFrame> VideoFrame::WrapExternalStorage(
     frame = new VideoFrame(format, storage_type, coded_size, visible_rect,
                            natural_size, timestamp);
   }
-  frame->strides_[kYPlane] = coded_size.width();
-  // TODO(miu): This always rounds widths down, whereas VideoFrame::RowBytes()
-  // always rounds up.  This inconsistency must be resolved.  Perhaps a
-  // CommonAlignment() check should be made in IsValidConfig()?
-  // http://crbug.com/555909
-  frame->strides_[kUPlane] = coded_size.width() / 2;
-  frame->strides_[kVPlane] = coded_size.width() / 2;
-  frame->data_[kYPlane] = data;
-  frame->data_[kUPlane] = data + coded_size.GetArea();
-  frame->data_[kVPlane] = data + (coded_size.GetArea() * 5 / 4);
+
+  switch (format) {
+    case PIXEL_FORMAT_I420:
+      frame->strides_[kYPlane] = coded_size.width();
+      // TODO(miu): This always rounds widths down, whereas VideoFrame::RowBytes()
+      // always rounds up.  This inconsistency must be resolved.  Perhaps a
+      // CommonAlignment() check should be made in IsValidConfig()?
+      // http://crbug.com/555909
+      frame->strides_[kUPlane] = coded_size.width() / 2;
+      frame->strides_[kVPlane] = coded_size.width() / 2;
+      frame->data_[kYPlane] = data;
+      frame->data_[kUPlane] = data + coded_size.GetArea();
+      frame->data_[kVPlane] = data + (coded_size.GetArea() * 5 / 4);
+      break;
+
+    case PIXEL_FORMAT_MMAL_BUFFER:
+    case PIXEL_FORMAT_ARGB:
+      frame->strides_[kARGBPlane] = data_size / coded_size.height();
+      frame->data_[kARGBPlane] = data;
+      break;
+
+    default:
+      LOG(DFATAL) << "Format not supported: "
+                  << VideoPixelFormatToString(format);
+      return nullptr;
+  }
+
   return frame;
 }
 
@@ -961,17 +971,19 @@ scoped_refptr<VideoFrame> VideoFrame::CreateFrameInternal(
     const gfx::Size& natural_size,
     base::TimeDelta timestamp,
     bool zero_initialize_memory) {
+#if 0
   if (!IsYuvPlanar(format)) {
     NOTIMPLEMENTED();
     return nullptr;
   }
-
+#endif
   // Since we're creating a new YUV frame (and allocating memory for it
   // ourselves), we can pad the requested |coded_size| if necessary if the
   // request does not line up on sample boundaries. See discussion at
   // http://crrev.com/1240833003
   const gfx::Size new_coded_size = DetermineAlignedSize(format, coded_size);
   const StorageType storage = STORAGE_OWNED_MEMORY;
+//  const StorageType storage = STORAGE_HOLE;
   if (!IsValidConfig(format, storage, new_coded_size, visible_rect,
                      natural_size)) {
     LOG(DFATAL) << __FUNCTION__ << " Invalid config."
@@ -1026,6 +1038,7 @@ gfx::Size VideoFrame::SampleSize(VideoPixelFormat format, size_t plane) {
         case PIXEL_FORMAT_RGB24:
         case PIXEL_FORMAT_RGB32:
         case PIXEL_FORMAT_MJPEG:
+        case PIXEL_FORMAT_MMAL_BUFFER:
           break;
       }
   }
@@ -1040,6 +1053,7 @@ int VideoFrame::BytesPerElement(VideoPixelFormat format, size_t plane) {
     case PIXEL_FORMAT_ARGB:
     case PIXEL_FORMAT_XRGB:
     case PIXEL_FORMAT_RGB32:
+    case PIXEL_FORMAT_MMAL_BUFFER:
       return 4;
     case PIXEL_FORMAT_RGB24:
       return 3;
diff --git a/src/media/base/video_frame.h b/src/media/base/video_frame.h
index 944a040..460c806 100644
--- a/src/media/base/video_frame.h
+++ b/src/media/base/video_frame.h
@@ -33,6 +33,8 @@ namespace media {
 
 class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
  public:
+  typedef base::Callback<void(const gfx::Size&)> MmalResizeCB;
+
   enum {
     kFrameSizeAlignment = 16,
     kFrameSizePadding = 16,
@@ -318,6 +320,9 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
   // accessed via data(), visible_data() etc.
   bool HasTextures() const;
 
+  // Mmal resize kludge info
+  MmalResizeCB mmal_resize_cb_;
+
   VideoPixelFormat format() const { return format_; }
   StorageType storage_type() const { return storage_type_; }
 
diff --git a/src/media/base/video_types.cc b/src/media/base/video_types.cc
index f8eeb3e..82445f4 100644
--- a/src/media/base/video_types.cc
+++ b/src/media/base/video_types.cc
@@ -54,6 +54,8 @@ std::string VideoPixelFormatToString(VideoPixelFormat format) {
       return "PIXEL_FORMAT_YUV444P9";
     case PIXEL_FORMAT_YUV444P10:
       return "PIXEL_FORMAT_YUV444P10";
+    case PIXEL_FORMAT_MMAL_BUFFER:
+      return "PIXEL_FORMAT_MMAL_BUFFER";
   }
   NOTREACHED() << "Invalid VideoPixelFormat provided: " << format;
   return "";
@@ -75,6 +77,7 @@ bool IsYuvPlanar(VideoPixelFormat format) {
     case PIXEL_FORMAT_YUV422P10:
     case PIXEL_FORMAT_YUV444P9:
     case PIXEL_FORMAT_YUV444P10:
+    case PIXEL_FORMAT_MMAL_BUFFER:
       return true;
 
     case PIXEL_FORMAT_UNKNOWN:
@@ -111,6 +114,7 @@ bool IsOpaque(VideoPixelFormat format) {
     case PIXEL_FORMAT_YUV422P10:
     case PIXEL_FORMAT_YUV444P9:
     case PIXEL_FORMAT_YUV444P10:
+    case PIXEL_FORMAT_MMAL_BUFFER:
       return true;
     case PIXEL_FORMAT_YV12A:
     case PIXEL_FORMAT_ARGB:
diff --git a/src/media/base/video_types.h b/src/media/base/video_types.h
index 7590b1b..ecf52e6 100644
--- a/src/media/base/video_types.h
+++ b/src/media/base/video_types.h
@@ -54,9 +54,11 @@ enum VideoPixelFormat {
   PIXEL_FORMAT_YUV444P9 = 20,
   PIXEL_FORMAT_YUV444P10 = 21,
 
+  PIXEL_FORMAT_MMAL_BUFFER = 22,
+
   // Please update UMA histogram enumeration when adding new formats here.
-  PIXEL_FORMAT_MAX =
-      PIXEL_FORMAT_YUV444P10,  // Must always be equal to largest entry logged.
+  PIXEL_FORMAT_MAX = PIXEL_FORMAT_MMAL_BUFFER
+//      PIXEL_FORMAT_YUV444P10,  // Must always be equal to largest entry logged.
 };
 
 // Color space or color range used for the pixels.
diff --git a/src/media/filters/decoder_stream.h b/src/media/filters/decoder_stream.h
index a7f084f..686aa1a 100644
--- a/src/media/filters/decoder_stream.h
+++ b/src/media/filters/decoder_stream.h
@@ -160,6 +160,9 @@ class MEDIA_EXPORT DecoderStream {
   // Output callback passed to Decoder::Initialize().
   void OnDecodeOutputReady(const scoped_refptr<Output>& output);
 
+  // "Read" when at EOS
+  void ReadFromEOS();
+
   // Reads a buffer from |stream_| and returns the result via OnBufferReady().
   void ReadFromDemuxerStream();
 
@@ -225,6 +228,9 @@ class MEDIA_EXPORT DecoderStream {
   // Tracks the duration of incoming packets over time.
   MovingAverage duration_tracker_;
 
+  // Have a delayed eos read already pending
+  bool pending_eos_decode_;
+
   // NOTE: Weak pointers must be invalidated before all other member variables.
   base::WeakPtrFactory<DecoderStream<StreamType> > weak_factory_;
 };
diff --git a/src/media/filters/mmal_video_decoder.cc b/src/media/filters/mmal_video_decoder.cc
new file mode 100644
index 0000000..682d0c5
--- /dev/null
+++ b/src/media/filters/mmal_video_decoder.cc
@@ -0,0 +1,2089 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/filters/mmal_video_decoder.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <algorithm>
+#include <string>
+
+#include "base/base_switches.h"
+#include "base/bind.h"
+#include "base/callback_helpers.h"
+#include "base/command_line.h"
+#include "base/location.h"
+#include "base/single_thread_task_runner.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/pickle.h"
+#include "base/posix/unix_domain_socket_linux.h"
+#include "media/base/bind_to_current_loop.h"
+#include "media/base/decoder_buffer.h"
+#include "media/base/limits.h"
+#include "media/base/media_switches.h"
+#include "media/base/timestamp_constants.h"
+#include "media/base/video_frame.h"
+#include "media/base/video_util.h"
+#include "content/common/child_process_sandbox_support_impl_linux.h"
+#include "content/common/sandbox_linux/sandbox_linux.h"
+#include "content/public/common/content_switches.h"
+
+#include <interface/mmal/mmal.h>
+#include <interface/mmal/mmal_buffer.h>
+#include <interface/mmal/mmal_parameters_video.h>
+#include <interface/mmal/util/mmal_util.h>
+#include <interface/mmal/util/mmal_util_params.h>
+#include <interface/mmal/util/mmal_default_components.h>
+#include <interface/mmal/util/mmal_connection.h>
+#include <interface/mmal/core/mmal_buffer_private.h>  // *** debug
+#include <interface/mmal/vc/mmal_vc_api.h>
+
+// Missing defn
+#define MMAL_COMPONENT_DEFAULT_RESIZER "vc.ril.resize"
+
+#define MMAL_SLICE_HEIGHT 16
+#define MMAL_ALIGN_W      32
+#define MMAL_ALIGN_H      16
+
+#define MMAL_LIMIT_WIDTH  VCOS_ALIGN_UP(1920, MMAL_ALIGN_W)
+#define MMAL_LIMIT_HEIGHT VCOS_ALIGN_UP(1088, MMAL_ALIGN_H)
+
+#define FRAME_COPY_DEFAULT_BUFFERS      2
+#define SLICE_COPY_DEFAULT_BUFFERS      16
+#define ZERO_COPY_DEFAULT_BUFFERS       6
+
+#define MAX_COPY_FRAMES_IN_FLIGHT       6
+
+namespace media {
+
+enum FrameCopyMode {
+  unset,
+  SLICE,
+  FRAME,
+  ZERO
+};
+
+// Only want/need to init mmal/vchiq once (per-process)
+// This checks it
+static bool vchiq_init_done = false;
+
+// Not strictly a decoder count - this is inced @ initialisation
+static volatile base::subtle::Atomic32 decoder_count = 0;
+
+// Task runner - current SingleThread - probably no reason
+// why it shouldn't be Sequenced so typedef for ease of changing
+typedef scoped_refptr<base::SingleThreadTaskRunner> MmalTaskRunner;
+
+// Trampoline class
+// This allows us to attach callbacks from VideoFrames to our
+// component / port without it locking down the component.
+// If the component is dead by the time the callback arrives then it is simply
+// dropped on the floor
+class MmalTrampoline : public base::RefCountedThreadSafe<MmalTrampoline>
+{
+  base::Lock lock_;
+  VideoFrame::MmalResizeCB resize_cb_;
+  base::Closure destruction_cb_;
+
+  void resize_trampoline(const gfx::Size& size)
+  {
+//    LOG(ERROR) << __func__ ;
+    base::AutoLock lock(lock_);
+    if (!resize_cb_.is_null())
+      resize_cb_.Run(size);
+  }
+
+  void destruction_trampoline()
+  {
+//    LOG(ERROR) << __func__;
+    base::AutoLock lock(lock_);
+    if (!destruction_cb_.is_null())
+      destruction_cb_.Run();
+  }
+
+
+  friend base::RefCountedThreadSafe<MmalTrampoline>;
+  virtual ~MmalTrampoline()
+  {
+//    LOG(ERROR) << __func__ << n_;
+  }
+public:
+  MmalTrampoline(const VideoFrame::MmalResizeCB& resize_cb,
+                 const base::Closure& destruction_cb) :
+    resize_cb_(resize_cb),
+    destruction_cb_(destruction_cb)
+  {
+//    LOG(ERROR) << __func__;
+  }
+
+  VideoFrame::MmalResizeCB new_resize_cb()
+  {
+//    LOG(ERROR) << __func__;
+    return base::Bind(&MmalTrampoline::resize_trampoline, this);
+  }
+
+  base::Closure new_destruction_cb()
+  {
+//    LOG(ERROR) << __func__;
+    return base::Bind(&MmalTrampoline::destruction_trampoline, this);
+  }
+
+
+  void kill()
+  {
+    base::AutoLock lock(lock_);
+    resize_cb_.Reset();
+    destruction_cb_.Reset();
+  }
+};
+
+
+// Wrapper for an mmal port
+class MmalPort
+{
+  // Actually connection should be a subclass?
+  friend class MmalConnection;
+
+
+protected:
+  MMAL_PORT_T * port_;
+  bool killing_;
+
+  virtual void event_cb(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    LOG(ERROR) << "### Unexpected ES data";
+    mmal_buffer_header_release(buffer);
+  }
+
+  virtual void cmd_cb(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    if (buffer->cmd == MMAL_EVENT_ERROR) {
+        LOG(WARNING) << "### Mmal reports error " << *(uint32_t *)buffer->data;
+    } else if (buffer->cmd == MMAL_EVENT_FORMAT_CHANGED) {
+      mmal_log_dump_port(port_);
+      const MMAL_EVENT_FORMAT_CHANGED_T *const fc = mmal_event_format_changed_get(buffer);
+      LOG(INFO) << "Mmal format changed: size_min:" << fc->buffer_size_min <<
+        ", num_min:" << fc->buffer_num_min <<
+          ", size_rec:" << fc->buffer_size_recommended <<
+          ", num_rec:" << fc->buffer_num_recommended;
+      if (fc->format != NULL) {
+        mmal_log_dump_format(fc->format);
+      }
+    } else {
+        char s[20];
+        LOG(WARNING) << "### Mmal unexpected command: " << mmal_4cc_to_string(s, sizeof(s), buffer->cmd);
+    }
+
+    // Commands are allocated from a different pool to ES data
+    // return to sender...
+    mmal_buffer_header_release(buffer);
+  }
+
+private:
+  void callback_common(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    if (buffer->cmd != 0) {
+      // Cmd buffers are not allocated from the main pool
+      cmd_cb(buffer);
+    }
+    else
+    {
+      if (killing_) {
+        // If flushing always release the buffer
+        mmal_buffer_header_release(buffer);
+      }
+      else {
+        event_cb(buffer);
+      }
+    }
+  }
+
+  static void callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
+  {
+    MmalPort *p = static_cast<MmalPort*>((void*)port->userdata);
+
+    if (p == NULL) {
+      LOG(ERROR) << __func__ << "### Port NULL";
+    }
+    else
+    {
+      p->callback_common(buffer);
+    }
+  }
+
+public:
+  virtual int enable()
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+
+    if (killing_) {
+      LOG(ERROR) << "### port enable when killed";
+      return -1;
+    }
+
+    if ((err = mmal_port_enable(port_, callback)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_port_enable failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  virtual int disable()
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+
+    if (port_ != NULL && port_->is_enabled) {
+      err = mmal_port_disable(port_);
+    }
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  int commit()
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+
+    if ((err = mmal_port_format_commit(port_)) != MMAL_SUCCESS)
+    {
+      LOG(ERROR) << "### mmal_port_format_commit failed: err=" << err;
+      mmal_log_dump_port(port_);
+    }
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  int set_parameter(const uint32_t param, const uint32_t val) const
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+    if ((err = mmal_port_parameter_set_uint32(port_, param, val)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_port_parameter_set_uint32 failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  int set_parameter(const uint32_t param, const bool val) const
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+    if ((err = mmal_port_parameter_set_boolean(port_, param, val ? MMAL_TRUE : MMAL_FALSE)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_port_parameter_set_boolean failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  int get_parameter(MMAL_PARAMETER_HEADER_T * const param) const
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+    if ((err = mmal_port_parameter_get(port_, param)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_port_parameter_get failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  class SupportedEncodings
+  {
+    static const int max_encodings_ = 64;
+    struct {
+       MMAL_PARAMETER_HEADER_T header_;
+       MMAL_FOURCC_T encodings_[max_encodings_];
+    } supported_;
+    int n;
+
+  public:
+    SupportedEncodings(const MmalPort& port) :
+      supported_({{MMAL_PARAMETER_SUPPORTED_ENCODINGS, sizeof(supported_)}, {0}}),
+      n(-1)
+    {
+      if (port.get_parameter(&supported_.header_) == 0)
+      {
+        n = (supported_.header_.size - sizeof(supported_.header_)) /
+          sizeof(supported_.encodings_[0]);
+      }
+    }
+
+    virtual ~SupportedEncodings()
+    {
+    }
+
+    // Default copy is OK
+
+    bool is_supported(const MMAL_FOURCC_T x) const
+    {
+      // If we end up doing this a lot for any reason then use a better lookup
+      for (int i = 0; i < n; ++i) {
+        if (x == supported_.encodings_[i]) {
+          return true;
+        }
+      }
+      return false;
+    }
+  };
+
+  SupportedEncodings get_parameter_supported_encodings() const
+  {
+    return SupportedEncodings(*this);
+  }
+
+  static MMAL_FOURCC_T color_space_to_mmal(const ColorSpace color_space)
+  {
+    switch (color_space) {
+      case ColorSpace::COLOR_SPACE_JPEG:
+        return MMAL_COLOR_SPACE_JPEG_JFIF;
+      case ColorSpace::COLOR_SPACE_HD_REC709:
+        return MMAL_COLOR_SPACE_ITUR_BT709;
+      case ColorSpace::COLOR_SPACE_SD_REC601:
+        return MMAL_COLOR_SPACE_ITUR_BT601;
+      case ColorSpace::COLOR_SPACE_UNSPECIFIED:
+        return MMAL_COLOR_SPACE_UNKNOWN;
+    }
+    return MMAL_COLOR_SPACE_UNKNOWN;
+  }
+
+  // Fill in all of a MMAL_VIDEO_FORMAT_T
+  void set_video_format(
+      const gfx::Size& size,
+      const gfx::Size& par = gfx::Size(),
+      const ColorSpace color_space = ColorSpace::COLOR_SPACE_UNSPECIFIED) const
+  {
+    MMAL_VIDEO_FORMAT_T *const video = &port_->format->es->video;
+
+    const uint32_t w = size.width();
+    const uint32_t h = size.height();
+
+    video->width = VCOS_ALIGN_UP(w, 32);
+    video->height = VCOS_ALIGN_UP(h, 16);
+    video->crop.x = 0;
+    video->crop.y = 0;
+    video->crop.width = w;
+    video->crop.height = h;
+    video->frame_rate.num = 30000;  // Not in config - make something valid up
+    video->frame_rate.den = 1001;
+    video->par.num = par.width();
+    video->par.den = par.height();
+    video->color_space = color_space_to_mmal(color_space);
+  }
+
+  // Disable once we forget about it
+  virtual ~MmalPort()
+  {
+//    LOG(ERROR) << __func__;
+    disable();
+  }
+
+  MmalPort() :
+    port_(NULL),
+    killing_(false)
+  {
+//    LOG(ERROR) << __func__;
+  }
+
+  virtual void set_port(MMAL_PORT_T * const port)
+  {
+    if (port_ != NULL) {
+      LOG(ERROR) << "### Port not null";
+      return;
+    }
+
+    port->userdata = (struct MMAL_PORT_USERDATA_T *)(void *)this;
+    port_ = port;
+  }
+
+  int buffer_size(const uint32_t size, const uint32_t num, const bool zero_copy) const
+  {
+    port_->buffer_size = std::max(port_->buffer_size_min, size);
+    port_->buffer_num = std::max(port_->buffer_num_min, num);
+    return set_parameter(MMAL_PARAMETER_ZERO_COPY, zero_copy);
+  }
+
+  // Submit a buffer - on failure (or kill) buffer is released
+  int submit(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    MMAL_STATUS_T err;
+
+    if (killing_ || !port_->is_enabled) {
+//      LOG(ERROR) << "submit: buffer flushed";
+      mmal_buffer_header_release(buffer);
+      return 0;
+    }
+
+    if ((err = mmal_port_send_buffer(port_, buffer)) != MMAL_SUCCESS)
+    {
+      // Release buffer on error
+      mmal_buffer_header_release(buffer);
+      LOG(ERROR) << "#### %s: mmal_send_buffer failed: err=" << err;
+    }
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  void kill()
+  {
+    killing_ = true;
+    disable();
+  }
+};
+
+// ---------------------------------------------------------------------------
+
+class MmalConnectedPort;
+
+class MmalConnection : public base::RefCountedThreadSafe<MmalConnection>
+{
+  friend MmalConnectedPort;
+
+  bool enabled_;
+  MMAL_CONNECTION_T * connection_;
+  MmalConnectedPort * src_;
+  MmalConnectedPort * dest_;
+
+  friend base::RefCountedThreadSafe<MmalConnection>;
+  virtual ~MmalConnection()
+  {
+//    LOG(ERROR) << __func__;
+    if (connection_ != NULL) {
+      mmal_connection_destroy(connection_);
+    }
+  }
+
+  MmalConnection() :
+    enabled_(false),
+    connection_(NULL),
+    src_(NULL),
+    dest_(NULL)
+  {
+//    LOG(ERROR) << __func__;
+  }
+
+  void disconnect();
+  int connect(MmalConnectedPort * const src, MmalConnectedPort * const dest);
+
+  int enable()
+  {
+    MMAL_STATUS_T err;
+
+    if (enabled_) {
+      // Bad stuff (tm) seems to happen if we multiply en/disable connections
+      return 0;
+    }
+
+    if ((err = mmal_connection_enable(connection_)) != MMAL_SUCCESS) {
+      LOG(ERROR) << "### mmal_connection_enable failed: err=" << err;
+      return -1;
+    }
+
+    enabled_ = true;
+    return 0;
+  }
+
+  int disable()
+  {
+    MMAL_STATUS_T err;
+
+    if (!enabled_) {
+      // Bad stuff (tm) seems to happen if we multiply en/disable connections
+      return 0;
+    }
+
+    // Mark as disabled even if we fail as in this case I have no idea how
+    // to recover and retry is very unlikely to help
+    enabled_ = false;
+
+    if ((err = mmal_connection_disable(connection_)) != MMAL_SUCCESS) {
+      LOG(ERROR) << "### mmal_connection_disable failed: err=" << err;
+      return -1;
+    }
+
+    return 0;
+  }
+};
+
+// ----------------------------------------------------------------------------
+
+class MmalConnectedPort : public MmalPort
+{
+  scoped_refptr<MmalConnection> connection_;
+
+public:
+  void set_connection(MmalConnection * connection)
+  {
+    connection_ = connection;
+  }
+
+  int disconnect()
+  {
+    if (connection_ != NULL) {
+      connection_->disconnect();
+    }
+    return 0;
+  }
+
+  int enable() override
+  {
+    return connection_->enable();
+  }
+
+  int disable() override
+  {
+    return connection_ == NULL ? 0 : connection_->disable();
+  }
+
+  int connect_to_src(MmalConnectedPort * const src)
+  {
+    scoped_refptr<MmalConnection> connection(new MmalConnection());
+    return connection->connect(src, this);
+  }
+
+  ~MmalConnectedPort() override
+  {
+    disconnect();
+  }
+};
+
+
+// ----------------------------------------------------------------------------
+
+class MmalComponent;
+
+class MmalPortPool : public MmalPort
+{
+  MmalComponent * const component_;
+
+  MMAL_POOL_T * pool_;
+
+  static MMAL_BOOL_T pool_cb(MMAL_POOL_T *pool, MMAL_BUFFER_HEADER_T *buffer, void *userdata)
+  {
+    MmalPortPool * const mpp = (MmalPortPool *)userdata;
+    // As the release can cause us to commit suicide we must put the buffer
+    // back by hand before calling Release as if we try to do it afterwards
+    // the Q may have vanished and we would crash.
+    mmal_queue_put(pool->queue, buffer);
+    mpp->Release();
+    return MMAL_FALSE;  // We did the put back ourselves
+  }
+
+public:
+  // These allow us to use scoped_refptr on this object
+  // They trampoline to the enclosing component
+  void AddRef() const;
+  void Release();
+  const MmalTaskRunner& task_runner() const;
+
+  template<typename T>
+  base::Callback<T> bind_to_task_runner(const base::Callback<T>& cb)
+  {
+    return base::Bind(&internal::TrampolineHelper<T>::Run,
+                      MmalTaskRunner(task_runner()), cb);
+  }
+  void task_run(const base::Closure& cb)
+  {
+    task_runner()->PostTask(FROM_HERE, cb);
+  }
+
+  MmalPortPool(MmalComponent * const component) :
+    component_(component),
+    pool_(NULL)
+  {
+//    LOG(ERROR) << __func__;
+  }
+
+  ~MmalPortPool() override
+  {
+    disable();
+
+    if (pool_ != NULL) {
+      mmal_port_pool_destroy(port_, pool_);
+    }
+  }
+
+  int create_pool()
+  {
+    if ((pool_ = mmal_port_pool_create(port_, port_->buffer_num, port_->buffer_size)) == NULL)
+    {
+      LOG(ERROR) << "### mmal_port_pool_create failed: " << port_->buffer_num << "*" << port_->buffer_size;
+      return -1;
+    }
+
+    mmal_pool_callback_set(pool_, pool_cb, this);
+    return 0;
+  }
+
+  MMAL_BUFFER_HEADER_T * pool_get(const bool wait = false)
+  {
+    if (pool_ == NULL) {
+      LOG(ERROR) << "### Pool not set up\n";
+      return NULL;
+    }
+
+    MMAL_BUFFER_HEADER_T * const header =  wait ?
+      mmal_queue_wait(pool_->queue) :
+      mmal_queue_get(pool_->queue);
+
+    if (header != NULL) {
+      AddRef();
+    }
+
+    return header;
+  }
+
+  int pool_size() const
+  {
+    return pool_->headers_num;
+  }
+
+  static void buffer_release(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    mmal_buffer_header_reset(buffer);
+    mmal_buffer_header_release(buffer);
+  }
+
+  // Stuff all the pool entries into the port
+  int stuff()
+  {
+    MMAL_BUFFER_HEADER_T * buffer;
+    while ((buffer = pool_get()) != NULL) {
+      // When flushing/disabling we may have left stuff with lengths in the pool
+      mmal_buffer_header_reset(buffer);
+      if (submit(buffer) != 0)
+        return -1;
+    }
+    return 0;
+  }
+
+  int stuff(int stuff_count, const bool wait = false)
+  {
+    while (--stuff_count >= 0)
+    {
+      MMAL_BUFFER_HEADER_T * buffer;
+      if ((buffer = pool_get(wait)) == NULL)
+      {
+        LOG(ERROR) << "### Unexpected pool_get_failure";
+        return -1;
+      }
+
+      // When flushing/disabling we may have left stuff with lengths in the pool
+      mmal_buffer_header_reset(buffer);
+      if (submit(buffer) != 0)
+        return -1;
+    }
+    return 0;
+  }
+
+};
+
+// ----------------------------------------------------------------------------
+
+
+class MmalVideoESPort : public MmalPortPool
+{
+  VideoDecoder::DecodeCB decode_cb_;
+  scoped_refptr<DecoderBuffer> submit_buffer_;
+  uint32_t submit_offset_;
+
+  static gfx::Size par_from_sizes(const gfx::Size& coded, const gfx::Size& natural)
+  {
+    uint32_t a = coded.width() * natural.height();
+    uint32_t b = coded.height() * natural.width();
+
+    // Deal with the trivial case
+
+    if (a == b) {
+      return gfx::Size(1, 1);
+    }
+
+    // reduce - probably not needed but it might well save overflow
+    // or precision reduction later in the code
+    // We only expect to do this at init time so inefficiency isn't important
+
+    static const uint32_t primes[] = {2, 3, 5, 7, 11, 13, 17, 19};
+    for (int i = 0; i != sizeof(primes)/sizeof(primes[0]); ++i) {
+      const uint32_t p = primes[i];
+      while (a % p == 0 && b % p == 0) {
+        a /= p;
+        b /= p;
+      }
+    }
+
+    return gfx::Size(b, a);
+  }
+
+public:
+  MmalVideoESPort(MmalComponent * const component) :
+    MmalPortPool(component)
+  {
+  }
+  ~MmalVideoESPort() override
+  {
+  }
+
+  void set_port(MMAL_PORT_T * const port) override
+  {
+    MmalPort::set_port(port);
+
+    port_->format->type = MMAL_ES_TYPE_VIDEO;
+    port_->format->encoding = MMAL_ENCODING_UNKNOWN;
+  }
+
+  int config(const VideoDecoderConfig& config)
+  {
+    MMAL_ES_FORMAT_T * const format = port_->format;
+
+    switch (config.codec()) {
+      case kCodecH264:
+        format->encoding = MMAL_ENCODING_H264;
+        break;
+      case kCodecVC1:
+        format->encoding = MMAL_ENCODING_WVC1;
+        break;
+      case kCodecMPEG2:
+        format->encoding = MMAL_ENCODING_MP2V;
+        break;
+      case kCodecMPEG4:
+        format->encoding = MMAL_ENCODING_MP4V;
+        break;
+      default:
+        LOG(ERROR) << "### Unexpected video codec:" << config.codec();
+        format->encoding = MMAL_ENCODING_UNKNOWN;
+        return -1;
+    }
+    format->flags = MMAL_ES_FORMAT_FLAG_FRAMED;
+
+    set_video_format(config.coded_size(),
+        par_from_sizes(config.coded_size(), config.natural_size()),
+        config.color_space());
+
+    return 0;
+  }
+
+private:
+  int submit_data(const uint8_t * const data, const uint32_t len,
+      const base::TimeDelta& pts,
+      const bool is_start, const bool not_pkt)
+  {
+    uint32_t bsent = 0;
+
+    MMAL_BUFFER_HEADER_T * const buffer = pool_get(not_pkt);
+    if (buffer == NULL) {
+      return 0;
+    }
+
+//    LOG(ERROR) << "-- submit len=" << len << ", pts=" << pts;
+
+    // resets length, offset, flags, pts, dts
+    mmal_buffer_header_reset(buffer);
+    buffer->cmd = 0;
+    buffer->user_data = NULL;
+
+    if (data == NULL)
+    {
+        static uint8_t zeros[8] = {0};
+
+        buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS;
+
+        buffer->data = zeros;
+        bsent = 1; // 0 means did nothing so pick another number
+    }
+    else
+    {
+        if (is_start)
+        {
+            buffer->pts = (pts == kNoTimestamp()) ? MMAL_TIME_UNKNOWN : pts.InMicroseconds();
+//            buffer->dts = avpkt->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->dts;
+            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START | MMAL_BUFFER_HEADER_FLAG_USER0;
+        }
+
+        bsent = buffer->length = std::min(len, buffer->alloc_size);
+
+        if (mmal_buffer_header_mem_lock(buffer) != MMAL_SUCCESS)
+        {
+            LOG(ERROR) << "#### Cannot lock buffer";
+            mmal_buffer_header_release(buffer);
+            return -1;
+        }
+
+        memcpy(buffer->data, data, buffer->length);
+
+        mmal_buffer_header_mem_unlock(buffer);
+
+        if (len == bsent)
+            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;
+
+        if (not_pkt)
+            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;
+    }
+
+//    LOG(ERROR) << "flags=" << buffer->flags;
+    if (MmalPortPool::submit(buffer) != 0)
+    {
+      return -1;
+    }
+
+    return (int)bsent;
+  }
+
+  void submit_done(const DecodeStatus status)
+  {
+    VideoDecoder::DecodeCB cb(decode_cb_);
+
+    decode_cb_.Reset();
+    submit_buffer_ = NULL;
+
+//    LOG(ERROR) << ">>> decode_cb.Run(" << status << ")";
+    cb.Run(status);
+  }
+
+  void submit_poll()
+  {
+    if (submit_buffer_ == NULL) {
+//      LOG(ERROR) << "ES CB null";
+      return;
+    }
+
+    if (submit_buffer_->end_of_stream()) {
+//      LOG(ERROR) << "<<< EOS";
+
+      int bsent = submit_data(NULL, 0, kNoTimestamp(), true, false);
+
+      if (bsent != 0)
+      {
+        decode_cb_.Reset();
+        submit_buffer_ = NULL;
+
+        // The callback on EOS takes place much later & from the resizer output
+      }
+    }
+    else
+    {
+//      LOG(ERROR) << "submit";
+
+      uint32_t size = submit_buffer_->data_size();
+      int bsent = submit_data(submit_buffer_->data() + submit_offset_,
+          size - submit_offset_,
+          submit_buffer_->timestamp(),
+          submit_offset_ == 0, false);
+
+//      LOG(ERROR) << "es submit bsent=" << bsent;
+
+      if (bsent < 0 || (submit_offset_ += bsent) >= size) {
+        submit_done(bsent >= 0 ? DecodeStatus::OK : DecodeStatus::DECODE_ERROR);
+      }
+    }
+  }
+
+  void event_cb(MMAL_BUFFER_HEADER_T * const buffer) override
+  {
+    mmal_buffer_header_release(buffer);
+
+    task_run(base::Bind(&MmalVideoESPort::submit_poll, this));
+  }
+
+
+public:
+  int submit(const scoped_refptr<DecoderBuffer>& buffer, const VideoDecoder::DecodeCB& decode_cb)
+  {
+    if (submit_buffer_ != NULL) {
+      LOG(ERROR) << "### Submit already active";
+      return -1;
+    }
+
+    if (decode_cb.is_null()) {
+      // If null CB then assume we need sync output
+      return submit_data(buffer->data(), buffer->data_size(), buffer->timestamp(), true, true) < 0 ? -1 : 0;
+    }
+    else
+    {
+      submit_buffer_ = buffer;
+      submit_offset_ = 0;
+      decode_cb_ = decode_cb;
+
+      // * Maybe don't need the task_run
+      task_run(base::Bind(&MmalVideoESPort::submit_poll, this));
+    }
+    return 0;
+  }
+
+  int disable() override
+  {
+    // Get and kill any pending submit_callback
+    if (submit_buffer_ != NULL) {
+      submit_done(DecodeStatus::ABORTED);
+    }
+    return MmalPortPool::disable();
+  }
+};
+
+
+// ----------------------------------------------------------------------------
+
+class MmalVideoARGBPort : public MmalPortPool
+{
+  FrameCopyMode copy_mode_;
+  gfx::Size req_size_;
+  VideoDecoder::OutputCB output_cb_;
+  VideoDecoder::DecodeCB eos_cb_;
+  base::Lock resize_lock_;
+  bool eos_sent_;
+  bool red_pixel_;
+  scoped_refptr<MmalTrampoline> frame_trampoline_;
+  scoped_refptr<VideoFrame> sliced_frame_;
+  int sliced_y_;
+  base::subtle::Atomic32 buffers_in_flight_;
+  int buffers_per_frame_;
+  int max_buffers_in_flight_;
+
+  void kill_trampoline()
+  {
+    if (frame_trampoline_)
+    {
+      frame_trampoline_->kill();
+      frame_trampoline_ = NULL;
+    }
+  }
+
+  // Mostly required to discard the return value
+  void posted_submit(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+//    LOG(ERROR) << "--- " << __func__;
+    submit(buffer);
+  }
+
+  void recycle_buffer(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    mmal_buffer_header_reset(buffer);
+
+    if (resize_lock_.Try()) {
+      submit(buffer);
+      resize_lock_.Release();
+    }
+    else
+    {
+      task_run(base::Bind(&MmalVideoARGBPort::posted_submit, this, buffer));
+    }
+  }
+
+  // Unlocks buffer & recycles it
+  void frame_destruction_cb(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+//    LOG(ERROR) << __func__;
+    base::subtle::NoBarrier_AtomicIncrement(&buffers_in_flight_, -1);
+
+    mmal_buffer_header_mem_unlock(buffer);
+    recycle_buffer(buffer);
+  }
+
+  void copied_frame_destruction_cb()
+  {
+    const base::subtle::Atomic32 n = base::subtle::NoBarrier_AtomicIncrement(&buffers_in_flight_, -buffers_per_frame_);
+
+    if (n < 0) {
+      LOG(FATAL) << "Buffers in flight underflow";
+    }
+
+//    LOG(ERROR) << "in flight:" << n << ", bpf:" << buffers_per_frame_ << ", mbif:" << max_buffers_in_flight_ <<", ps:" << pool_size();
+
+    const int stuff_count = n + buffers_per_frame_ - max_buffers_in_flight_;
+
+    if (stuff_count > 0)
+    {
+      // We do need to wait as the inc happens before the release in the tx code
+      if (stuff(std::min(buffers_per_frame_, stuff_count), true) == -1) {
+        LOG(FATAL) << "No buffers to back up recycle request";
+      }
+    }
+  }
+
+  void resize_posted(const gfx::Size req_size)
+  {
+    if (req_size.width() <= 0 || req_size.height() <= 0 || req_size == size())
+      return;
+
+    LOG(INFO) << __func__ << "(" << req_size.ToString() << ")";
+
+    base::AutoLock lock(resize_lock_);
+    disable();
+    set_size(req_size);
+    commit();
+    enable();
+  }
+
+  void resize_cb(const gfx::Size& size)
+  {
+//    LOG(ERROR) << __func__ << "(" << size.ToString() << ")";
+
+    if (size == req_size_) {
+      return;
+    }
+    req_size_ = size;
+
+    // Avoid running in the callback - run on our own thread
+    task_run(base::Bind(&MmalVideoARGBPort::resize_posted, this, size));
+  }
+
+public:
+  gfx::Size size() const
+  {
+    return gfx::Size(port_->format->es->video.crop.width, port_->format->es->video.crop.height);
+  }
+
+private:
+
+  void mov_frame_block(const scoped_refptr<VideoFrame>& frame,
+      MMAL_BUFFER_HEADER_T * const buffer,
+      const size_t stride,
+      const size_t width,
+      const size_t start_y,
+      const int lines)
+  {
+    MMAL_STATUS_T err;
+    if ((err = mmal_buffer_header_mem_lock(buffer)) != MMAL_SUCCESS)
+    {
+      LOG(ERROR) << "### Unable to lock buffer; err=" << err;
+      return;
+    }
+
+    const uint8_t * s = buffer->data + buffer->type->video.offset[0];
+    const size_t d_stride = frame->stride(0);
+    uint8_t * d = frame->data(0) + start_y * d_stride;
+    const size_t line_size = width * 4;
+
+    for (int i = 0; i < lines; ++i, s += stride, d += d_stride) {
+      memcpy(d, s, line_size);
+    }
+
+    // Unlock & recycles
+    mmal_buffer_header_mem_unlock(buffer);
+
+    const base::subtle::Atomic32 n = base::subtle::NoBarrier_AtomicIncrement(&buffers_in_flight_, 1);
+    if (n > max_buffers_in_flight_) {
+      buffer_release(buffer);
+    }
+    else {
+      recycle_buffer(buffer);
+    }
+  }
+
+  void emit_copied_frame(const scoped_refptr<VideoFrame>& frame)
+  {
+    if (red_pixel_) {
+      // Mark our frames with happy red pixels
+      uint8_t * d = frame->data(0);
+      const size_t d_stride = frame->stride(0);
+
+      for (int i = 0; i != 8; ++i, d += d_stride) {
+          for (int j = 0; j != 8 * 4; j += 4) {
+              d[j+0] = 0;
+              d[j+1] = 0;
+              d[j+2] = 0xff;
+              d[j+3] = 0xff;
+          }
+      }
+    }
+
+    if (frame_trampoline_ == NULL) {
+      LOG(FATAL) << "Trampoline NULL";
+    }
+
+    frame->mmal_resize_cb_ = frame_trampoline_->new_resize_cb();
+    frame->AddDestructionObserver(frame_trampoline_->new_destruction_cb());
+
+    output_cb_.Run(frame);
+  }
+
+protected:
+  void event_cb(MMAL_BUFFER_HEADER_T * const buffer) override
+  {
+    // One might have hoped that buffer->type->video.pitch[0] held this info...
+    const int stride = mmal_encoding_width_to_stride(port_->format->encoding, port_->format->es->video.width);
+    const gfx::Size cur_size = size();
+
+#if 0
+    LOG(ERROR) << "-- Got frame from resizer: copy_mode=" << copy_mode_ << ", len=" << buffer->length <<
+        ", size = " << port_->format->es->video.width << "x" << port_->format->es->video.height << ", req=" << cur_size.ToString() <<
+        ", stride=" << buffer->type->video.pitch[0] << "/" << stride << ", pts=" << buffer->pts <<
+        ", flags=" << std::hex << buffer->flags << std::dec << ", enabled=" << port_->is_enabled;
+#endif
+
+    if ((buffer->flags & MMAL_BUFFER_HEADER_FLAG_EOS) != 0) {
+      LOG(INFO) << ">>> EOS";
+      // Finally call the decode CB
+      if (!eos_cb_.is_null()) {
+        eos_cb_.Run(DecodeStatus::OK);
+        eos_cb_.Reset();
+        eos_sent_ = true;
+      }
+      // Remember to recycle the buffer!
+      recycle_buffer(buffer);
+      return;
+    }
+
+    if (buffer->length == 0) {
+      // Empty flushed buffer
+      recycle_buffer(buffer);
+      return;
+    }
+
+    eos_sent_ = false;
+
+    const base::TimeDelta pts(buffer->pts == MMAL_TIME_UNKNOWN ?
+        kNoTimestamp() :
+        base::TimeDelta::FromMicroseconds(buffer->pts));
+
+    switch (copy_mode_) {
+      case FrameCopyMode::unset:
+        LOG(ERROR) << "### copy mode unset";
+        recycle_buffer(buffer);
+        break;
+
+      case FrameCopyMode::ZERO:
+      {
+        mmal_buffer_header_mem_lock(buffer);
+
+        scoped_refptr<VideoFrame> frame(
+            VideoFrame::WrapExternalData(PIXEL_FORMAT_MMAL_BUFFER,
+              cur_size,
+              gfx::Rect(cur_size),
+              cur_size,
+              buffer->data + buffer->type->video.offset[0],
+              stride * cur_size.height(),
+              pts));
+
+        base::subtle::NoBarrier_AtomicIncrement(&buffers_in_flight_, 1);
+
+        // BEWARE race - resize will disable the port so must ensure that
+        // we aren't trying to use the port (to recycle stuff) whilst we do that
+        frame->mmal_resize_cb_ = base::Bind(&MmalVideoARGBPort::resize_cb, this);
+        frame->AddDestructionObserver(base::Bind(&MmalVideoARGBPort::frame_destruction_cb, this, buffer));
+
+        output_cb_.Run(frame);
+        break;
+      }
+
+      case FrameCopyMode::FRAME:
+      {
+        // * Arguably we should be creating ARGB buffers here rather than MMAL
+        //   but we have only carved a path through the rest of the video
+        //   render stack for MMAL
+        scoped_refptr<VideoFrame> frame(
+            VideoFrame::CreateFrame(PIXEL_FORMAT_MMAL_BUFFER,
+              cur_size,
+              gfx::Rect(cur_size),
+              cur_size,
+              pts));
+
+        mov_frame_block(frame, buffer, stride, cur_size.width(), 0, cur_size.height());
+
+        emit_copied_frame(frame);
+        break;
+      }
+
+      case FrameCopyMode::SLICE:
+      {
+        // Remember end of frame flag as we kill the buffer before using it
+        const bool eof = (buffer->flags & MMAL_BUFFER_HEADER_FLAG_FRAME_END) != 0;
+
+        if (sliced_frame_ == NULL) {
+          sliced_y_ = 0;
+          // pts only correct at eof
+          sliced_frame_ = VideoFrame::CreateFrame(PIXEL_FORMAT_MMAL_BUFFER,
+                cur_size,
+                gfx::Rect(cur_size),
+                cur_size,
+                kNoTimestamp());
+        }
+
+        mov_frame_block(sliced_frame_, buffer, stride, cur_size.width(), sliced_y_,
+            std::min(MMAL_SLICE_HEIGHT, sliced_frame_->rows(0) - sliced_y_));
+
+        if ((sliced_y_ += MMAL_SLICE_HEIGHT) < sliced_frame_->rows(0))
+        {
+          // Partial - stop now
+          if (eof) {
+            // Partial frame - discard
+            sliced_frame_ = NULL;
+            LOG(WARNING) << "### frame underrun";
+          }
+          return;
+        }
+
+        if (!eof) {
+          // Overrun
+          LOG(WARNING) << "### frame overrun";
+        }
+
+        sliced_frame_->set_timestamp(pts);
+
+        // Make sure sliced_frame_ is NULL before we do output callbacks
+        // that might cause us to look at it
+        scoped_refptr<VideoFrame> frame(sliced_frame_);
+        sliced_frame_ = NULL;
+
+        emit_copied_frame(frame);
+      }
+    }
+  }
+
+
+public:
+  MmalVideoARGBPort(MmalComponent * const component) :
+    MmalPortPool(component),
+    eos_sent_(false),
+    red_pixel_(false),
+    buffers_in_flight_(0),
+    buffers_per_frame_(0),
+    max_buffers_in_flight_(0)
+  {
+  }
+  ~MmalVideoARGBPort() override
+  {
+//    LOG(ERROR) << __func__;
+    kill_trampoline();
+  }
+
+  void set_port(MMAL_PORT_T * const port) override
+  {
+    MmalPort::set_port(port);
+
+    port_->format->type = MMAL_ES_TYPE_VIDEO;
+  }
+
+  void set_copy_mode(const FrameCopyMode copy_mode)
+  {
+    copy_mode_ = copy_mode;
+
+    if (copy_mode_ == FrameCopyMode::SLICE) {
+      port_->format->encoding = MMAL_ENCODING_BGRA_SLICE;
+      port_->format->encoding_variant = MMAL_ENCODING_BGRA_SLICE;
+    }
+    else
+    {
+      port_->format->encoding = MMAL_ENCODING_BGRA;
+      port_->format->encoding_variant = MMAL_ENCODING_BGRA;
+    }
+  }
+
+  int set_size(const gfx::Size& req_size)
+  {
+    set_video_format(req_size, gfx::Size(), ColorSpace::COLOR_SPACE_JPEG);
+    return 0;
+  }
+
+  void set_eos_cb(const VideoDecoder::DecodeCB& eos_cb)
+  {
+    eos_cb_ = eos_cb;
+  }
+
+  void set_red_pixel(const bool red)
+  {
+    red_pixel_ = red;
+  }
+
+  bool eos_sent() const
+  {
+    return eos_sent_ && eos_cb_.is_null();
+  }
+
+public:
+  int enable() override
+  {
+    if (copy_mode_ == FrameCopyMode::ZERO) {
+      buffers_per_frame_ = 1;
+      max_buffers_in_flight_ = pool_size();
+    }
+    else
+    {
+      kill_trampoline();  // Shouldn't be needed but good to make sure
+
+      frame_trampoline_ = new MmalTrampoline(
+          base::Bind(&MmalVideoARGBPort::resize_cb, this),
+          base::Bind(&MmalVideoARGBPort::copied_frame_destruction_cb, this));
+
+      // Reset buffers in flight info - buffers are restuffed after the enable
+      buffers_per_frame_ = copy_mode_ != FrameCopyMode::SLICE ? 1 :
+          (port_->format->es->video.crop.height + MMAL_SLICE_HEIGHT - 1) / MMAL_SLICE_HEIGHT;
+      max_buffers_in_flight_ = buffers_per_frame_ * MAX_COPY_FRAMES_IN_FLIGHT;
+      base::subtle::NoBarrier_Store(&buffers_in_flight_, 0);
+    }
+
+
+    if (MmalPortPool::enable() != 0)
+      return  -1;
+    return stuff();
+  }
+
+  int enable(const VideoDecoder::OutputCB& output_cb)
+  {
+    output_cb_ = output_cb;
+    return enable();
+  }
+
+  int disable() override
+  {
+    int rv = MmalPortPool::disable();
+
+    // Worry about class status vars after disable to avoid race conditions
+    kill_trampoline();
+
+    sliced_frame_ = NULL;  // Forget any partial frame info
+
+    if (!eos_cb_.is_null()) {
+      LOG(INFO) << ">>> EOS (abort)";
+      eos_cb_.Run(DecodeStatus::ABORTED);
+      eos_cb_.Reset();
+    }
+    eos_sent_ = false;
+
+    return rv;
+  }
+
+  bool is_stalling() const
+  {
+    return base::subtle::NoBarrier_Load(&buffers_in_flight_) >= max_buffers_in_flight_;
+  }
+};
+
+// ---------------------------------------------------------------------------
+
+class MmalComponent : public base::RefCountedThreadSafe<MmalComponent>
+{
+protected:
+  MMAL_COMPONENT_T * component_;
+private:
+  MmalTaskRunner task_runner_;
+
+protected:
+  int create_by_name(const char * const name)
+  {
+    MMAL_STATUS_T err;
+    if ((err = mmal_component_create(name, &component_)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_component_create failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  friend class base::RefCountedThreadSafe<MmalComponent>;
+  virtual ~MmalComponent()
+  {
+    if (component_ != NULL) {
+      mmal_component_release(component_);
+    }
+  }
+
+  virtual MmalConnectedPort * input_port() = 0;
+  virtual MmalConnectedPort * output_port() = 0;
+
+public:
+  MmalComponent() :
+    component_(NULL),
+    task_runner_(base::ThreadTaskRunnerHandle::Get())
+  {
+  }
+
+  const MmalTaskRunner& task_runner() const
+  {
+    return task_runner_;
+  }
+
+  int connect_to_output(scoped_refptr<MmalComponent> src)
+  {
+    MmalConnectedPort * const dest = input_port();
+    if (dest->connect_to_src(src->output_port()) != 0)
+      return -1;
+    if (dest->enable() != 0) {
+      dest->disconnect();
+      return -1;
+    }
+    return 0;
+  }
+
+  int enable()
+  {
+    MMAL_STATUS_T err;
+
+    if ((err = mmal_component_enable(component_)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_component_enable failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  int disable()
+  {
+    MMAL_STATUS_T err;
+    if ((err = mmal_component_disable(component_)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_component_disable failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  // Shut this component down
+  // Reclaim all resources as they return & attempt to zero our internal
+  // ref count so we will die when the decoder derefs us.
+  // The reclaim process may be async so we may die some time later
+  virtual void kill() = 0;
+};
+
+// ---------------------------------------------------------------------------
+
+class MmalVideoDecoderComponent : public MmalComponent
+{
+  MmalVideoESPort port_in_;
+  MmalConnectedPort port_out_;
+  MmalPort port_ctrl_;
+
+protected:
+  ~MmalVideoDecoderComponent() override
+  {
+    LOG(INFO) << "@@@ ~MmalVideoDecoderComponent";
+  }
+
+  MmalConnectedPort * input_port() override
+  {
+    return NULL;
+  }
+
+  MmalConnectedPort * output_port() override
+  {
+    return &port_out_;
+  }
+
+
+public:
+  MmalVideoDecoderComponent() :
+    port_in_(this)
+  {
+    LOG(INFO) << "@@@ MmalVideoDecoderComponent";
+  }
+
+  int create(const VideoDecoderConfig& config, const bool low_delay)
+  {
+    if (create_by_name(MMAL_COMPONENT_DEFAULT_VIDEO_DECODER) != 0) {
+      return -1;
+    }
+
+    // Attach control structures to ports
+    port_in_.set_port(component_->input[0]);
+    port_out_.set_port(component_->output[0]);
+    port_ctrl_.set_port(component_->control);
+
+    if (
+        port_ctrl_.enable() != 0 ||
+
+        port_in_.set_parameter(MMAL_PARAMETER_VIDEO_INTERPOLATE_TIMESTAMPS, false) ||
+//        port_in_.set_parameter(MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS, low_delay ? (uint32_t)(-5) : 120) ||
+        port_in_.set_parameter(MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS, (uint32_t)(-5)) ||
+        port_in_.config(config) != 0 ||
+        port_in_.commit() != 0 ||
+
+//        port_in_.buffer_size(0x10000, 8, true) ||  // ### Z-Copy is bust here
+        port_in_.buffer_size(0x10000, 8, false) ||
+        port_in_.create_pool() ||
+
+        port_in_.enable() != 0)
+    {
+      goto fail;
+    }
+    return 0;
+
+fail:
+    return -1;
+  }
+
+  void kill() override
+  {
+    port_in_.kill();
+    port_out_.kill();
+  }
+
+  void reset1()
+  {
+    port_in_.disable();
+    port_out_.disable();
+  }
+
+  void reset2()
+  {
+    port_out_.enable();
+    port_in_.enable();
+  }
+
+
+  int submit(const scoped_refptr<DecoderBuffer>& buffer, const VideoDecoder::DecodeCB& decode_cb)
+  {
+    return port_in_.submit(buffer, decode_cb);
+  }
+};
+
+// ---------------------------------------------------------------------------
+
+class MmalVideoResizerComponent : public MmalComponent
+{
+  FrameCopyMode copy_mode_;
+  gfx::Size cur_size_;
+  MmalConnectedPort port_in_;
+  MmalVideoARGBPort port_out_;
+  MmalPort port_ctrl_;
+
+protected:
+  ~MmalVideoResizerComponent() override
+  {
+    LOG(INFO) << "@@@ ~MmalVideoResizerComponent";
+  }
+
+  MmalConnectedPort * input_port() override
+  {
+    return &port_in_;
+  }
+
+  MmalConnectedPort * output_port() override
+  {
+    return NULL;
+  }
+
+
+public:
+  MmalVideoResizerComponent() :
+    copy_mode_(FrameCopyMode::unset),
+    port_out_(this)
+  {
+    LOG(INFO) << "@@@ MmalVideoResizerComponent";
+  }
+
+  int create()
+  {
+    if (create_by_name(MMAL_COMPONENT_DEFAULT_RESIZER) != 0) {
+      return -1;
+    }
+
+    // Attach control structures to ports
+    port_in_.set_port(component_->input[0]);
+    port_out_.set_port(component_->output[0]);
+    port_ctrl_.set_port(component_->control);
+    return 0;
+  }
+
+  bool is_copy_mode_supported(const FrameCopyMode mode) const
+  {
+    return port_out_.get_parameter_supported_encodings().is_supported(mode == FrameCopyMode::SLICE ? MMAL_ENCODING_BGRA_SLICE : MMAL_ENCODING_BGRA);
+  }
+
+  int configure(const FrameCopyMode copy_mode, const gfx::Size& size, const unsigned int frame_buffers, const VideoDecoder::OutputCB& output_cb)
+  {
+    copy_mode_ = copy_mode;
+    port_out_.set_copy_mode(copy_mode);
+
+    if (port_ctrl_.enable() != 0 ||
+        port_out_.set_size(size) != 0 ||
+        port_out_.commit() != 0 ||
+        port_out_.buffer_size(copy_mode_ == FrameCopyMode::SLICE ?
+              MMAL_SLICE_HEIGHT * MMAL_LIMIT_WIDTH * 4 :
+              MMAL_LIMIT_WIDTH * MMAL_LIMIT_HEIGHT * 4,
+            frame_buffers, true) ||
+        port_out_.create_pool() ||
+        port_out_.enable(output_cb) != 0)
+    {
+      goto fail;
+    }
+
+    cur_size_ = size;
+    return 0;
+
+fail:
+    return -1;
+  }
+
+  void kill() override
+  {
+    port_in_.kill();
+    port_out_.kill();
+  }
+
+  void reset1()
+  {
+    port_in_.disable();
+    port_out_.disable();
+  }
+
+  void reset2()
+  {
+    port_out_.enable();
+    port_in_.enable();
+  }
+
+  void set_eos_cb(const VideoDecoder::DecodeCB& eos_cb)
+  {
+    port_out_.set_eos_cb(eos_cb);
+  }
+
+  void set_red_pixel(const bool red)
+  {
+    port_out_.set_red_pixel(red);
+  }
+
+  bool is_output_stalling() const
+  {
+    return port_out_.is_stalling();
+  }
+};
+
+// ---------------------------------------------------------------------------
+
+void MmalConnection::disconnect()
+{
+  if (src_ == NULL || dest_ == NULL) {
+    LOG(ERROR) << "#### src or dest NULL";
+    return;
+  }
+
+  disable();
+
+  // Commit suicide by killing our refs
+  // Both ends should still exist as the destruction of either
+  // should call this fn
+  src_->set_connection(NULL);
+  dest_->set_connection(NULL);
+}
+
+int MmalConnection::connect(MmalConnectedPort * const src, MmalConnectedPort * const dest)
+{
+  MMAL_STATUS_T err;
+
+  if ((err = mmal_connection_create(&connection_, src->port_, dest->port_, MMAL_CONNECTION_FLAG_TUNNELLING)) != MMAL_SUCCESS) {
+    LOG(ERROR) << "### mmal_connection_create failed: err=" << err;
+    connection_ = NULL;  // Just in case
+    return -1;
+  }
+
+  src->set_connection(this);
+  dest->set_connection(this);
+
+  src_ = src;
+  dest_ = dest;
+  return 0;
+}
+
+
+// ---------------------------------------------------------------------------
+
+// Any refs required are applied to our enclosing object
+void MmalPortPool::AddRef() const
+{
+  component_->AddRef();
+}
+
+// Any refs required are applied to our enclosing object
+void MmalPortPool::Release()
+{
+  component_->Release();
+}
+
+const MmalTaskRunner& MmalPortPool::task_runner() const
+{
+  return component_->task_runner();
+}
+
+// ---------------------------------------------------------------------------
+
+// static
+bool MmalVideoDecoder::IsCodecSupported(VideoCodec codec) {
+//  LOG(ERROR) << "Test codec: " << codec;
+  return
+    codec == kCodecH264 ||
+    codec == kCodecVC1 ||
+    codec == kCodecMPEG2 ||
+    codec == kCodecMPEG4;
+}
+
+bool MmalVideoDecoder::IsSizeSupported(const gfx::Size& size)
+{
+  return size.width() <= MMAL_LIMIT_WIDTH &&
+    size.height() <= MMAL_LIMIT_HEIGHT &&
+    size.width() >= 32 &&
+    size.height() >= 32;
+}
+
+static unsigned int cmd_line_uint(const char name[], const unsigned int def_val)
+{
+  unsigned int val = def_val;
+
+  base::CommandLine * const cmd_line = base::CommandLine::ForCurrentProcess();
+
+  if (base::StringToUint(cmd_line->GetSwitchValueNative(name), &val))
+    return val;
+
+  return def_val;
+}
+
+static int cmd_line_flag(const char name[])
+{
+  base::CommandLine * const cmd_line = base::CommandLine::ForCurrentProcess();
+  return cmd_line->HasSwitch(name);
+}
+
+
+MmalVideoDecoder::MmalVideoDecoder() :
+  state_(MmalDecoderState::kNew),
+  counted_(false),
+  wants_extra_data_(false),
+  mmal_zero_copy_(cmd_line_flag(switches::kMmalZeroCopy)),
+  mmal_frame_copy_(cmd_line_flag(switches::kMmalFrameCopy)),
+  mmal_slice_copy_(cmd_line_flag(switches::kMmalSliceCopy)),
+  mmal_red_pixel_(cmd_line_flag(switches::kMmalRedPixel)),
+  mmal_buffers_(cmd_line_uint(switches::kMmalFrameBuffers, 0)),
+  mmal_decoders_(cmd_line_uint(switches::kMmalDecoders, 1))
+{
+  LOG(INFO) << "@@@ Create Decoder pid=" << getpid() << ", ppid=" << getppid() << ", vchiq_fd=" << vchiq_init_done;
+
+  if (cmd_line_flag(switches::kSingleProcess)) {
+    LOG(INFO) << "Single Process";
+
+    MMAL_STATUS_T err = mmal_vc_init();
+
+    if (err != MMAL_SUCCESS) {
+      LOG(ERROR) << "### mmal_vc_init failed: err=" << err;
+      goto fail;
+    }
+
+    vchiq_init_done = true;
+  }
+  else if (!vchiq_init_done) {
+
+    base::Pickle request;
+    request.WriteInt(content::LinuxSandbox::METHOD_OPEN_DEV_VCHIQ);
+    int vfd = -1;
+
+    uint8_t reply_buf[512];
+    const ssize_t rv = base::UnixDomainSocket::SendRecvMsg(
+        content::GetSandboxFD(), reply_buf, sizeof(reply_buf), &vfd, request);
+
+    if (rv == -1 || vfd == -1) {
+      LOG(ERROR) << "### Failed to open /dev/vchiq";
+      goto fail;
+    }
+
+    MMAL_STATUS_T err = mmal_vc_init_fd(vfd);
+
+    // The passed fd is at a minimum duped so close now
+    // we want to close on error too
+    IGNORE_EINTR(close(vfd));
+
+    if (err != MMAL_SUCCESS) {
+      LOG(ERROR) << "### mmal_vc_init_fd failed: fd=" << vfd << ", err=" << err;
+      goto fail;
+    }
+
+    vchiq_init_done = true;
+  }
+
+  state_ = MmalDecoderState::kUninitialised;
+  return;
+
+fail:
+  // We are never going to be happy - do not try
+  state_ = MmalDecoderState::kFatal;
+}
+
+MmalVideoDecoder::~MmalVideoDecoder() {
+  LOG(INFO) << "@@@ Destroy Decoder";
+
+  uninitialise();
+
+  if (counted_) {
+    base::subtle::NoBarrier_AtomicIncrement(& decoder_count, -1);
+  }
+}
+
+
+
+std::string MmalVideoDecoder::GetDisplayName() const {
+  return "MmalVideoDecoder";
+}
+
+
+void MmalVideoDecoder::uninitialise()
+{
+  if (decoder_ != NULL) {
+    decoder_->kill();
+    decoder_ = NULL;
+  }
+  if (resizer_ != NULL) {
+    resizer_->kill();
+    resizer_ = NULL;
+  }
+
+  extra_data_ = NULL;
+  wants_extra_data_ = false;
+
+  state_ = kUninitialised;
+}
+
+// Initializes a VideoDecoder with the given |config|, executing the
+// |init_cb| upon completion. |output_cb| is called for each output frame
+// decoded by Decode().
+//
+// If |low_delay| is true then the decoder is not allowed to queue frames,
+// except for out-of-order frames, i.e. if the next frame can be returned it
+// must be returned without waiting for Decode() to be called again.
+// Initialization should fail if |low_delay| is true and the decoder cannot
+// satisfy the requirements above.
+//
+// |cdm_context| can be used to handle encrypted buffers. May be null if the
+// stream is not encrypted.
+//
+// Note:
+// 1) The VideoDecoder will be reinitialized if it was initialized before.
+//    Upon reinitialization, all internal buffered frames will be dropped.
+// 2) This method should not be called during pending decode or reset.
+// 3) No VideoDecoder calls should be made before |init_cb| is executed.
+// 4) VideoDecoders should take care to run |output_cb| as soon as the frame
+// is ready (i.e. w/o thread trampolining) since it can strongly affect frame
+// delivery times with high-frame-rate material.  See Decode() for additional
+// notes.
+
+void MmalVideoDecoder::Initialize(const VideoDecoderConfig& config,
+                                    bool low_delay,
+                                    CdmContext* /* cdm_context */,
+                                    const InitCB& init_cb,
+                                    const OutputCB& output_cb) {
+  LOG(INFO) << "Mmal Init: low_delay=" << low_delay << ", config=" << config.AsHumanReadableString();
+
+  DCHECK(config.IsValidConfig());
+  DCHECK(!output_cb.is_null());
+
+  InitCB bound_init_cb = BindToCurrentLoop(init_cb);
+
+  // If dead - give up now
+  if (state_ <= MmalDecoderState::kFatal) {
+    LOG(ERROR) << __func__ << ": FATAL";
+    bound_init_cb.Run(false);
+    return;
+  }
+  
+  // If already inited (or failed) then kill
+  if (state_ != kUninitialised) {
+    // * This is unsubtle in the extreme
+    // and we would really prefer to wait for the kill ops to finish
+    // before continuing so we don't have an overlap where we have
+    // two sets of resizer buffers ... or preserve the resizer...
+    // or something...
+    uninitialise();
+  }
+
+  if (state_ != kUninitialised) {
+    LOG(ERROR) << __func__ << ": Unexpected state: " << state_;
+    goto fail;
+  }
+
+  // Do we support this?
+  if (config.is_encrypted() || !IsCodecSupported(config.codec()) ||
+      !IsSizeSupported(config.coded_size())) {
+//    LOG(ERROR) << "Encrypted or unsupported";
+    // No
+    goto fail;
+  }
+
+  // Check count
+  // 0 will effectively turn off mmal decode
+  if (!counted_ && base::subtle::NoBarrier_AtomicIncrement(&decoder_count, 1) > (int)mmal_decoders_) {
+    base::subtle::NoBarrier_AtomicIncrement(&decoder_count, -1);
+    LOG(WARNING) << __func__ << ": Exceeded decoder limit";
+    goto fail;
+  }
+  counted_ = true;
+
+  LOG(INFO) << "Decoder count:" << decoder_count << "/" << mmal_decoders_;
+
+  // Stash for later reset
+  decoder_config_ = config;
+  low_delay_ = low_delay;
+
+  if (config.extra_data().size() != 0)
+  {
+    extra_data_ = DecoderBuffer::CopyFrom(&config.extra_data()[0], config.extra_data().size());
+    wants_extra_data_ = true;
+  }
+
+  decoder_ = new MmalVideoDecoderComponent();
+  if (decoder_->create(config, low_delay) != 0)
+    goto fail;
+  if (decoder_->enable() != 0)
+    goto fail;
+
+  resizer_ = new MmalVideoResizerComponent();
+
+  if (resizer_->create() != 0)
+    goto fail;
+
+  {
+    // Only ever test for sliced resize once
+    static FrameCopyMode default_copy_mode = FrameCopyMode::unset;
+
+    if (default_copy_mode == FrameCopyMode::unset) {
+      if (resizer_->is_copy_mode_supported(FrameCopyMode::SLICE)) {
+        default_copy_mode = FrameCopyMode::SLICE;
+      }
+      else {
+        LOG(ERROR) << "Sliced resize not supported in firmware; Default copy mode=FRAME";
+        default_copy_mode = FrameCopyMode::FRAME;
+      }
+    }
+
+    const FrameCopyMode copy_mode = mmal_zero_copy_ ? FrameCopyMode::ZERO :
+      mmal_frame_copy_ ? FrameCopyMode::FRAME :
+      mmal_slice_copy_ ? FrameCopyMode::SLICE :
+      default_copy_mode;
+    const unsigned int frame_buffers = mmal_buffers_ != 0 ? mmal_buffers_ :
+      copy_mode == FrameCopyMode::ZERO ? ZERO_COPY_DEFAULT_BUFFERS :
+      copy_mode == FrameCopyMode::SLICE ? SLICE_COPY_DEFAULT_BUFFERS : FRAME_COPY_DEFAULT_BUFFERS;
+
+    LOG(INFO) << "mmal buffers=" << mmal_buffers_ << ", frame_buffers=" << frame_buffers << ", copy (z/f/s)=" <<
+      mmal_zero_copy_  << "/"  << mmal_frame_copy_ << "/" << mmal_slice_copy_ << ", copy_mode=" << copy_mode;
+
+    if (resizer_->configure(copy_mode, config.natural_size(), frame_buffers, BindToCurrentLoop(output_cb)) != 0)
+      goto fail;
+  }
+  resizer_->set_red_pixel(mmal_red_pixel_);
+  if (resizer_->enable() != 0)
+    goto fail;
+
+  if (resizer_->connect_to_output(decoder_) != 0)
+    goto fail;
+
+  state_ = MmalDecoderState::kInitialised;
+
+  // Success!
+  bound_init_cb.Run(true);
+  return;
+
+
+fail:
+  LOG(INFO) << __func__ << ": FAILED";
+  state_ = std::min(state_, MmalDecoderState::kFail);
+  bound_init_cb.Run(false);
+}
+
+void MmalVideoDecoder::Decode(const scoped_refptr<DecoderBuffer>& buffer,
+                                const DecodeCB& decode_cb) {
+  DCHECK(buffer.get());
+  DCHECK(!decode_cb.is_null());
+
+//  LOG(ERROR) << "<<< Decode";
+  DecodeCB decode_cb_bound = BindToCurrentLoop(decode_cb);
+
+  if (state_ < MmalDecoderState::kInitialised)
+  {
+    LOG(ERROR) << "### Decode in bad state: " << state_;
+    goto fail;
+  }
+
+  if (wants_extra_data_) {
+    if (extra_data_ == NULL) {
+      LOG(ERROR) << "### extra_data_ NULL";
+      goto fail;
+    }
+
+    wants_extra_data_ = false;
+    if (decoder_->submit(extra_data_, DecodeCB()) < 0)
+      goto fail;
+  }
+
+  // ????????????
+  // VideoDecoderShim expects that |decode_cb| is called only after
+  // |output_cb_|.
+
+  if (buffer->end_of_stream()) {
+    // If we've never sent any data or already have EOS
+    // then EOS won't propagate and we should ack here & now
+    if (state_ != MmalDecoderState::kRunning) {
+      LOG(INFO) << "<<< >>> EOS";
+      decode_cb_bound.Run(DecodeStatus::OK);
+      return;
+    }
+
+    resizer_->set_eos_cb(decode_cb_bound);
+
+    if (decoder_->submit(buffer, decode_cb_bound) < 0)
+      goto fail;
+
+    state_ = MmalDecoderState::kEOS;
+  }
+  else
+  {
+    if (decoder_->submit(buffer, decode_cb_bound) < 0)
+      goto fail;
+
+    state_ = MmalDecoderState::kRunning;
+  }
+
+
+//  LOG(ERROR) << ">>> Decode";
+
+  return;
+
+fail:
+  LOG(WARNING) << ">>> Decode: FAIL";
+  decode_cb_bound.Run(DecodeStatus::DECODE_ERROR);
+}
+
+// Resets decoder state. All pending Decode() requests will be finished or
+// aborted before |closure| is called.
+// Note: No VideoDecoder calls should be made before |closure| is executed.
+//
+// * Should end up in state Init
+void MmalVideoDecoder::Reset(const base::Closure& closure) {
+	switch (state_) {
+    case MmalDecoderState::kRunning:
+      LOG(INFO) << "@@@ Reset start";
+      decoder_->reset1();
+      resizer_->reset1();
+      resizer_->reset2();
+      decoder_->reset2();
+      wants_extra_data_ = (extra_data_ != NULL);
+      LOG(INFO) << "@@@ Reset fin";
+
+      state_ = MmalDecoderState::kInitialised;
+      break;
+
+    case MmalDecoderState::kEOS:
+      LOG(INFO) << "@@@ Reset EOS start";
+      decoder_->kill();
+      decoder_ = NULL;
+      resizer_->reset1();
+
+      decoder_ = new MmalVideoDecoderComponent();
+      if (decoder_->create(decoder_config_, low_delay_) != 0)
+        goto fail;
+      if (decoder_->enable() != 0)
+        goto fail;
+
+      if (resizer_->connect_to_output(decoder_) != 0)
+        goto fail;
+
+      resizer_->reset2();
+
+      wants_extra_data_ = (extra_data_ != NULL);
+      LOG(INFO) << "@@@ Reset EOS fin";
+
+      state_ = MmalDecoderState::kInitialised;
+      break;
+
+
+    default:
+      LOG(INFO) << "@@@ Reset null";
+      break;
+  }
+
+  // Ensure the closure is scheduled after any callbacks triggered by
+  // the reset sequence
+  base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE, closure);
+  return;
+
+fail:
+  LOG(ERROR) << "### Reset failed";
+  state_ = MmalDecoderState::kFail;
+}
+
+bool MmalVideoDecoder::CanReadWithoutStalling() const
+{
+  return !resizer_->is_output_stalling();
+}
+
+}  // namespace media
+
diff --git a/src/media/filters/mmal_video_decoder.h b/src/media/filters/mmal_video_decoder.h
new file mode 100644
index 0000000..f066ff0
--- /dev/null
+++ b/src/media/filters/mmal_video_decoder.h
@@ -0,0 +1,96 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_FILTERS_MMAL_VIDEO_DECODER_H_
+#define MEDIA_FILTERS_MMAL_VIDEO_DECODER_H_
+
+#include <list>
+
+#include "base/callback.h"
+#include "base/macros.h"
+#include "base/memory/scoped_ptr.h"
+#include "base/threading/thread_checker.h"
+#include "media/base/video_decoder.h"
+#include "media/base/video_decoder_config.h"
+#include "media/base/video_frame_pool.h"
+
+struct AVCodecContext;
+struct AVFrame;
+
+namespace base {
+class SingleThreadTaskRunner;
+}
+
+namespace media {
+
+class DecoderBuffer;
+class MmalVideoDecoderComponent;
+class MmalVideoResizerComponent;
+
+class MEDIA_EXPORT MmalVideoDecoder : public VideoDecoder {
+  enum MmalDecoderState {
+      kFatal = -2,
+      kFail = -1,
+      kNew = 0,
+      kUninitialised,
+      kReseting,
+      kInitialised,  // Init but no decode yet
+      kRunning,      // Have successful decode
+      kEOS           // EOS rxed
+  };
+
+  MmalDecoderState state_;
+
+  // Have we counted this decoder (for decoder count limits) yet?
+  bool counted_;
+
+  scoped_refptr<DecoderBuffer> extra_data_;
+  bool wants_extra_data_;
+
+  scoped_refptr<MmalVideoDecoderComponent> decoder_;
+  // Resizer may persist after VideoDecoder dies if it maintains frames
+  // with shared VC memory
+  scoped_refptr<MmalVideoResizerComponent> resizer_;
+
+  VideoDecoderConfig decoder_config_;
+  bool low_delay_;
+
+  void uninitialise();
+
+  const bool mmal_zero_copy_;
+  const bool mmal_frame_copy_;
+  const bool mmal_slice_copy_;
+  const bool mmal_red_pixel_;
+  const unsigned int mmal_buffers_;
+  const unsigned int mmal_decoders_;
+
+ public:
+  static bool IsCodecSupported(VideoCodec codec);
+  static bool IsSizeSupported(const gfx::Size& size);
+
+  MmalVideoDecoder();
+  ~MmalVideoDecoder() override;
+
+  // VideoDecoder implementation.
+  std::string GetDisplayName() const override;
+
+  void Initialize(const VideoDecoderConfig& config,
+                  bool low_delay,
+                  CdmContext* cdm_context,
+                  const InitCB& init_cb,
+                  const OutputCB& output_cb) override;
+  void Decode(const scoped_refptr<DecoderBuffer>& buffer,
+              const DecodeCB& decode_cb) override;
+  void Reset(const base::Closure& closure) override;
+  bool CanReadWithoutStalling() const override;
+
+ private:
+
+  DISALLOW_COPY_AND_ASSIGN(MmalVideoDecoder);
+};
+
+}  // namespace media
+
+#endif  // MEDIA_FILTERS_MMAL_VIDEO_DECODER_H_
+
diff --git a/src/media/filters/video_cadence_estimator.cc b/src/media/filters/video_cadence_estimator.cc
index ac2beb1..ae0c539 100644
--- a/src/media/filters/video_cadence_estimator.cc
+++ b/src/media/filters/video_cadence_estimator.cc
@@ -29,10 +29,12 @@ const double kConstantFPSFactor = 0.45;
 
 // Records the number of cadence changes to UMA.
 static void HistogramCadenceChangeCount(int cadence_changes) {
+#if 0
   const int kCadenceChangeMax = 10;
   UMA_HISTOGRAM_CUSTOM_COUNTS("Media.VideoRenderer.CadenceChanges",
                               cadence_changes, 0, kCadenceChangeMax,
                               kCadenceChangeMax);
+#endif
 }
 
 // Construct a Cadence vector, a vector of integers satisfying the following
diff --git a/src/media/media.gyp b/src/media/media.gyp
index 9752856..f88fc97 100644
--- a/src/media/media.gyp
+++ b/src/media/media.gyp
@@ -96,6 +96,9 @@
       ],
       'include_dirs': [
         '..',
+                '<(sysroot)/opt/vc/include',
+                '<(sysroot)/opt/vc/include/interface/vcos/pthreads',
+                '<(sysroot)/opt/vc/include/interface/vmcs_host/linux',
       ],
       'includes': [
         'capture.gypi',
@@ -541,6 +544,8 @@
         'filters/media_source_state.h',
         'filters/memory_data_source.cc',
         'filters/memory_data_source.h',
+        'filters/mmal_video_decoder.cc',
+        'filters/mmal_video_decoder.h',
         'filters/opus_audio_decoder.cc',
         'filters/opus_audio_decoder.h',
         'filters/opus_constants.cc',
@@ -667,6 +672,8 @@
             'filters/ffmpeg_video_decoder.h',
             'filters/in_memory_url_protocol.cc',
             'filters/in_memory_url_protocol.h',
+            'filters/mmal_video_decoder.cc',
+            'filters/mmal_video_decoder.h',
           ],
           'defines': [
             'MEDIA_DISABLE_FFMPEG',
@@ -715,6 +722,8 @@
             'filters/decrypting_video_decoder.h',
             'filters/ffmpeg_video_decoder.cc',
             'filters/ffmpeg_video_decoder.h',
+            'filters/mmal_video_decoder.cc',
+            'filters/mmal_video_decoder.h',
           ],
           'sources': [
             'filters/android/media_codec_audio_decoder.cc',
diff --git a/src/media/renderers/default_renderer_factory.cc b/src/media/renderers/default_renderer_factory.cc
index e09f90e..ed6e4a5 100644
--- a/src/media/renderers/default_renderer_factory.cc
+++ b/src/media/renderers/default_renderer_factory.cc
@@ -29,6 +29,8 @@
 #include "media/filters/vpx_video_decoder.h"
 #endif
 
+#include "media/filters/mmal_video_decoder.h"
+
 namespace media {
 
 DefaultRendererFactory::DefaultRendererFactory(
@@ -86,6 +88,8 @@ ScopedVector<VideoDecoder> DefaultRendererFactory::CreateVideoDecoders(
     video_decoders.push_back(
         new GpuVideoDecoder(gpu_factories, request_surface_cb));
 
+  video_decoders.push_back(new MmalVideoDecoder());
+
 #if !defined(MEDIA_DISABLE_LIBVPX)
   video_decoders.push_back(new VpxVideoDecoder());
 #endif
@@ -94,6 +98,7 @@ ScopedVector<VideoDecoder> DefaultRendererFactory::CreateVideoDecoders(
   video_decoders.push_back(new FFmpegVideoDecoder());
 #endif
 
+
   return video_decoders;
 }
 
diff --git a/src/media/renderers/skcanvas_video_renderer.cc b/src/media/renderers/skcanvas_video_renderer.cc
index 0f51d55..ac555a8 100644
--- a/src/media/renderers/skcanvas_video_renderer.cc
+++ b/src/media/renderers/skcanvas_video_renderer.cc
@@ -83,6 +83,7 @@ class SyncTokenClientImpl : public VideoFrame::SyncTokenClient {
   DISALLOW_IMPLICIT_CONSTRUCTORS(SyncTokenClientImpl);
 };
 
+
 skia::RefPtr<SkImage> NewSkImageFromVideoFrameYUVTextures(
     const VideoFrame* video_frame,
     const Context3D& context_3d) {
@@ -208,13 +209,26 @@ class VideoImageGenerator : public SkImageGenerator {
  public:
   VideoImageGenerator(const scoped_refptr<VideoFrame>& frame)
       : SkImageGenerator(
-            SkImageInfo::MakeN32Premul(frame->visible_rect().width(),
-                                       frame->visible_rect().height())),
+            SkImageInfo::MakeN32(frame->visible_rect().width(),
+                                       frame->visible_rect().height(), kOpaque_SkAlphaType)),  // *** Was Premul
         frame_(frame) {
     DCHECK(!frame_->HasTextures());
   }
   ~VideoImageGenerator() override {}
 
+  bool installBitmapPixels(SkBitmap * const bitmap) override
+  {
+    const SkImageInfo& info = getInfo();
+    // ??? Also check size
+    if (frame_->format() != PIXEL_FORMAT_MMAL_BUFFER) {
+      return false;
+    }
+
+    bitmap->installPixels(info, frame_->data(0), frame_->stride(0));
+
+    return true;
+  }
+
  protected:
   bool onGetPixels(const SkImageInfo& info,
                    void* pixels,
@@ -326,6 +340,7 @@ SkCanvasVideoRenderer::~SkCanvasVideoRenderer() {
   ResetCache();
 }
 
+
 void SkCanvasVideoRenderer::Paint(const scoped_refptr<VideoFrame>& video_frame,
                                   SkCanvas* canvas,
                                   const gfx::RectF& dest_rect,
@@ -347,8 +362,9 @@ void SkCanvasVideoRenderer::Paint(const scoped_refptr<VideoFrame>& video_frame,
   // Paint black rectangle if there isn't a frame available or the
   // frame has an unexpected format.
   if (!video_frame.get() || video_frame->natural_size().IsEmpty() ||
-      !(media::IsYuvPlanar(video_frame->format()) ||
-        video_frame->HasTextures())) {
+    !(media::IsYuvPlanar(video_frame->format()) || video_frame->format() == PIXEL_FORMAT_MMAL_BUFFER ||
+      video_frame->HasTextures()))
+  {
     canvas->drawRect(dest, paint);
     canvas->flush();
     return;
@@ -390,7 +406,9 @@ void SkCanvasVideoRenderer::Paint(const scoped_refptr<VideoFrame>& video_frame,
   const bool need_scaling =
       dest_rect.size() !=
       gfx::SizeF(gfx::SkISizeToSize(last_image_->dimensions()));
+
   const bool need_translation = !dest_rect.origin().IsOrigin();
+
   bool need_transform = need_rotation || need_scaling || need_translation;
   if (need_transform) {
     canvas->save();
@@ -633,6 +651,7 @@ void SkCanvasVideoRenderer::ConvertVideoFrameToRGBPixels(
     case PIXEL_FORMAT_RGB32:
     case PIXEL_FORMAT_MJPEG:
     case PIXEL_FORMAT_MT21:
+    case PIXEL_FORMAT_MMAL_BUFFER:
     case PIXEL_FORMAT_UNKNOWN:
       NOTREACHED();
   }
diff --git a/src/media/video/gpu_memory_buffer_video_frame_pool.cc b/src/media/video/gpu_memory_buffer_video_frame_pool.cc
index 777a1fc..731a456 100644
--- a/src/media/video/gpu_memory_buffer_video_frame_pool.cc
+++ b/src/media/video/gpu_memory_buffer_video_frame_pool.cc
@@ -387,6 +387,7 @@ void GpuMemoryBufferVideoFramePool::PoolImpl::CreateHardwareFrame(
     case PIXEL_FORMAT_YUV420P10:
     case PIXEL_FORMAT_YUV422P10:
     case PIXEL_FORMAT_YUV444P10:
+    case PIXEL_FORMAT_MMAL_BUFFER:
     case PIXEL_FORMAT_UNKNOWN:
       frame_ready_cb.Run(video_frame);
       return;
diff --git a/src/pi-util/BUILD.txt b/src/pi-util/BUILD.txt
new file mode 100644
index 0000000..5f0f0b1
--- /dev/null
+++ b/src/pi-util/BUILD.txt
@@ -0,0 +1,119 @@
+Build notes (cross compile from Ubuntu)
+=======================================
+
+Build from a patch
+------------------
+
+# Pick somewhere to put this
+cd ~
+mkdir chromium
+cd chromium
+git clone https://chromium.googlesource.com/chromium/tools/depot_tools
+# This is needed for more recent versions of gclient as we
+# are currently set up to use ninja
+export GYP_CHROMIUM_NO_ACTION=0
+export PATH=$PATH:`pwd`/depot_tools
+# Get the main tree
+fetch chromium
+cd src
+# Checkout the version you want
+# * Fix version number
+git checkout 51.0.2704.91
+# Fix up any missing dependancies on the build m/c
+# * may well be unnecessary if you have built any other chrome
+./build/install-build-deps.sh
+./build/install-build-deps.sh --arm
+# Fetch & pull the other bits of the tree to sync.
+# As we are checking out a tag the --with_branch_heads is important
+gclient sync --with_branch_heads
+# Patch - should be completely clean if everything matchs
+# * Fix patch file to correct name / location
+cd ..
+patch -p1 < v51.0.2704.91.patch
+cd src
+# * Get a sysroot from somewhere and put it in build/linux/raspian_jessie_pi1
+# * Example below is only if you have got an appropriate one lying around
+# * Otherwise follow sysroot instructions further down
+rsync -rl previous_location/raspian_jessie_pi1-sysroot build/linux/
+# Copy an appropriate gyp_env to where it will be found
+# * Will need editing if you have picked another sysroot name
+cp pi-util/chromium.gyp_env.pi1 ../chromium.gyp_env
+# Build hooks
+gclient runhooks
+# Build chrome
+ninja -C out/Release chrome
+
+
+
+
+Sysroots (one time only)
+------------------------
+
+1st you will need to get the dev files for a bunch of libs on your pi (or
+if you can get the right files by magic on your cross-compile m/c then
+that is good too).  In src/pi-util there is a shell script
+pi-install-dev.sh which lists all the libs I think are needed along with a
+helpful apt-get install so all you should need to do is run it on an
+appropriate pi.
+
+Next the appropriate bits need to be copied to
+build/linux/<sysroot-name>-sysroot. (We use raspian_jessie_pi1 as the
+sysroot name in these instructions and in the example script files so you
+might well find it easiest to use the same name too
+
+The script pi-util/syncroot.sh that will copy the needed bits of a root to
+the right place and then fix the full path symlinks to be relative.  It
+uses rsync to copy the files so the src can contain a machine name
+
+pi-util/syncroot.sh my-pi: raspian_jessie_pi1
+
+Beware that there are ~8 rsync statements so if the rsync is operating
+over ssh then you may need to type your password 8 times...
+
+If the pi root is updated then this script can / should be rerun to update
+the sysroot.
+
+
+gyp_env (one time only)
+-------
+
+Copy an appropriate chromium.gyp_env.??? to buildhost as chromium.gyp_env
+and change its sysroot_name to whatever you chose omitting the final
+"-sysroot", so if you installed your sysroot into
+src/build/linux/raspian_jessie_pi1-sysroot you would want
+sysroot_name=raspian_jessie_pi1
+
+cp pi-util/chromium.gyp_env.pi1 ../chromium.gyp_env
+vi ../chromium.gyp_env
+
+build
+-----
+
+You will want a clean environment (i.e. no CFLAGS etc), but with
+depot_tools in your path.  Anything else will probably confuse the build.
+
+For a clean build which you will need to do if you have moved the tree,
+updated sysroot or changed chromium.gyp_env
+
+rm -rf out
+gclient runhooks
+
+Then the (re)make step is
+
+ninja -C out/Release chrome
+
+the executable (chrome) should turn up out/Release
+
+
+Other notes on the tree
+ -----------------------
+
+The git branches in use are
+
+src:                        test/use_mmal_3
+src/native_client:          test_use_mmal_3
+src/third_party/opus/src:   test/use_mmal_3
+src/third_party/pdfium:     test/use_mmal_3
+src/third_party/ffmpeg:     test/use_mmal_3
+src/third_party/skia:       test/use_mmal_2
+src/third_party/webrtc:     test/use_mmal_3
diff --git a/src/pi-util/README.txt b/src/pi-util/README.txt
new file mode 100644
index 0000000..dc62a49
--- /dev/null
+++ b/src/pi-util/README.txt
@@ -0,0 +1,60 @@
+Release notes
+=============
+
+This version should run with gpu-mem=64 with the default switches. Having
+said that this will only allow for 1 stream.  If you are playing >1 stream
+(even transiently) then you will need more (say gpu_mem=128) and you will
+need to set the --mmal-decoders option to the desired max number. The code
+should give up cleanly if it cannot allocate a h/w video decoder and give
+the stream to old-style ffmpeg decode, but as it stands in many cases it
+thinks it has allocated a decoder cleanly only to find that it fails when
+it tries to use it.
+
+Needs firmware from "Sep 13 2016 17:01:56" or later to work properly
+("vcgencmd version" will give the date).
+
+There are a few command-line switches - in general you shouldn't use
+them!
+
+Copy-modes
+----------
+
+These are modes for getting frames out of mmal.  Current default is
+--mmal-slice-copy if we think the firware supports it otherwise
+--mmal-frame-copy. Explicit use of a copy mode option will override the
+default regardless of whether or not we think the firmware supports the
+selected option.  Only use one of of these flags.
+
+--mmal-zero-copy         Pass gpu frames directly to chrome.  Chrome
+buffers some frames and stalls if it doesn't get them. So this option
+needs 6+ gpu frames allocated.  This is the fastest option but you
+probably want to have gpu_mem=192 if you are going to use it.  Default
+frame-buffers = 6 (8M each)
+
+--mmal-frame-copy        Copy frame at a time out of mmal to chrome. Needs
+2+ gpu frames for plausible performance.  Default frame-buffers = 2 (8M
+each).  You probably want gpu-mem=80 for 1 decoder with this option.
+
+--mmal-slice-copy        Copy frames out in 16-line slices.  Has the
+lowest memory overhead, but the highest CPU load.  If this is selected
+then --mmal-frame-buffers is the number of slice buffers. Default frame
+buffers = 16 (~122k each)
+
+Misc options
+------------
+
+--mmal-decoders=<n>      Set the number of mmal decoders we wil try to
+create simultainiously. Default=1. If this number is exceeded then decoder
+init will fail and chrome will fallback to ffmpeg decode.  There is no
+panalty for setting this to a large number if you wish to have "unlimited"
+decoders.  However if it is set too big and there isn't the gpu mem to
+satisfy the requirements of the decode it may fail cleanly and revert to
+software (ffmpeg) decode or init may appear to succeed and decode then
+fails in an undefined manner.
+
+--mmal-frame-buffers=<n> Set the number of gpu "frame" buffers (see
+--mmal-xxx-copy). Change with care.
+
+--mmal-red-pixel         Puts a red square in the top left of a frame
+decoded by mmal so you can tell that it is active.  Doesn't work if
+zero-copy is set.
diff --git a/src/pi-util/chromium.gyp_env.pi1 b/src/pi-util/chromium.gyp_env.pi1
new file mode 100644
index 0000000..db0f0c7
--- /dev/null
+++ b/src/pi-util/chromium.gyp_env.pi1
@@ -0,0 +1,5 @@
+{
+'GYP_CROSSCOMPILE': '1',
+'GYP_DEFINES': 'use_system_harfbuzz=1 use_system_libjpeg=1 proprietary_codecs=1 target_arch=arm arm_float_abi=hard arm_version=6 arm_neon=0 ffmpeg_branding=Chrome video_hole=0 sysroot_name=raspian_jessie_pi1'
+}
+
diff --git a/src/pi-util/chromium.gyp_env.pi2 b/src/pi-util/chromium.gyp_env.pi2
new file mode 100644
index 0000000..b626df6
--- /dev/null
+++ b/src/pi-util/chromium.gyp_env.pi2
@@ -0,0 +1,5 @@
+{
+'GYP_CROSSCOMPILE': '1',
+'GYP_DEFINES': 'use_system_harfbuzz=1 use_system_libjpeg=1 proprietary_codecs=1 target_arch=arm arm_float_abi=hard arm_version=7 arm_neon=1 ffmpeg_branding=Chrome video_hole=0 sysroot_name=raspian_jessie_pi2'
+}
+
diff --git a/src/pi-util/dodiff.py b/src/pi-util/dodiff.py
new file mode 100755
index 0000000..f90d7aa
--- /dev/null
+++ b/src/pi-util/dodiff.py
@@ -0,0 +1,35 @@
+#!/usr/bin/env python
+
+import os, sys, string, subprocess
+
+# Local
+import gitscan, pipaths
+
+def doscan():
+    revdict = gitscan.revdict()
+
+    cpath = gitscan.basepath()
+
+    for p in pipaths.pipaths:
+        os.chdir(os.path.join(cpath, p))
+        diff = subprocess.check_output(["git", "diff", revdict[p]])
+
+        header = False
+        lines = diff.split("\n")
+        # Remove terminal blank line
+        if lines[-1] == "":
+            lines.pop()
+        for line in lines:
+            if line.startswith("diff --git "):
+                header = True
+            if header:
+                line = string.replace(line, " a/", " a/" + p + "/")
+                line = string.replace(line, " b/", " b/" + p + "/")
+            if line.startswith("+++ "):
+                header = False
+            print line
+
+
+if __name__ == '__main__':
+    doscan()
+
diff --git a/src/pi-util/gitscan.py b/src/pi-util/gitscan.py
new file mode 100755
index 0000000..eb6fd99
--- /dev/null
+++ b/src/pi-util/gitscan.py
@@ -0,0 +1,51 @@
+#!/usr/bin/env python
+
+import os,subprocess
+
+# Local
+import pipaths
+
+def revdict():
+    revdict = {'src':pipaths.src_commit}
+    stuff = subprocess.check_output(["gclient", "revinfo"])
+    for line in stuff.split("\n"):
+        pathn = line.find(":")
+        commitn = line.rfind("@")
+        if pathn != -1 and commitn != -1 :
+             revdict[line[:pathn]] = line[commitn+1:]
+    return revdict
+
+def basepath():
+    cpath = os.getcwd()
+    if not cpath.endswith("/src"):
+        raise "CWD doesn't end with /src"
+
+    return cpath[:-4]
+
+if __name__ == '__main__':
+    import sys, string
+
+    nosrc = False
+
+    if sys.argv[1] == "--gitscan-no-src":
+        nosrc = True
+        del sys.argv[1]
+
+    revdict = revdict()
+
+    cpath = basepath()
+
+    for p in pipaths.pipaths:
+        if nosrc and p == "src":
+            continue
+
+        os.chdir(os.path.join(cpath, p))
+
+        gitargs = [string.replace(string.replace(a, "{PATH}", p), "{BASE}", revdict[p]) for a in sys.argv]
+        gitargs[0] = "git"
+
+        print ">>>", p
+        subprocess.check_call(gitargs)
+
+
+
diff --git a/src/pi-util/pi-install-dev.sh b/src/pi-util/pi-install-dev.sh
new file mode 100755
index 0000000..336fc26
--- /dev/null
+++ b/src/pi-util/pi-install-dev.sh
@@ -0,0 +1,34 @@
+# Install set to build appropriate root on a clean pi
+
+sudo apt-get install \
+comerr-dev \
+libasound2-dev \
+libatk1.0-dev \
+libcap-dev \
+libcups2-dev \
+libexif-dev \
+libffi-dev \
+libgconf2-dev \
+libgl1-mesa-dev \
+libgnome-keyring-dev \
+libgtk2.0-dev \
+libjpeg-dev \
+libkrb5-dev \
+libnspr4-dev \
+libnss3-dev \
+libpam0g-dev \
+libpci-dev \
+libpcre3-dev \
+libpulse-dev \
+libssl-dev \
+libudev-dev \
+libxss-dev \
+libxt-dev \
+libxtst-dev \
+mesa-common-dev
+
+# Obviously replace paths appropriately below
+# Now run pi-util/syncroot.sh on the compile m/c to grab the appropriate
+# bits of the root and fix up the paths.
+# e.g. ON COMPILE M/C in src dir:
+# pi-util/syncroot.sh my-pi: raspian_jessie_pi1
diff --git a/src/pi-util/pi1_relink.sh b/src/pi-util/pi1_relink.sh
new file mode 100755
index 0000000..958a9b3
--- /dev/null
+++ b/src/pi-util/pi1_relink.sh
@@ -0,0 +1,6 @@
+# Run from src
+cd build/linux/raspian_jessie_pi1-sysroot/usr/lib/pkgconfig
+ln -sf ../arm-linux-gnueabihf/pkgconfig/* .
+cd ../../../../../..
+pi-util/rebase_liblinks.py build/linux/raspian_jessie_pi1-sysroot
+
diff --git a/src/pi-util/pi2_relink.sh b/src/pi-util/pi2_relink.sh
new file mode 100755
index 0000000..09e104f
--- /dev/null
+++ b/src/pi-util/pi2_relink.sh
@@ -0,0 +1,6 @@
+# Run from src
+cd build/linux/raspian_jessie_pi2-sysroot/usr/lib/pkgconfig
+ln -sf ../arm-linux-gnueabihf/pkgconfig/* .
+cd ../../../../../..
+pi-util/rebase_liblinks.py build/linux/raspian_jessie_pi2-sysroot
+
diff --git a/src/pi-util/pipaths.py b/src/pi-util/pipaths.py
new file mode 100755
index 0000000..c833ab6
--- /dev/null
+++ b/src/pi-util/pipaths.py
@@ -0,0 +1,11 @@
+pipaths=[
+    "src",
+    "src/native_client",
+    "src/third_party/opus/src",
+    "src/third_party/pdfium",
+    "src/third_party/ffmpeg",
+    "src/third_party/skia",
+    "src/third_party/webrtc"]
+
+# Or maybe "master"
+src_commit="52715df2ad7c374fae6410f0a6c457f0aff3ef96"
diff --git a/src/pi-util/rebase_liblinks.py b/src/pi-util/rebase_liblinks.py
new file mode 100755
index 0000000..6a9a33f
--- /dev/null
+++ b/src/pi-util/rebase_liblinks.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python
+
+import os, sys
+from stat import *
+
+def walktree(top, callback, n, prefix):
+    '''recursively descend the directory tree rooted at top,
+       calling the callback function for each regular file'''
+
+    for f in os.listdir(top):
+        pathname = os.path.join(top, f)
+        mode = os.lstat(pathname).st_mode
+        if S_ISDIR(mode):
+            # It's a directory, recurse into it
+            walktree(pathname, callback, n+1, prefix)
+        elif S_ISLNK(mode):
+            # It's a file, call the callback function
+            callback(pathname, os.readlink(pathname), n, prefix)
+
+def visitfile(file, linkname, n, prefix):
+    if (linkname.startswith(prefix + 'lib/')):
+        newlink = "../" * n + linkname[len(prefix):]
+        print 'relinking', file, "->", newlink
+        os.remove(file)
+        os.symlink(newlink, file)
+
+if __name__ == '__main__':
+    argc = len(sys.argv)
+    if argc == 2:
+        walktree(sys.argv[1], visitfile, 0, "/")
+    elif argc == 3:
+        walktree(sys.argv[1], visitfile, 0, sys.argv[2])
+    else:
+        print "rebase_liblinks.py <local root> [<old sysroot>]"
+
+
+
diff --git a/src/pi-util/syncroot.sh b/src/pi-util/syncroot.sh
new file mode 100644
index 0000000..b9a0341
--- /dev/null
+++ b/src/pi-util/syncroot.sh
@@ -0,0 +1,45 @@
+set -e
+
+if [ "$2" == "" ]; then
+  echo Usage: $0 \<src_dir\> \<rootname\>
+  echo src_dir is a source for rsync so may contain m/c name.
+  echo e.g.: pi-util/syncroot.sh my-pi: raspian_jessie_pi1
+  exit 1
+fi
+
+DST_ROOT=`gclient root`
+DST=$DST_ROOT/src/build/linux/$2-sysroot
+SRC=$1
+
+if [ ! -d $DST_ROOT/src/build/linux ]; then
+  echo We don\'t appear to be in a Chrome build tree
+  exit 1
+fi
+
+echo Sync src:  $SRC
+echo Sync dest: $DST
+
+mkdir -p $DST/lib
+mkdir -p $DST/opt/vc/include
+mkdir -p $DST/usr/lib/pkgconfig
+mkdir -p $DST/usr/bin
+mkdir -p $DST/usr/share
+
+#### MUST NOT include /opt/vc/include/*GL*
+# Creates conflicts with GL includes inside Chrome
+
+rsync -rl $SRC/lib/arm-linux-gnueabihf $DST/lib
+rsync -rl $SRC/opt/vc/lib $DST/opt/vc
+rsync -rl $SRC/opt/vc/include/interface $DST/opt/vc/include
+rsync -rl $SRC/usr/lib/arm-linux-gnueabihf $DST/usr/lib
+rsync -rl $SRC/usr/lib/gcc $DST/usr/lib
+rsync -rl $SRC/usr/include $DST/usr
+rsync -rl $SRC/usr/share/pkgconfig $DST/usr/share
+rsync -rl $SRC/usr/bin/cups-config $DST/usr/bin
+
+cd $DST/usr/lib/pkgconfig
+ln -sf ../arm-linux-gnueabihf/pkgconfig/* .
+cd ../../../../../..
+pi-util/rebase_liblinks.py $DST
+
+
diff --git a/src/third_party/WebKit/Source/wtf/SpinLock.cpp b/src/third_party/WebKit/Source/wtf/SpinLock.cpp
index 3abd17a..b775e6e 100644
--- a/src/third_party/WebKit/Source/wtf/SpinLock.cpp
+++ b/src/third_party/WebKit/Source/wtf/SpinLock.cpp
@@ -30,7 +30,11 @@
 #if CPU(X86_64) || CPU(X86)
 #define YIELD_PROCESSOR __asm__ __volatile__("pause")
 #elif CPU(ARM) || CPU(ARM64)
+#if __ARM_ARCH < 7
+#define YIELD_PROCESSOR ((void)0)
+#else
 #define YIELD_PROCESSOR __asm__ __volatile__("yield")
+#endif
 #elif CPU(MIPS)
 // The MIPS32 docs state that the PAUSE instruction is a no-op on older
 // architectures (first added in MIPS32r2). To avoid assembler errors when
diff --git a/src/third_party/boringssl/linux-arm/crypto/chacha/chacha-armv4.S b/src/third_party/boringssl/linux-arm/crypto/chacha/chacha-armv4.S
index 19a4d2c..30cb152 100644
--- a/src/third_party/boringssl/linux-arm/crypto/chacha/chacha-armv4.S
+++ b/src/third_party/boringssl/linux-arm/crypto/chacha/chacha-armv4.S
@@ -9,7 +9,8 @@
 .code	32
 #endif
 
-#if defined(__thumb2__) || defined(__clang__)
+@ #if defined(__thumb2__) || defined(__clang__)
+#if defined(__thumb2__)
 #define ldrhsb	ldrbhs
 #endif
 
diff --git a/src/third_party/tcmalloc/chromium/src/base/atomicops-internals-arm-v6plus.h b/src/third_party/tcmalloc/chromium/src/base/atomicops-internals-arm-v6plus.h
index dc06987..b7a1e1a 100644
--- a/src/third_party/tcmalloc/chromium/src/base/atomicops-internals-arm-v6plus.h
+++ b/src/third_party/tcmalloc/chromium/src/base/atomicops-internals-arm-v6plus.h
@@ -112,7 +112,14 @@ inline Atomic32 NoBarrier_AtomicIncrement(volatile Atomic32* ptr,
 }
 
 inline void MemoryBarrier() {
-  __asm__ __volatile__("dmb" : : : "memory");
+#if __ARM_ARCH >= 7
+  /* Note that this depends on ARMv7. */
+  __asm__ __volatile__("dsb");
+#else
+  /* We could support ARMv6 by instead using: */
+  __asm__ __volatile__("mcr p15, 0, %0, c7, c10, 5"
+                       : : "r" (0) : "memory");
+#endif
 }
 
 inline Atomic32 Barrier_AtomicIncrement(volatile Atomic32* ptr,
diff --git a/src/third_party/tcmalloc/chromium/src/base/cycleclock.h b/src/third_party/tcmalloc/chromium/src/base/cycleclock.h
index 0ce1638..fe6ca02 100644
--- a/src/third_party/tcmalloc/chromium/src/base/cycleclock.h
+++ b/src/third_party/tcmalloc/chromium/src/base/cycleclock.h
@@ -126,7 +126,8 @@ struct CycleClock {
 #elif defined(_MSC_VER)
     return __rdtsc();
 #elif defined(ARMV3)
-#if defined(ARMV6)  // V6 is the earliest arch that has a standard cyclecount
+//#if defined(ARMV6)  // V6 is the earliest arch that has a standard cyclecount
+#if defined(ARMV7)  // V6 is the earliest arch that has a standard cyclecount
     uint32 pmccntr;
     uint32 pmuseren;
     uint32 pmcntenset;
diff --git a/src/native_client/src/include/concurrency_ops.h b/src/native_client/src/include/concurrency_ops.h
old mode 100644
new mode 100755
index 82e313c..fdb51ef
--- a/src/native_client/src/include/concurrency_ops.h
+++ b/src/native_client/src/include/concurrency_ops.h
@@ -32,14 +32,14 @@ static INLINE void NaClWriteMemoryBarrier(void) {
 #elif NACL_ARCH(NACL_BUILD_ARCH) == NACL_arm
 
 static INLINE void NaClWriteMemoryBarrier(void) {
+#if __ARM_ARCH >= 7
   /* Note that this depends on ARMv7. */
   __asm__ __volatile__("dsb");
-
-  /*
-   * We could support ARMv6 by instead using:
-   * __asm__ __volatile__("mcr p15, 0, %0, c7, c10, 5"
-   *                      : : "r" (0) : "memory");
-   */
+#else
+  /* We could support ARMv6 by instead using: */
+  __asm__ __volatile__("mcr p15, 0, %0, c7, c10, 5"
+                       : : "r" (0) : "memory");
+#endif
 }
 
 #elif NACL_ARCH(NACL_BUILD_ARCH) == NACL_mips
diff --git a/src/third_party/opus/src/celt/arm/celt_neon_intr.c b/src/third_party/opus/src/celt/arm/celt_neon_intr.c
old mode 100644
new mode 100755
index 47dce15..a104364
--- a/src/third_party/opus/src/celt/arm/celt_neon_intr.c
+++ b/src/third_party/opus/src/celt/arm/celt_neon_intr.c
@@ -34,7 +34,9 @@
 #include "config.h"
 #endif
 
+#ifdef __ARM_NEON
 #include <arm_neon.h>
+#endif
 #include "../pitch.h"
 
 #if !defined(FIXED_POINT)
diff --git a/src/third_party/pdfium/third_party/third_party.gyp b/src/third_party/pdfium/third_party/third_party.gyp
old mode 100644
new mode 100755
index 7fd1082..01ed3b2
--- a/src/third_party/pdfium/third_party/third_party.gyp
+++ b/src/third_party/pdfium/third_party/third_party.gyp
@@ -411,6 +411,20 @@
             'libtiff/tif_write.c',
             'libtiff/tif_zip.c',
           ],
+          'conditions': [
+            ['OS=="win"', {
+              'defines!': [
+                # Need to undefine the macro since it is redefined in
+                # tif_ojpeg.c and tif_jpeg.c.
+                'WIN32_LEAN_AND_MEAN',
+              ],
+            }],
+            ['use_system_libjpeg!=0', {
+              'defines': [
+                'USE_SYSTEM_LIBJPEG=1',
+              ],
+            }],
+          ],
         },
       ],
     }],
diff --git a/src/third_party/ffmpeg/chromium/config/Chrome/linux/arm/config.h b/src/third_party/ffmpeg/chromium/config/Chrome/linux/arm/config.h
old mode 100644
new mode 100755
index f6c0650..9e960a1
--- a/src/third_party/ffmpeg/chromium/config/Chrome/linux/arm/config.h
+++ b/src/third_party/ffmpeg/chromium/config/Chrome/linux/arm/config.h
@@ -40,7 +40,7 @@
 #define ARCH_X86_64 0
 #define HAVE_ARMV5TE 1
 #define HAVE_ARMV6 1
-#define HAVE_ARMV6T2 1
+#define HAVE_ARMV6T2 0
 #define HAVE_ARMV8 0
 #define HAVE_NEON 0
 #define HAVE_VFP 1
@@ -82,8 +82,8 @@
 #define HAVE_LOONGSON3 1
 #define HAVE_MMI 0
 #define HAVE_ARMV5TE_EXTERNAL 1
-#define HAVE_ARMV6_EXTERNAL 1
-#define HAVE_ARMV6T2_EXTERNAL 1
+#define HAVE_ARMV6_EXTERNAL 0
+#define HAVE_ARMV6T2_EXTERNAL 0
 #define HAVE_ARMV8_EXTERNAL 0
 #define HAVE_NEON_EXTERNAL 0
 #define HAVE_VFP_EXTERNAL 1
@@ -126,7 +126,7 @@
 #define HAVE_MMI_EXTERNAL 0
 #define HAVE_ARMV5TE_INLINE 1
 #define HAVE_ARMV6_INLINE 1
-#define HAVE_ARMV6T2_INLINE 1
+#define HAVE_ARMV6T2_INLINE 0
 #define HAVE_ARMV8_INLINE 0
 #define HAVE_NEON_INLINE 0
 #define HAVE_VFP_INLINE 1
@@ -550,7 +550,7 @@
 #define CONFIG_PIC 1
 #define CONFIG_POD2MAN 1
 #define CONFIG_RAISE_MAJOR 0
-#define CONFIG_THUMB 1
+#define CONFIG_THUMB 0
 #define CONFIG_VALGRIND_BACKTRACE 0
 #define CONFIG_XMM_CLOBBER_TEST 0
 #define CONFIG_AANDCTTABLES 0
diff --git a/src/third_party/skia/include/core/SkImageGenerator.h b/src/third_party/skia/include/core/SkImageGenerator.h
index 1a46f6b..35eb4cc 100644
--- a/src/third_party/skia/include/core/SkImageGenerator.h
+++ b/src/third_party/skia/include/core/SkImageGenerator.h
@@ -129,6 +129,11 @@ public:
      */
     bool getPixels(const SkImageInfo& info, void* pixels, size_t rowBytes);
 
+    virtual bool installBitmapPixels(SkBitmap * const bitmap)
+    {
+        return false;
+    }
+
     /**
      *  If decoding to YUV is supported, this returns true.  Otherwise, this
      *  returns false and does not modify any of the parameters.
diff --git a/src/third_party/skia/src/core/SkImageGenerator.cpp b/src/third_party/skia/src/core/SkImageGenerator.cpp
index c8c94c2..92b45fe 100644
--- a/src/third_party/skia/src/core/SkImageGenerator.cpp
+++ b/src/third_party/skia/src/core/SkImageGenerator.cpp
@@ -128,8 +128,13 @@ static bool reset_and_return_false(SkBitmap* bitmap) {
     return false;
 }
 
+
 bool SkImageGenerator::tryGenerateBitmap(SkBitmap* bitmap, const SkImageInfo* infoPtr,
                                          SkBitmap::Allocator* allocator) {
+    if (this->installBitmapPixels(bitmap)) {
+        return true;
+    }
+
     SkImageInfo info = infoPtr ? *infoPtr : this->getInfo();
     if (0 == info.getSafeSize(info.minRowBytes())) {
         return false;
diff --git a/src/third_party/webrtc/modules/video_processing/deflickering.cc b/src/third_party/webrtc/modules/video_processing/deflickering.cc
index 0e936ce..d8b94ae 100644
--- a/src/third_party/webrtc/modules/video_processing/deflickering.cc
+++ b/src/third_party/webrtc/modules/video_processing/deflickering.cc
@@ -17,6 +17,8 @@
 #include "webrtc/common_audio/signal_processing/include/signal_processing_library.h"
 #include "webrtc/system_wrappers/include/sort.h"
 
+#pragma clang optimize off
+
 namespace webrtc {
 
 // Detection constants
diff --git a/src/third_party/webrtc/modules/video_processing/video_processing.gypi b/src/third_party/webrtc/modules/video_processing/video_processing.gypi
old mode 100644
new mode 100755
index 5bf0ea3..7d4d325
--- a/src/third_party/webrtc/modules/video_processing/video_processing.gypi
+++ b/src/third_party/webrtc/modules/video_processing/video_processing.gypi
@@ -49,7 +49,7 @@
         ['target_arch=="ia32" or target_arch=="x64"', {
           'dependencies': [ 'video_processing_sse2', ],
         }],
-        ['target_arch=="arm" or target_arch == "arm64"', {
+        ['(target_arch=="arm" and arm_neon==1) or target_arch == "arm64"', {
           'dependencies': [ 'video_processing_neon', ],
         }],
       ],
@@ -79,7 +79,7 @@
         },
       ],
     }],
-    ['target_arch=="arm" or target_arch == "arm64"', {
+    ['(target_arch=="arm" and arm_neon==1) or target_arch == "arm64"', {
       'targets': [
         {
           'target_name': 'video_processing_neon',
