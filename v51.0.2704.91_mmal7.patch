diff --git a/src/build/common.gypi b/src/build/common.gypi
index 1aad5054..48ee2b0 100644
--- a/src/build/common.gypi
+++ b/src/build/common.gypi
@@ -98,6 +98,9 @@
           # if packaging for a linux distro)
           'use_sysroot%': 1,
 
+          # sysroot name where it can be overridden (assumed to be in build/linux)
+          'sysroot_name%': '',
+
           # Override buildtype to select the desired build flavor.
           # Dev - everyday build for development/testing
           # Official - release build (generally implies additional processing)
@@ -181,6 +184,7 @@
         'host_arch%': '<(host_arch)',
         'target_arch%': '<(target_arch)',
         'use_sysroot%': '<(use_sysroot)',
+        'sysroot_name%': '<(sysroot_name)',
 
         # Set to true to instrument the code with function call logger.
         # See src/third_party/cygprofile/cyg-profile.cc for details.
@@ -334,6 +338,10 @@
               ['target_arch=="mipsel"', {
                 'sysroot%': '<!(cd <(DEPTH) && pwd -P)/build/linux/debian_wheezy_mips-sysroot',
               }],
+              # Will override above sysroot if sysroot_name is set
+              ['sysroot_name!=""', {
+                'sysroot%': '<!(cd <(DEPTH) && pwd -P)/build/linux/<(sysroot_name)-sysroot',
+              }],
             ],
           }, {
             'sysroot%': ''
@@ -378,6 +386,7 @@
       'arm_version%': '<(arm_version)',
       'sysroot%': '<(sysroot)',
       'use_sysroot%': '<(use_sysroot)',
+      'sysroot_name%': '<(sysroot_name)',
       'chroot_cmd%': '<(chroot_cmd)',
       'system_libdir%': '<(system_libdir)',
       'order_profiling%': '<(order_profiling)',
@@ -1200,6 +1209,7 @@
     'arm_neon_optional%': '<(arm_neon_optional)',
     'sysroot%': '<(sysroot)',
     'use_sysroot%': '<(use_sysroot)',
+    'sysroot_name%': '<(sysroot_name)',
     'pkg-config%': '<(pkg-config)',
     'chroot_cmd%': '<(chroot_cmd)',
     'system_libdir%': '<(system_libdir)',
@@ -3922,6 +3932,11 @@
           ['target_arch=="arm"', {
             'target_conditions': [
               ['_toolset=="target"', {
+                  'ldflags': [
+                    '-L<(sysroot)/opt/vc/lib',
+                    '-Wl,-rpath=/opt/vc/lib,-rpath-link=<(sysroot)/opt/vc/lib',
+                    '-Wl,--start-group -lbcm_host -lmmal -lmmal_util -lmmal_core -lmmal_vc_client -lvcos -lvcsm -lvchostif -lvchiq_arm -Wl,--end-group',
+                  ],
                 'conditions': [
                   ['clang==0', {
                     'cflags_cc': [
diff --git a/src/cc/layers/video_layer_impl.cc b/src/cc/layers/video_layer_impl.cc
index f22860c..57c789a 100644
--- a/src/cc/layers/video_layer_impl.cc
+++ b/src/cc/layers/video_layer_impl.cc
@@ -107,6 +107,12 @@ bool VideoLayerImpl::WillDraw(DrawMode draw_mode,
                                  layer_tree_impl()->resource_provider()));
   }
 
+  if (!frame_->mmal_resize_cb_.is_null()) {
+//    LOG(ERROR) << "vis:" << visible_layer_rect().ToString() << ", clip:" << clip_rect().ToString() <<
+//      ", drawable:" << drawable_content_rect().ToString() << ", bounds:" << bounds().ToString();
+    frame_->mmal_resize_cb_.Run(bounds());
+  }
+
   VideoFrameExternalResources external_resources =
       updater_->CreateExternalResourcesFromVideoFrame(frame_);
   frame_resource_type_ = external_resources.type;
diff --git a/src/cc/resources/video_resource_updater.cc b/src/cc/resources/video_resource_updater.cc
index e77cd75..359d70d 100644
--- a/src/cc/resources/video_resource_updater.cc
+++ b/src/cc/resources/video_resource_updater.cc
@@ -81,6 +81,7 @@ VideoFrameExternalResources::ResourceType ResourceTypeForVideoFrame(
     case media::PIXEL_FORMAT_YUV420P10:
     case media::PIXEL_FORMAT_YUV422P10:
     case media::PIXEL_FORMAT_YUV444P10:
+    case media::PIXEL_FORMAT_MMAL_BUFFER:
     case media::PIXEL_FORMAT_UNKNOWN:
       break;
   }
@@ -297,6 +298,7 @@ VideoFrameExternalResources VideoResourceUpdater::CreateForSoftwarePlanes(
     case media::PIXEL_FORMAT_RGB32:
     case media::PIXEL_FORMAT_MJPEG:
     case media::PIXEL_FORMAT_MT21:
+    case media::PIXEL_FORMAT_MMAL_BUFFER:
       bits_per_channel = 8;
       break;
     case media::PIXEL_FORMAT_YUV420P9:
@@ -312,7 +314,8 @@ VideoFrameExternalResources VideoResourceUpdater::CreateForSoftwarePlanes(
   }
 
   // Only YUV software video frames are supported.
-  if (!media::IsYuvPlanar(input_frame_format)) {
+  // Also allow our mmal buffer through
+  if (!media::IsYuvPlanar(input_frame_format) && input_frame_format != media::PIXEL_FORMAT_MMAL_BUFFER) {
     NOTREACHED() << media::VideoPixelFormatToString(input_frame_format);
     return VideoFrameExternalResources();
   }
diff --git a/src/chrome/browser/ui/startup/bad_flags_prompt.cc b/src/chrome/browser/ui/startup/bad_flags_prompt.cc
index ecab673..8141a7e 100644
--- a/src/chrome/browser/ui/startup/bad_flags_prompt.cc
+++ b/src/chrome/browser/ui/startup/bad_flags_prompt.cc
@@ -50,8 +50,10 @@ void ShowBadFlagsPrompt(Browser* browser) {
 #if !defined(DISABLE_NACL)
     switches::kNaClDangerousNoSandboxNonSfi,
 #endif
+#if 0
     switches::kNoSandbox,
     switches::kSingleProcess,
+#endif
 
     // These flags disable or undermine the Same Origin Policy.
     translate::switches::kTranslateSecurityOrigin,
diff --git a/src/content/browser/compositor/software_output_device_x11.cc b/src/content/browser/compositor/software_output_device_x11.cc
old mode 100644
new mode 100755
index 7bf743f..4c5aa8d
--- a/src/content/browser/compositor/software_output_device_x11.cc
+++ b/src/content/browser/compositor/software_output_device_x11.cc
@@ -19,8 +19,152 @@
 
 namespace content {
 
+int SoftwareOutputDeviceX11::ShmDesc::attach(XDisplay * const display, const XWindowAttributes& attributes, const int stride, const int h)
+{
+  XImage *img;
+
+  if ((img = XShmCreateImage(display, attributes.visual, attributes.depth,
+                          ZPixmap, NULL, &shminfo_, stride, h)) == NULL) {
+      LOG(ERROR) << "XShmCreateImage failed!";
+      goto fail0;
+  }
+
+//   LOG(ERROR) << "shmget";
+
+   if ((shminfo_.shmid = shmget(IPC_PRIVATE,
+        img->bytes_per_line * img->height, IPC_CREAT|0777 )) < 0)
+   {
+     LOG(ERROR) << "alloc_back_buffer: Shared memory error (shmget), disabling.";
+     goto fail;
+   }
+
+//   LOG(ERROR) << "shmat";
+
+   shminfo_.shmaddr = img->data =
+     (char*)shmat(shminfo_.shmid, 0, 0);
+   if (shminfo_.shmaddr == (char *) -1) {
+     goto fail;
+   }
+
+   shminfo_.readOnly = False;
+   /* This may trigger the X protocol error we're ready to catch: */
+   XShmAttach(display, &shminfo_);
+
+//   LOG(ERROR) << "shmctl";
+
+   shmctl(shminfo_.shmid, IPC_RMID, 0); /* nobody else needs it */
+
+   shmimg_ = img;
+   display_ = display;
+   window_attributes_ = attributes;
+   return 0;
+
+fail:
+    XDestroyImage(img);
+fail0:
+    return -1;
+}
+
+void SoftwareOutputDeviceX11::ShmDesc::detach()
+{
+  if (display_ != NULL) {
+    XShmDetach(display_, &shminfo_);
+    display_ = NULL;
+  }
+}
+
+void SoftwareOutputDeviceX11::ShmDesc::destroy()
+{
+  detach();
+  if (shmimg_ != NULL) {
+    XDestroyImage(shmimg_);
+    shmdt(shminfo_.shmaddr);
+  }
+}
+
+
+Bool SoftwareOutputDeviceX11::ShmDesc::put_image(Drawable drawable, GC gc, const gfx::Rect& rect)
+{
+  return XShmPutImage(display_, drawable, gc, shmimg_,
+      rect.x(), rect.y(), rect.x(), rect.y(),
+      rect.width(), rect.height(), false);
+}
+
+void SoftwareOutputDeviceX11::ShmDesc::resize(const SkImageInfo& info)
+{
+//  LOG(ERROR) << "resize req:" << info.width() << "x" << info.height();
+  req_ii_ = info;
+}
+
+sk_sp<SkSurface> SoftwareOutputDeviceX11::ShmDesc::use_surface()
+{
+  if (req_ii_ != cur_ii_) {
+    // Remember display - we kill it when we detach
+    // window_attributes_ survive destruction
+    XDisplay* const display = display_;
+
+//    LOG(ERROR) << "resize set:" << req_ii_.width() << "x" << req_ii_.height();
+
+    // Kill all current stuff
+    surface_.reset();
+    destroy();
+
+    // Rebuild
+    if (attach(display, window_attributes_, req_ii_.minRowBytes(), req_ii_.height()) != 0)
+    {
+      LOG(ERROR) << "Failed to make new XImage";
+    }
+    // Build a surface on it
+    else if (!(surface_ = SkSurface::MakeRasterDirect(req_ii_, shminfo_.shmaddr, shmimg_->bytes_per_line)))
+    {
+      LOG(ERROR) << "Failed to make new SkSurface";
+    }
+    else
+    {
+      // Success
+      cur_ii_ = req_ii_;
+    }
+  }
+  return surface_;
+}
+
+
+SoftwareOutputDeviceX11::ShmDesc::ShmDesc() :
+  shmimg_(NULL),
+  display_(NULL)
+{
+  // Empty
+}
+
+SoftwareOutputDeviceX11::ShmDesc::~ShmDesc() {
+  destroy();
+}
+
+
+/*
+ * Check if the X Shared Memory extension is available.
+ * Return:  0 = not available
+ *          1 = shared XImage support available
+ *          2 = shared Pixmap support available also
+ */
+static int check_for_xshm(Display * const display)
+{
+   int major, minor, ignore;
+   Bool pixmaps;
+
+   if (XQueryExtension(display, "MIT-SHM", &ignore, &ignore, &ignore)) {
+      if (XShmQueryVersion(display, &major, &minor, &pixmaps)) {
+        return pixmaps ? 2 : 1;
+      }
+   }
+   return 0;
+}
+
+
+
 SoftwareOutputDeviceX11::SoftwareOutputDeviceX11(ui::Compositor* compositor)
-    : compositor_(compositor), display_(gfx::GetXDisplay()), gc_(NULL) {
+    : compositor_(compositor), display_(gfx::GetXDisplay()), gc_(NULL),
+      shm_n_(0) {
   // TODO(skaslev) Remove this when crbug.com/180702 is fixed.
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
 
@@ -30,6 +174,29 @@ SoftwareOutputDeviceX11::SoftwareOutputDeviceX11(ui::Compositor* compositor)
                << compositor_->widget();
     return;
   }
+
+  if (!(gfx::BitsPerPixelForPixmapDepth(display_, attributes_.depth) == 32 &&
+        attributes_.visual->red_mask == 0xff0000 &&
+        attributes_.visual->green_mask == 0xff00 &&
+        attributes_.visual->blue_mask == 0xff &&
+        check_for_xshm(display_) != 0))
+  {
+    LOG(WARNING) << "Display attributes incompatible with SHM";
+    shm_n_ = -1;
+  }
+  else
+  {
+    for (int i = 0; i != 2; ++i) {
+      // Pick any old initial shape - it will be freed as soon as we start
+      // know what size we actually want (even if it is 1024x768!)
+      // This also allows us to check here that SHM actually works
+      if (shm_descs_[i].attach(display_, attributes_, 1024, 768) != 0)
+      {
+        shm_n_ = -1;
+        break;
+      }
+    }
+  }
 }
 
 SoftwareOutputDeviceX11::~SoftwareOutputDeviceX11() {
@@ -38,6 +205,32 @@ SoftwareOutputDeviceX11::~SoftwareOutputDeviceX11() {
   XFreeGC(display_, gc_);
 }
 
+
+void SoftwareOutputDeviceX11::Resize(const gfx::Size& viewport_pixel_size,
+                                  float scale_factor) {
+  scale_factor_ = scale_factor;
+
+  if (viewport_pixel_size_ == viewport_pixel_size)
+    return;
+
+  const SkImageInfo info(SkImageInfo::MakeN32(viewport_pixel_size.width(),
+                                          viewport_pixel_size.height(),
+                                          kOpaque_SkAlphaType));
+  viewport_pixel_size_ = viewport_pixel_size;
+
+  if (shm_n_ < 0) {
+    surface_ = SkSurface::MakeRaster(info);
+  }
+  else
+  {
+    for (int i = 0; i != 2; ++i) {
+      shm_descs_[i].resize(info);
+    }
+
+    surface_ = shm_descs_[shm_n_].use_surface();
+  }
+}
+
 void SoftwareOutputDeviceX11::EndPaint() {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
 
@@ -115,15 +308,26 @@ void SoftwareOutputDeviceX11::EndPaint() {
     return;
   }
 
-  // TODO(jbauman): Switch to XShmPutImage since it's async.
-  SkImageInfo info;
-  size_t rowBytes;
-  const void* addr = surface_->peekPixels(&info, &rowBytes);
-  gfx::PutARGBImage(
-      display_, attributes_.visual, attributes_.depth, compositor_->widget(),
-      gc_, static_cast<const uint8_t*>(addr), viewport_pixel_size_.width(),
-      viewport_pixel_size_.height(), rect.x(), rect.y(), rect.x(), rect.y(),
-      rect.width(), rect.height());
+  if (shm_n_ >= 0) {
+    shm_descs_[shm_n_].put_image(compositor_->widget(), static_cast<GC>(gc_), rect);
+    // Swap to other surface for next draw
+    // Could use sync if we only want 1 surface but that wastes time
+    //  XSync(display_, false);
+    shm_n_ = (shm_n_ + 1) % 2;
+    surface_ = shm_descs_[shm_n_].use_surface();
+  }
+  else
+  {
+    // TODO(jbauman): Switch to XShmPutImage since it's async.
+    SkImageInfo info;
+    size_t rowBytes;
+    const void* addr = surface_->peekPixels(&info, &rowBytes);
+    gfx::PutARGBImage(
+        display_, attributes_.visual, attributes_.depth, compositor_->widget(),
+        gc_, static_cast<const uint8_t*>(addr), viewport_pixel_size_.width(),
+        viewport_pixel_size_.height(), rect.x(), rect.y(), rect.x(), rect.y(),
+        rect.width(), rect.height());
+  }
 }
 
 }  // namespace content
diff --git a/src/content/browser/compositor/software_output_device_x11.h b/src/content/browser/compositor/software_output_device_x11.h
index 9fe571d..7dea7f8 100644
--- a/src/content/browser/compositor/software_output_device_x11.h
+++ b/src/content/browser/compositor/software_output_device_x11.h
@@ -6,11 +6,15 @@
 #define CONTENT_BROWSER_COMPOSITOR_SOFTWARE_OUTPUT_DEVICE_X11_H_
 
 #include <X11/Xlib.h>
+#include <X11/extensions/XShm.h>
 
 #include "base/macros.h"
 #include "cc/output/software_output_device.h"
 #include "ui/gfx/x/x11_types.h"
 
+#include <sys/ipc.h>
+#include <sys/shm.h>
+
 namespace ui {
 class Compositor;
 }
@@ -24,13 +28,38 @@ class SoftwareOutputDeviceX11 : public cc::SoftwareOutputDevice {
   ~SoftwareOutputDeviceX11() override;
 
   void EndPaint() override;
+  void Resize(const gfx::Size& viewport_pixel_size, float scale_factor) override;
 
  private:
   ui::Compositor* compositor_;
-  XDisplay* display_;
+  XDisplay* const display_;
   GC gc_;
   XWindowAttributes attributes_;
 
+  // Shared memory stuff
+
+  int shm_n_;
+  class ShmDesc
+  {
+      XShmSegmentInfo shminfo_;
+      XImage * shmimg_;
+      XDisplay* display_;
+      XWindowAttributes window_attributes_;
+      sk_sp<SkSurface> surface_;
+      SkImageInfo req_ii_;
+      SkImageInfo cur_ii_;
+
+public:
+      ShmDesc();
+      virtual ~ShmDesc();
+      int attach(XDisplay * const display, const XWindowAttributes& attributes, const int stride, const int h);
+      void detach();
+      void destroy();
+      void resize(const SkImageInfo& info);
+      Bool put_image(Drawable drawable, GC gc, const gfx::Rect& rect);
+      sk_sp<SkSurface> use_surface();
+  } shm_descs_[2];
+
   DISALLOW_COPY_AND_ASSIGN(SoftwareOutputDeviceX11);
 };
 
diff --git a/src/content/browser/renderer_host/render_process_host_impl.cc b/src/content/browser/renderer_host/render_process_host_impl.cc
index d565491..e64faa5 100644
--- a/src/content/browser/renderer_host/render_process_host_impl.cc
+++ b/src/content/browser/renderer_host/render_process_host_impl.cc
@@ -1565,6 +1565,13 @@ void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
 #if defined(OS_CHROMEOS)
     switches::kDisableVaapiAcceleratedVideoEncode,
 #endif
+    switches::kMmalFrameBuffers, switches::kMmalZeroCopy,
+    switches::kMmalFrameCopy,    switches::kMmalSliceCopy,
+    switches::kMmalDecodeI420,   switches::kMmalDecodeOpaque,
+    switches::kMmalResizeIsp,
+    switches::kMmalLowDelay,
+    switches::kMmalRedPixel,     switches::kMmalDecoders,
+    switches::kMmalDebugBench,   switches::kMmalDebugFixedSize,
   };
   renderer_cmd->CopySwitchesFrom(browser_cmd, kSwitchNames,
                                  arraysize(kSwitchNames));
diff --git a/src/content/browser/renderer_host/sandbox_ipc_linux.cc b/src/content/browser/renderer_host/sandbox_ipc_linux.cc
index 94a34b5..6a0d846 100644
--- a/src/content/browser/renderer_host/sandbox_ipc_linux.cc
+++ b/src/content/browser/renderer_host/sandbox_ipc_linux.cc
@@ -11,6 +11,8 @@
 #include <sys/poll.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
+#include <sys/ioctl.h>
+
 
 #include "base/command_line.h"
 #include "base/files/scoped_file.h"
@@ -156,6 +158,12 @@ void SandboxIPCHandler::HandleRequestFromRenderer(int fd) {
     HandleMakeSharedMemorySegment(fd, iter, fds);
   } else if (kind == LinuxSandbox::METHOD_MATCH_WITH_FALLBACK) {
     HandleMatchWithFallback(fd, iter, fds);
+  } else if (kind == LinuxSandbox::METHOD_OPEN_DEV_VCHIQ) {
+    HandleOpenDevVchiq(fd, iter, fds);
+  }
+  else
+  {
+    LOG(ERROR) << "Unexpected kind=" << kind;
   }
 }
 
@@ -349,6 +357,57 @@ void SandboxIPCHandler::HandleMakeSharedMemorySegment(
   SendRendererReply(fds, reply, shm_fd);
 }
 
+#define IOCTL_MBOX_PROPERTY _IOWR(100, 0, char *)
+#define VCIO_PATH "/dev/vcio"
+
+static uint32_t pi_firmware_date()
+{
+  int vcio_fd = IGNORE_EINTR(open(VCIO_PATH, 0));
+
+  if (vcio_fd == -1) {
+    PLOG(ERROR) << "Failed to open " VCIO_PATH;
+    return 0;
+  }
+
+  uint32_t req_buf[256] = {
+    (4+3)*4, 0,  // 4 args, + 3 overhead
+    1, 4, 4, 0,  // args
+  };
+
+  int err = IGNORE_EINTR(ioctl(vcio_fd, IOCTL_MBOX_PROPERTY, req_buf));
+  uint32_t rv = req_buf[5];
+
+  if (err < 0) {
+    PLOG(ERROR) << VCIO_PATH ": ioctl";
+    rv = 0;
+  }
+
+  if (IGNORE_EINTR(close(vcio_fd)) < 0)
+    PLOG(ERROR) << VCIO_PATH ": close";
+  return rv;
+}
+
+void SandboxIPCHandler::HandleOpenDevVchiq(
+    int fd,
+    base::PickleIterator iter,
+    const std::vector<base::ScopedFD>& fds)
+{
+  const int vchiq_fd = IGNORE_EINTR(open("/dev/vchiq", O_RDWR));
+
+  if (vchiq_fd == -1) {
+    PLOG(ERROR) << "Failed to open vchiq";
+  }
+
+  base::Pickle reply;
+  reply.WriteUInt32(pi_firmware_date());
+  SendRendererReply(fds, reply, vchiq_fd);
+
+  if (vchiq_fd >= 0) {
+    if (IGNORE_EINTR(close(vchiq_fd)) < 0)
+      PLOG(ERROR) << "close";
+  }
+}
+
 void SandboxIPCHandler::HandleMatchWithFallback(
     int fd,
     base::PickleIterator iter,
diff --git a/src/content/browser/renderer_host/sandbox_ipc_linux.h b/src/content/browser/renderer_host/sandbox_ipc_linux.h
index f1a6bd5..42f8345 100644
--- a/src/content/browser/renderer_host/sandbox_ipc_linux.h
+++ b/src/content/browser/renderer_host/sandbox_ipc_linux.h
@@ -61,6 +61,10 @@ class SandboxIPCHandler : public base::DelegateSimpleThread::Delegate {
                                base::PickleIterator iter,
                                const std::vector<base::ScopedFD>& fds);
 
+  void HandleOpenDevVchiq(int fd,
+                               base::PickleIterator iter,
+                               const std::vector<base::ScopedFD>& fds);
+
   void SendRendererReply(const std::vector<base::ScopedFD>& fds,
                          const base::Pickle& reply,
                          int reply_fd);
diff --git a/src/content/common/sandbox_linux/sandbox_linux.h b/src/content/common/sandbox_linux/sandbox_linux.h
index 7ce723b..5b2c013 100644
--- a/src/content/common/sandbox_linux/sandbox_linux.h
+++ b/src/content/common/sandbox_linux/sandbox_linux.h
@@ -52,6 +52,7 @@ class LinuxSandbox {
     METHOD_GET_STYLE_FOR_STRIKE = 35,
     METHOD_MAKE_SHARED_MEMORY_SEGMENT = 36,
     METHOD_MATCH_WITH_FALLBACK = 37,
+    METHOD_OPEN_DEV_VCHIQ,
   };
 
   // Get our singleton instance.
diff --git a/src/media/audio/alsa/alsa_output.cc b/src/media/audio/alsa/alsa_output.cc
index 9216def..f9ab901 100644
--- a/src/media/audio/alsa/alsa_output.cc
+++ b/src/media/audio/alsa/alsa_output.cc
@@ -134,7 +134,10 @@ const char AlsaPcmOutputStream::kPlugPrefix[] = "plug:";
 
 // We use 40ms as our minimum required latency. If it is needed, we may be able
 // to get it down to 20ms.
-const uint32_t AlsaPcmOutputStream::kMinLatencyMicros = 40 * 1000;
+// ** When life gets hard we don't seem to cycle fast enough for 40ms to be
+// long enough (actually it is approx half that as we put off reload until
+// half full)
+const uint32_t AlsaPcmOutputStream::kMinLatencyMicros = 200 * 1000;
 
 AlsaPcmOutputStream::AlsaPcmOutputStream(const std::string& device_name,
                                          const AudioParameters& params,
@@ -480,26 +483,28 @@ void AlsaPcmOutputStream::WritePacket() {
 void AlsaPcmOutputStream::WriteTask() {
   DCHECK(IsOnAudioThread());
 
-  if (stop_stream_)
-    return;
+  bool source_exhausted;
 
-  if (state() == kIsStopped)
-    return;
+  do
+  {
+    if (stop_stream_)
+      return;
 
-  bool source_exhausted;
-  BufferPacket(&source_exhausted);
-  WritePacket();
+    if (state() == kIsStopped)
+      return;
 
-  ScheduleNextWrite(source_exhausted);
+    BufferPacket(&source_exhausted);
+    WritePacket();
+  } while (ScheduleNextWrite(source_exhausted));
 }
 
-void AlsaPcmOutputStream::ScheduleNextWrite(bool source_exhausted) {
+bool AlsaPcmOutputStream::ScheduleNextWrite(bool source_exhausted) {
   DCHECK(IsOnAudioThread());
 
   if (stop_stream_ || state() != kIsPlaying)
-    return;
+    return false;
 
-  const uint32_t kTargetFramesAvailable = alsa_buffer_frames_ / 2;
+  const uint32_t kTargetFramesAvailable = frames_per_packet_;
   uint32_t available_frames = GetAvailableFrames();
 
   base::TimeDelta next_fill_time;
@@ -527,9 +532,14 @@ void AlsaPcmOutputStream::ScheduleNextWrite(bool source_exhausted) {
     next_fill_time = base::TimeDelta::FromMilliseconds(10);
   }
 
+  if (next_fill_time.is_zero()) {
+    return true;
+  }
+
   message_loop_->PostDelayedTask(FROM_HERE, base::Bind(
       &AlsaPcmOutputStream::WriteTask, weak_factory_.GetWeakPtr()),
       next_fill_time);
+  return false;
 }
 
 // static
diff --git a/src/media/audio/alsa/alsa_output.h b/src/media/audio/alsa/alsa_output.h
index e67253f..9586477 100644
--- a/src/media/audio/alsa/alsa_output.h
+++ b/src/media/audio/alsa/alsa_output.h
@@ -126,7 +126,7 @@ class MEDIA_EXPORT AlsaPcmOutputStream : public AudioOutputStream {
   void BufferPacket(bool* source_exhausted);
   void WritePacket();
   void WriteTask();
-  void ScheduleNextWrite(bool source_exhausted);
+  bool ScheduleNextWrite(bool source_exhausted);
 
   // Utility functions for talking with the ALSA API.
   static base::TimeDelta FramesToTimeDelta(int frames, double sample_rate);
diff --git a/src/media/base/media_switches.cc b/src/media/base/media_switches.cc
index baa93f9..3ff658d 100644
--- a/src/media/base/media_switches.cc
+++ b/src/media/base/media_switches.cc
@@ -114,6 +114,20 @@ const char kVideoUnderflowThresholdMs[] = "video-underflow-threshold-ms";
 const char kDisableRTCSmoothnessAlgorithm[] =
     "disable-rtc-smoothness-algorithm";
 
+const char kMmalFrameBuffers[]              = "mmal-frame-buffers";
+const char kMmalZeroCopy[]                  = "mmal-zero-copy";
+const char kMmalFrameCopy[]                 = "mmal-frame-copy";
+const char kMmalSliceCopy[]                 = "mmal-slice-copy";
+const char kMmalDecodeI420[]                = "mmal-decode-i420";
+const char kMmalDecodeOpaque[]              = "mmal-decode-opaque";
+const char kMmalResizeIsp[]                 = "mmal-resize-isp";
+const char kMmalLowDelay[]                  = "mmal-low-delay";
+const char kMmalRedPixel[]                  = "mmal-red-pixel";
+const char kMmalDecoders[]                  = "mmal-decoders";
+
+const char kMmalDebugBench[]                = "mmal-debug-bench";
+const char kMmalDebugFixedSize[]            = "mmal-debug-fixed-size";
+
 }  // namespace switches
 
 namespace media {
diff --git a/src/media/base/media_switches.h b/src/media/base/media_switches.h
index 2fbbb4f..fa7002f 100644
--- a/src/media/base/media_switches.h
+++ b/src/media/base/media_switches.h
@@ -61,6 +61,19 @@ MEDIA_EXPORT extern const char kVideoUnderflowThresholdMs[];
 
 MEDIA_EXPORT extern const char kDisableRTCSmoothnessAlgorithm[];
 
+MEDIA_EXPORT extern const char kMmalFrameBuffers[];
+MEDIA_EXPORT extern const char kMmalZeroCopy[];
+MEDIA_EXPORT extern const char kMmalFrameCopy[];
+MEDIA_EXPORT extern const char kMmalSliceCopy[];
+MEDIA_EXPORT extern const char kMmalDecodeI420[];
+MEDIA_EXPORT extern const char kMmalDecodeOpaque[];
+MEDIA_EXPORT extern const char kMmalResizeIsp[];
+MEDIA_EXPORT extern const char kMmalLowDelay[];
+MEDIA_EXPORT extern const char kMmalRedPixel[];
+MEDIA_EXPORT extern const char kMmalDecoders[];
+
+MEDIA_EXPORT extern const char kMmalDebugBench[];
+MEDIA_EXPORT extern const char kMmalDebugFixedSize[];
 }  // namespace switches
 
 namespace media {
diff --git a/src/media/base/video_frame.cc b/src/media/base/video_frame.cc
index b4a8392f..123f48b 100644
--- a/src/media/base/video_frame.cc
+++ b/src/media/base/video_frame.cc
@@ -121,7 +121,7 @@ bool VideoFrame::IsValidConfig(VideoPixelFormat format,
     return true;
 
   // Make sure new formats are properly accounted for in the method.
-  static_assert(PIXEL_FORMAT_MAX == 21,
+  static_assert(PIXEL_FORMAT_MAX == 22,
                 "Added pixel format, please review IsValidConfig()");
 
   if (format == PIXEL_FORMAT_UNKNOWN) {
@@ -521,6 +521,7 @@ size_t VideoFrame::NumPlanes(VideoPixelFormat format) {
     case PIXEL_FORMAT_RGB24:
     case PIXEL_FORMAT_RGB32:
     case PIXEL_FORMAT_MJPEG:
+    case PIXEL_FORMAT_MMAL_BUFFER:
       return 1;
     case PIXEL_FORMAT_NV12:
     case PIXEL_FORMAT_NV21:
@@ -1026,6 +1027,7 @@ gfx::Size VideoFrame::SampleSize(VideoPixelFormat format, size_t plane) {
         case PIXEL_FORMAT_RGB24:
         case PIXEL_FORMAT_RGB32:
         case PIXEL_FORMAT_MJPEG:
+        case PIXEL_FORMAT_MMAL_BUFFER:
           break;
       }
   }
@@ -1040,6 +1042,7 @@ int VideoFrame::BytesPerElement(VideoPixelFormat format, size_t plane) {
     case PIXEL_FORMAT_ARGB:
     case PIXEL_FORMAT_XRGB:
     case PIXEL_FORMAT_RGB32:
+    case PIXEL_FORMAT_MMAL_BUFFER:
       return 4;
     case PIXEL_FORMAT_RGB24:
       return 3;
diff --git a/src/media/base/video_frame.h b/src/media/base/video_frame.h
index 944a040..460c806 100644
--- a/src/media/base/video_frame.h
+++ b/src/media/base/video_frame.h
@@ -33,6 +33,8 @@ namespace media {
 
 class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
  public:
+  typedef base::Callback<void(const gfx::Size&)> MmalResizeCB;
+
   enum {
     kFrameSizeAlignment = 16,
     kFrameSizePadding = 16,
@@ -318,6 +320,9 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
   // accessed via data(), visible_data() etc.
   bool HasTextures() const;
 
+  // Mmal resize kludge info
+  MmalResizeCB mmal_resize_cb_;
+
   VideoPixelFormat format() const { return format_; }
   StorageType storage_type() const { return storage_type_; }
 
diff --git a/src/media/base/video_types.cc b/src/media/base/video_types.cc
index f8eeb3e..82445f4 100644
--- a/src/media/base/video_types.cc
+++ b/src/media/base/video_types.cc
@@ -54,6 +54,8 @@ std::string VideoPixelFormatToString(VideoPixelFormat format) {
       return "PIXEL_FORMAT_YUV444P9";
     case PIXEL_FORMAT_YUV444P10:
       return "PIXEL_FORMAT_YUV444P10";
+    case PIXEL_FORMAT_MMAL_BUFFER:
+      return "PIXEL_FORMAT_MMAL_BUFFER";
   }
   NOTREACHED() << "Invalid VideoPixelFormat provided: " << format;
   return "";
@@ -75,6 +77,7 @@ bool IsYuvPlanar(VideoPixelFormat format) {
     case PIXEL_FORMAT_YUV422P10:
     case PIXEL_FORMAT_YUV444P9:
     case PIXEL_FORMAT_YUV444P10:
+    case PIXEL_FORMAT_MMAL_BUFFER:
       return true;
 
     case PIXEL_FORMAT_UNKNOWN:
@@ -111,6 +114,7 @@ bool IsOpaque(VideoPixelFormat format) {
     case PIXEL_FORMAT_YUV422P10:
     case PIXEL_FORMAT_YUV444P9:
     case PIXEL_FORMAT_YUV444P10:
+    case PIXEL_FORMAT_MMAL_BUFFER:
       return true;
     case PIXEL_FORMAT_YV12A:
     case PIXEL_FORMAT_ARGB:
diff --git a/src/media/base/video_types.h b/src/media/base/video_types.h
index 7590b1b..ecf52e6 100644
--- a/src/media/base/video_types.h
+++ b/src/media/base/video_types.h
@@ -54,9 +54,11 @@ enum VideoPixelFormat {
   PIXEL_FORMAT_YUV444P9 = 20,
   PIXEL_FORMAT_YUV444P10 = 21,
 
+  PIXEL_FORMAT_MMAL_BUFFER = 22,
+
   // Please update UMA histogram enumeration when adding new formats here.
-  PIXEL_FORMAT_MAX =
-      PIXEL_FORMAT_YUV444P10,  // Must always be equal to largest entry logged.
+  PIXEL_FORMAT_MAX = PIXEL_FORMAT_MMAL_BUFFER
+//      PIXEL_FORMAT_YUV444P10,  // Must always be equal to largest entry logged.
 };
 
 // Color space or color range used for the pixels.
diff --git a/src/media/filters/mmal_video_decoder.cc b/src/media/filters/mmal_video_decoder.cc
new file mode 100644
index 0000000..065c255
--- /dev/null
+++ b/src/media/filters/mmal_video_decoder.cc
@@ -0,0 +1,3267 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/filters/mmal_video_decoder.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <algorithm>
+#include <string>
+
+#include "base/base_switches.h"
+#include "base/bind.h"
+#include "base/callback_helpers.h"
+#include "base/command_line.h"
+#include "base/location.h"
+#include "base/single_thread_task_runner.h"
+#include "base/pickle.h"
+#include "base/posix/unix_domain_socket_linux.h"
+#include "media/base/bind_to_current_loop.h"
+#include "media/base/decoder_buffer.h"
+#include "media/base/limits.h"
+#include "media/base/media_switches.h"
+#include "media/base/timestamp_constants.h"
+#include "media/base/video_frame.h"
+#include "media/base/video_util.h"
+#include "content/common/child_process_sandbox_support_impl_linux.h"
+#include "content/common/sandbox_linux/sandbox_linux.h"
+#include "content/public/common/content_switches.h"
+
+#include <interface/mmal/mmal.h>
+#include <interface/mmal/mmal_buffer.h>
+#include <interface/mmal/mmal_parameters_video.h>
+#include <interface/mmal/util/mmal_util.h>
+#include <interface/mmal/util/mmal_util_params.h>
+#include <interface/mmal/util/mmal_default_components.h>
+#include <interface/mmal/util/mmal_connection.h>
+#include <interface/mmal/core/mmal_buffer_private.h>  // *** debug
+#include <interface/mmal/vc/mmal_vc_api.h>
+
+#include <iomanip>
+
+// Debug & test defines
+#define OPT_FRAME_COPY_STASHED 1
+#define TRACE_COMPONENT_CREATION 0
+#define TRACE_TRAMPOLINE 0
+#define TRACE_FRAME_STASH_NEW  0  // Traces memory allocated by FrameStash
+
+// Missing defn
+#define MMAL_COMPONENT_DEFAULT_RESIZER "vc.ril.resize"
+#define MMAL_COMPONENT_ISP_RESIZER "vc.ril.isp"
+
+#define MMAL_SLICE_HEIGHT 16
+#define MMAL_ALIGN_W      32
+#define MMAL_ALIGN_H      16
+
+#define MMAL_LIMIT_WIDTH  VCOS_ALIGN_UP(1920, MMAL_ALIGN_W)
+#define MMAL_LIMIT_HEIGHT VCOS_ALIGN_UP(1088, MMAL_ALIGN_H)
+//#define MMAL_LIMIT_WIDTH  VCOS_ALIGN_UP(2048, MMAL_ALIGN_W)
+//#define MMAL_LIMIT_HEIGHT VCOS_ALIGN_UP(1280, MMAL_ALIGN_H)
+
+#define FRAME_COPY_DEFAULT_BUFFERS      2
+#define SLICE_COPY_DEFAULT_BUFFERS      16
+#define ZERO_COPY_DEFAULT_BUFFERS       6
+
+#define MAX_COPY_FRAMES_IN_FLIGHT       6
+
+namespace media {
+
+enum FrameCopyMode {
+  unset,
+  SLICE,
+  FRAME,
+  ZERO
+};
+
+// Only want/need to init mmal/vchiq once (per-process)
+// This checks it
+static bool vchiq_init_done = false;
+
+// Not strictly a decoder count - this is inced @ initialisation
+static volatile base::subtle::Atomic32 decoder_count = 0;
+
+// Task runner - current SingleThread - probably no reason
+// why it shouldn't be Sequenced so typedef for ease of changing
+typedef scoped_refptr<base::SingleThreadTaskRunner> MmalTaskRunner;
+
+
+// Some classes that we have fwd refs to
+class MmalConnectedPort;
+class MmalComponent;
+
+// ----------------------------------------------------------------------------
+//
+// Misc helper fns
+
+// Zap & release buffer
+static void buffer_release(MMAL_BUFFER_HEADER_T * const buffer)
+{
+  mmal_buffer_header_reset(buffer);
+  mmal_buffer_header_release(buffer);
+}
+
+// Calculate pixel aspect ratio
+static gfx::Size par_from_sizes(const gfx::Size& coded, const gfx::Size& natural)
+{
+  uint32_t a = coded.width() * natural.height();
+  uint32_t b = coded.height() * natural.width();
+
+  // Deal with the trivial case
+
+  if (a == b) {
+    return gfx::Size(1, 1);
+  }
+
+  // reduce - probably not needed but it might well save overflow
+  // or precision reduction later in the code
+  // We only expect to do this at init time so inefficiency isn't important
+
+  static const uint32_t primes[] = {2, 3, 5, 7, 11, 13, 17, 19};
+  for (int i = 0; i != sizeof(primes)/sizeof(primes[0]); ++i) {
+    const uint32_t p = primes[i];
+    while (a % p == 0 && b % p == 0) {
+      a /= p;
+      b /= p;
+    }
+  }
+
+  return gfx::Size(b, a);
+}
+
+// Convert a time_t to a printable string
+// * Surely there is a std C++ fn for this?
+static std::string strgmtimet(const time_t tt)
+{
+  char tbuf[32];
+  struct tm tm;
+  gmtime_r(&tt, &tm);
+  tbuf[sizeof(tbuf)-1] = 0;
+  snprintf(tbuf, sizeof(tbuf) - 1, "%04d-%02d-%02d %02d:%02d:%02d UTC",
+      tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+      tm.tm_hour, tm.tm_min, tm.tm_sec);
+  return std::string(tbuf);
+}
+
+//-----------------------------------------------------------------------------
+
+
+class MmalVideoDecoder::Options
+{
+  const bool single_process_;
+  const bool zero_copy_;
+  const bool frame_copy_;
+  const bool slice_copy_;
+  const bool red_pixel_;
+  const bool decode_opaque_;
+  const bool decode_i420_;
+  const bool resize_isp_;
+  const bool low_delay_;
+  const unsigned int frame_buffers_;
+  const unsigned int decoders_;
+
+  const bool debug_bench_;
+  const gfx::Size debug_fixed_size_;
+
+  static unsigned int cl_uint(const base::CommandLine& cmd_line, const char name[], const unsigned int def_val = 0)
+  {
+      unsigned int val;
+      return base::StringToUint(cmd_line.GetSwitchValueNative(name), &val) ? val : def_val;
+  }
+
+  static bool cl_flag(const base::CommandLine& cmd_line, const char name[])
+  {
+      return cmd_line.HasSwitch(name);
+  }
+
+  static gfx::Size cl_size(const base::CommandLine& cmd_line, const char name[])
+  {
+      const char * const cl(cmd_line.GetSwitchValueNative(name).c_str());
+      char * eoi = NULL;
+      const unsigned long w = strtoul(cl, &eoi, 10);
+      if (*eoi != 'x' && *eoi != 'X') {
+        return gfx::Size();
+      }
+      const unsigned long h = strtoul(eoi + 1, &eoi, 10);
+      if (*eoi != '\0') {
+        return gfx::Size();
+      }
+      return gfx::Size(w, h);
+  }
+
+  Options(const base::CommandLine& cmd_line) :
+    single_process_(cl_flag(cmd_line, switches::kSingleProcess)),
+    zero_copy_(cl_flag(cmd_line, switches::kMmalZeroCopy)),
+    frame_copy_(cl_flag(cmd_line, switches::kMmalFrameCopy)),
+    slice_copy_(cl_flag(cmd_line, switches::kMmalSliceCopy)),
+    red_pixel_(cl_flag(cmd_line, switches::kMmalRedPixel)),
+    decode_opaque_(cl_flag(cmd_line, switches::kMmalDecodeOpaque)),
+    decode_i420_(cl_flag(cmd_line, switches::kMmalDecodeI420)),
+    resize_isp_(cl_flag(cmd_line, switches::kMmalResizeIsp)),
+    low_delay_(cl_flag(cmd_line, switches::kMmalLowDelay)),
+    frame_buffers_(cl_uint(cmd_line, switches::kMmalFrameBuffers)),
+    decoders_(cl_uint(cmd_line, switches::kMmalDecoders, 1)),
+    debug_bench_(cl_flag(cmd_line, switches::kMmalDebugBench)),
+    debug_fixed_size_(cl_size(cmd_line, switches::kMmalDebugFixedSize))
+  {
+  }
+
+public:
+  static scoped_ptr<Options> Create(const base::CommandLine& cmd_line = *base::CommandLine::ForCurrentProcess())
+  {
+    return scoped_ptr<Options>(new Options(cmd_line));
+  }
+
+  // Default encoding currently I420
+  MMAL_FOURCC_T decoder_out_encoding() const
+  {
+    return decode_opaque_ ? MMAL_ENCODING_OPAQUE : MMAL_ENCODING_I420;
+  }
+
+  const char * resizer_component_name() const
+  {
+    return resize_isp_ ? MMAL_COMPONENT_ISP_RESIZER : MMAL_COMPONENT_DEFAULT_RESIZER;
+  }
+
+  FrameCopyMode frame_copy_mode(const bool has_slice_resize) const
+  {
+    return zero_copy_ ? FrameCopyMode::ZERO :
+      frame_copy_ ? FrameCopyMode::FRAME :
+      slice_copy_ ? FrameCopyMode::SLICE :
+      has_slice_resize ? FrameCopyMode::SLICE : FrameCopyMode::FRAME;
+  }
+
+  unsigned int frame_buffers(const FrameCopyMode copy_mode) const
+  {
+    return frame_buffers_ != 0 ? frame_buffers_ :
+      copy_mode == FrameCopyMode::ZERO ? ZERO_COPY_DEFAULT_BUFFERS :
+      copy_mode == FrameCopyMode::SLICE ? SLICE_COPY_DEFAULT_BUFFERS : FRAME_COPY_DEFAULT_BUFFERS;
+  }
+
+  bool single_process() const
+  {
+    return single_process_;
+  }
+
+  bool max_decoders() const
+  {
+    return decoders_;
+  }
+
+  bool red_pixel() const
+  {
+    return red_pixel_;
+  }
+
+  bool low_delay(const bool low_delay_req = false) const
+  {
+    return low_delay_ || low_delay_req;
+  }
+
+  bool debug_bench() const
+  {
+    return debug_bench_;
+  }
+
+  bool debug_fixed_size_set() const
+  {
+    return debug_fixed_size_.width() > 0 && debug_fixed_size_.height()  > 0;
+  }
+
+  gfx::Size debug_fixed_size() const
+  {
+    return debug_fixed_size_;
+  }
+
+  std::string ToString() const
+  {
+    std::ostringstream s;
+    s << "mmal frame_buffers=" << frame_buffers_ <<
+       ", mmal_X_copy (z/f/s)=" << zero_copy_  << "/"  << frame_copy_ << "/" << slice_copy_ <<
+       ", mmal_low_delay=" << low_delay_ <<
+       ", mmal_decode_i420/opaque=" << decode_i420_ << "/" << decode_opaque_ <<
+       ", mmal_resize_isp=" << resize_isp_ <<
+       ", mmal_decoders=" << decoders_ <<
+       ", mmal_debug_bench=" << debug_bench_ <<
+       ", mmal_debug_fixed_size=" << debug_fixed_size_.ToString();
+    return s.str();
+  }
+};
+
+
+//-----------------------------------------------------------------------------
+
+#if TRACE_FRAME_STASH_NEW
+volatile base::subtle::Atomic32 total_stash_alloc = 0;
+#endif
+
+// Simple class to stash frames
+// Thread unsafe - use external locks
+class FrameStash
+{
+  size_t size_;
+  std::stack<uint8_t *> frames_;
+
+  // delete & new frame fns for easy tracking
+  static void delete_frame(uint8_t * const ptr, const size_t size)
+  {
+#if TRACE_FRAME_STASH_NEW
+    const base::subtle::Atomic32 talloc = base::subtle::NoBarrier_AtomicIncrement(&total_stash_alloc, -(base::subtle::Atomic32)size);
+    LOG(ERROR) << "Delete frame: size=" << size << ", total=" << talloc;
+#endif
+    base::AlignedFree(ptr);
+  }
+
+  static uint8_t * new_frame(const size_t size)
+  {
+#if TRACE_FRAME_STASH_NEW
+    const base::subtle::Atomic32 talloc = base::subtle::NoBarrier_AtomicIncrement(&total_stash_alloc, (base::subtle::Atomic32)size);
+    LOG(ERROR) << "New frame: size=" << size << ", total=" << talloc;
+#endif
+    return reinterpret_cast<uint8_t*>(base::AlignedAlloc(size, VideoFrame::kFrameAddressAlignment));
+  }
+
+  uint8_t * frame_pop()
+  {
+    uint8_t * const frame = frames_.top();
+    frames_.pop();
+    return frame;
+  }
+
+  void empty_frames()
+  {
+    while (!frames_.empty()) {
+      delete_frame(frame_pop(), size_);
+    }
+  }
+
+public:
+  FrameStash()
+  {
+  }
+  virtual ~FrameStash()
+  {
+    empty_frames();
+  }
+
+  void free_frame(uint8_t * const frame, const size_t frame_size)
+  {
+    if (frame_size != size_) {
+      delete_frame(frame, frame_size);
+    }
+    else {
+      frames_.push(frame);
+    }
+  }
+
+  uint8_t * alloc_frame(const size_t size)
+  {
+    if (size != size_) {
+      empty_frames();
+    }
+    size_ = size;
+
+    uint8_t * const frame = (size == 0) ? NULL :
+      frames_.empty() ? new_frame(size) : frame_pop();
+
+    return frame;
+  }
+};
+
+//-----------------------------------------------------------------------------
+
+// Trampoline class
+// This allows us to attach callbacks from VideoFrames to our
+// component / port without it locking down the component.
+// If the component is dead by the time the callback arrives then it is simply
+// dropped on the floor
+//
+// * Extended well past original intention - rather more than just
+//   a trampoline now... Should be renamed
+
+// A number of functions in this class (in particular "kill") look like they
+// might cause suicide which would be bad as the AutoLock would be removed
+// after it was destroyed. This is prevented by the fact that this class should
+// only be accessed though scoped_refptrs so the calling fn should have a ref
+// on us for at least the duration of the call.
+
+class MmalTrampoline : public base::RefCountedThreadSafe<MmalTrampoline>
+{
+  typedef base::Callback<void(const int)> MmalCopiedFramedDestructionCB;
+#if TRACE_TRAMPOLINE
+  // These two are only used for debug
+  static int seq_count_; // Seq number counter
+  const int seq_;  // Debugging sequence number
+#endif
+
+  base::Lock lock_;
+  int in_flight_;
+  bool low_traced_;
+  const int max_in_flight_;
+  VideoFrame::MmalResizeCB resize_cb_;
+  MmalCopiedFramedDestructionCB destruction_cb_;
+  FrameStash frame_stash_;
+
+  void resize_trampoline(const gfx::Size& size)
+  {
+//    LOG(ERROR) << __func__ ;
+    base::AutoLock lock(lock_);
+    if (!resize_cb_.is_null())
+      resize_cb_.Run(size);
+  }
+
+  friend base::RefCountedThreadSafe<MmalTrampoline>;
+  virtual ~MmalTrampoline()
+  {
+//    LOG(ERROR) << "@@@ " << __func__ << "[" << seq_ << "]";
+  }
+public:
+  MmalTrampoline(
+      const int max_in_flight,
+      const VideoFrame::MmalResizeCB& resize_cb,
+      const MmalCopiedFramedDestructionCB& destruction_cb) :
+#if TRACE_TRAMPOLINE
+    seq_(++seq_count_),
+#endif
+    in_flight_(0),
+    low_traced_(true),
+    max_in_flight_(max_in_flight),
+    resize_cb_(resize_cb),
+    destruction_cb_(destruction_cb)
+  {
+#if TRACE_TRAMPOLINE
+    LOG(ERROR) << "@@@ " <<  __func__ << "[" << seq_ << "]";
+#endif
+  }
+
+  VideoFrame::MmalResizeCB new_resize_cb()
+  {
+    return base::Bind(&MmalTrampoline::resize_trampoline, this);
+  }
+
+  void kill()
+  {
+#if TRACE_TRAMPOLINE
+    LOG(ERROR) << "--- "  << "[" << seq_ << "] Trampoline::kill";
+#endif
+    base::AutoLock lock(lock_);
+    resize_cb_.Reset();
+    destruction_cb_.Reset();
+    frame_stash_.alloc_frame(0); // Will flush out anything we have stashed
+  }
+
+  void free_frame(uint8_t * const frame, const size_t size, const int buffer_count)
+  {
+    lock_.Acquire();
+
+    // Some callbacks can call us back
+    // We don't have recursive locks - so copy the callback for later use
+    // outside the lock
+    const MmalCopiedFramedDestructionCB cb = destruction_cb_;
+
+    frame_stash_.free_frame(frame, size);
+
+    // in_flight_ can exceed max_in_flight_ by the number of frames
+    // that can fit in the mmal port.  Avoid stuffing more than we have had returned.
+    const int stuff_count = std::min(in_flight_ - max_in_flight_, buffer_count);
+
+    if ((in_flight_ -= buffer_count) < 0)
+      LOG(FATAL) << "Buffers in flight underflow";
+
+#if TRACE_TRAMPOLINE
+    LOG(ERROR)  << "[" << seq_ << "] killed=" << destruction_cb_.is_null() << ", in_flight:" << in_flight_ << "/" << max_in_flight_ <<
+      ", BCount=" << buffer_count <<
+      ", Stuff=" << stuff_count;
+#endif
+    // Some hysteresis on in_flight logging - do not log if killed
+    if (in_flight_ < max_in_flight_ / 2 && !low_traced_ && !cb.is_null()) {
+      low_traced_ = true;
+      LOG(INFO) << "--- In flight low: " << in_flight_ << "/" << max_in_flight_;
+    }
+    else if (in_flight_ >= max_in_flight_ - 1 && low_traced_) {
+      low_traced_ = false;
+      LOG(INFO) << "--- In flight OK: " << in_flight_ << "/" << max_in_flight_;
+    }
+
+    lock_.Release();
+
+    if (stuff_count > 0 && !cb.is_null())
+      cb.Run(std::min(buffer_count, stuff_count));
+  }
+
+  uint8_t * alloc_frame(const size_t size)
+  {
+    base::AutoLock lock(lock_);
+    return frame_stash_.alloc_frame(size);
+  }
+
+  bool recycle_buffer_in_flight(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    lock_.Acquire();
+    const bool wants_recycle = (++in_flight_ <= max_in_flight_);
+    lock_.Release();
+
+    if (wants_recycle)
+    {
+#if TRACE_TRAMPOLINE
+      LOG(ERROR) << "[" << seq_ << "] recycle: in flight=" << in_flight_;
+#endif
+      return true;
+    }
+#if TRACE_TRAMPOLINE
+    LOG(ERROR) << "[" << seq_ << "] release, in_flight=" << in_flight_;
+#endif
+
+    // Was Deadlock opportunity
+    // ?? pool starvation opportunity now
+
+    buffer_release(buffer);
+    return false;
+  }
+
+  bool is_stalling() const
+  {
+    return in_flight_ >= max_in_flight_;
+  }
+};
+
+#if TRACE_TRAMPOLINE
+int MmalTrampoline::seq_count_ = 0;
+#endif
+
+//-----------------------------------------------------------------------------
+
+static inline size_t RoundUp(size_t value, size_t alignment) {
+  return ((value + (alignment - 1)) & ~(alignment - 1));
+}
+
+
+class MmalCopiedVideoFrame : public media::VideoFrame
+{
+  scoped_refptr<MmalTrampoline> trampoline_;
+  size_t data_size_;
+  int buffer_count_;
+
+  ~MmalCopiedVideoFrame() override;
+
+public:
+  MmalCopiedVideoFrame(const scoped_refptr<MmalTrampoline>& trampoline,
+      const gfx::Size& size,
+      const base::TimeDelta timestamp = kNoTimestamp()) :
+    VideoFrame(PIXEL_FORMAT_MMAL_BUFFER,
+      STORAGE_UNOWNED_MEMORY, size, gfx::Rect(size), size, timestamp),
+    trampoline_(trampoline),
+    buffer_count_(0)
+  {
+    // Allow 1 line overread (see VideoFrame::AllocateYUV)
+    const size_t height = RoundUp(rows(0) + 1, kFrameSizeAlignment * 2);
+    const size_t stride = RoundUp(row_bytes(0), kFrameSizeAlignment);
+    data_size_ = height * stride + kFrameSizePadding;
+
+    set_data(0, trampoline_->alloc_frame(data_size_));
+    set_stride(0, stride);
+
+    mmal_resize_cb_ = trampoline_->new_resize_cb();
+  }
+
+  void inc_buffer_count()
+  {
+    ++buffer_count_;
+  }
+};
+
+MmalCopiedVideoFrame::~MmalCopiedVideoFrame()
+{
+  trampoline_->free_frame(data(0), data_size_, buffer_count_);
+}
+
+//-----------------------------------------------------------------------------
+//
+// VideoFrame class that deals with the case where the frame is copied into
+// an mmal buffer by the firmware and we then move the frame buffer from the mmal
+// buffer header to our frame.  This requires more careful buffer management than
+// the copy or zero variaitions.  See MmalFramePool for the buffer pool logic.
+
+class MmalStashedVideoFrame : public media::VideoFrame
+{
+  scoped_refptr<MmalTrampoline> trampoline_;
+  size_t data_size_;
+  const int buffer_count_;
+
+  ~MmalStashedVideoFrame() override;
+
+public:
+  // Create a VideoFrame and move the frame stash into it from
+  // the mmal buffer
+  MmalStashedVideoFrame(MMAL_BUFFER_HEADER_T * const buffer,
+      const scoped_refptr<MmalTrampoline>& trampoline,
+      const gfx::Size& size,
+      const size_t stride,
+      const base::TimeDelta timestamp = kNoTimestamp()) :
+    VideoFrame(PIXEL_FORMAT_MMAL_BUFFER,
+      STORAGE_UNOWNED_MEMORY, size, gfx::Rect(size), size, timestamp),
+    trampoline_(trampoline),
+    data_size_(buffer->alloc_size),
+    buffer_count_(1)
+  {
+    set_data(0, buffer->data);
+    set_stride(0, stride);
+
+    buffer->data = nullptr;
+    buffer->alloc_size = 0;
+
+//    LOG(ERROR) << "@@@ " << __func__;
+
+    mmal_resize_cb_ = trampoline_->new_resize_cb();
+  }
+};
+
+MmalStashedVideoFrame::~MmalStashedVideoFrame()
+{
+//  LOG(ERROR) << "@@@ " << __func__;
+  trampoline_->free_frame(data(0), data_size_, buffer_count_);
+}
+
+//-----------------------------------------------------------------------------
+
+class MmalZeroVideoFrame : public media::VideoFrame
+{
+  const base::Closure destruction_cb_;
+
+  ~MmalZeroVideoFrame() override;
+
+public:
+  MmalZeroVideoFrame(
+      const gfx::Size& size,
+      uint8_t * const data,
+      size_t stride,
+      const MmalResizeCB& resize_cb,
+      const base::Closure& destruction_cb,
+      const base::TimeDelta timestamp = kNoTimestamp()) :
+    VideoFrame(PIXEL_FORMAT_MMAL_BUFFER,
+      STORAGE_UNOWNED_MEMORY, size, gfx::Rect(size), size, timestamp),
+    destruction_cb_(destruction_cb)
+  {
+    set_data(0, data);
+    set_stride(0, stride);
+    mmal_resize_cb_ = resize_cb;
+  }
+};
+
+MmalZeroVideoFrame::~MmalZeroVideoFrame()
+{
+  destruction_cb_.Run();
+}
+
+// ----------------------------------------------------------------------------
+
+// Pool base class - can be instantiated
+class MmalPool
+{
+public:
+  typedef base::Callback<bool(MMAL_BUFFER_HEADER_T * buffer)> MmalPoolBufferReleaseCB;
+
+private:
+  MmalPoolBufferReleaseCB pool_cb_;
+
+protected:
+  virtual bool do_pool_cb(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    return pool_cb_.Run(buffer);
+  }
+
+private:
+  static MMAL_BOOL_T static_pool_cb(MMAL_POOL_T *pool, MMAL_BUFFER_HEADER_T *buffer, void *userdata)
+  {
+    return ((MmalPool *)userdata)->do_pool_cb(buffer);
+  }
+
+protected:
+  MMAL_POOL_T * pool_;
+
+  MmalPool() :
+    pool_(nullptr)
+  {
+  }
+
+  // Must be called as part of create if you ever want callbacks to work
+  void set_static_pool_cb()
+  {
+    mmal_pool_callback_set(pool_, static_pool_cb, this);
+  }
+
+public:
+  // N.B. Overriding classes are responsible for freeing pool_ correctly
+  virtual ~MmalPool()
+  {
+  }
+
+  void set_buffer_release_cb(const MmalPoolBufferReleaseCB& cb)
+  {
+    pool_cb_ = cb;
+  }
+
+  virtual MMAL_BUFFER_HEADER_T * get_timeout(const uint32_t timeout_ms)
+  {
+    return mmal_queue_timedwait(pool_->queue, timeout_ms);
+  }
+
+  virtual MMAL_BUFFER_HEADER_T * get()
+  {
+    return mmal_queue_get(pool_->queue);
+  }
+
+  virtual void put(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    mmal_queue_put(pool_->queue, buffer);
+  }
+
+  // Do the equivalent of put then get
+  // Will refresh buffer->data if required
+  virtual MMAL_BUFFER_HEADER_T * put_get(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    return buffer;
+  }
+
+  uint32_t length() const
+  {
+    return mmal_queue_length(pool_->queue);
+  }
+
+  // Pool size (not data size)
+  uint32_t size() const
+  {
+    return pool_->headers_num;
+  }
+
+  // Thing we are servicing may have changed shape
+  // By default ignore
+  virtual int port_resized(const uint32_t num, const uint32_t size)
+  {
+    return 0;
+  }
+
+  virtual int create(const uint32_t num, const uint32_t size) = 0;
+
+  // Enable/disable aren't required fns but add helpful hints
+  // to some derived classes
+  // * Could be used to debug unexpected pool movement
+  virtual int disable()
+  {
+    return 0;
+  }
+
+  virtual int enable()
+  {
+    return 0;
+  }
+
+  // This isn't exactly part of a base pool implementation
+  // but it saves a spurious extra layer
+  virtual void set_trampoline(const scoped_refptr<MmalTrampoline>& trampoline)
+  {
+  }
+};
+
+//-----------------------------------------------------------------------------
+//
+// Pool attached to a port
+class MmalPortPool : public MmalPool
+{
+  MMAL_PORT_T * const port_;
+public:
+  MmalPortPool(MMAL_PORT_T * const port) :
+    port_(port)
+  {
+  }
+
+  ~MmalPortPool() override
+  {
+    if (pool_ != NULL) {
+      mmal_port_pool_destroy(port_, pool_);
+    }
+  }
+
+  int create(const uint32_t num, const uint32_t size) override
+  {
+    if ((pool_ = mmal_port_pool_create(port_, num, size)) == NULL)
+    {
+      LOG(ERROR) << "### mmal_port_pool_create failed: " << num << "*" << size;
+      return -1;
+    }
+    set_static_pool_cb();
+    return 0;
+  }
+};
+
+//-----------------------------------------------------------------------------
+//
+// Pool not attached to a port
+
+class MmalUserPool : public MmalPool
+{
+public:
+  MmalUserPool()
+  {
+  }
+
+  ~MmalUserPool() override
+  {
+    if (pool_ != NULL) {
+      mmal_pool_destroy(pool_);
+    }
+  }
+
+  int create(const uint32_t num, const uint32_t size) override
+  {
+    if ((pool_ = mmal_pool_create(num, size)) == NULL)
+    {
+      LOG(ERROR) << "### mmal_pool_create failed: " << num << "*" << size;
+      return -1;
+    }
+    set_static_pool_cb();
+    return 0;
+  }
+};
+
+//-----------------------------------------------------------------------------
+//
+// Pool that has detachable frame buffers allocated by our trampoline
+// Buffers in the pool have no frame buffers attached
+// Buffers are attached on get and detached on release
+// * For a more generic version we could have callback alloc/free fns
+class MmalFramePool : public MmalUserPool
+{
+  scoped_refptr<MmalTrampoline> trampoline_;
+  size_t size_;
+
+  MMAL_BUFFER_HEADER_T * attach_data_buffer(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    // Ignore null
+    if (buffer != nullptr) {
+      if (buffer->data != NULL) {
+        LOG(FATAL) << "Buffer already in use";
+      }
+
+      if ((buffer->data = trampoline_->alloc_frame(size_)) == nullptr)
+      {
+        LOG(ERROR) << "### " << __func__ << ": alloc frame failed";
+        // If we cannot alloc then release buffer back to pool as we are about
+        // to lose track of it
+        buffer_release(buffer);
+        return nullptr;
+      }
+      buffer->alloc_size = size_;
+    }
+    return buffer;
+  }
+
+  MMAL_BUFFER_HEADER_T * detach_data_buffer(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    if (buffer != nullptr && buffer->data != nullptr) {
+      // This is called on buffer release so should have no "in-flight" component
+      trampoline_->free_frame(buffer->data, buffer->alloc_size, 0);
+      buffer->data = nullptr;
+      buffer->alloc_size = 0;
+    }
+    return buffer;  // For convienience
+  }
+
+protected:
+  bool do_pool_cb(MMAL_BUFFER_HEADER_T * const buffer) override
+  {
+    return MmalUserPool::do_pool_cb(detach_data_buffer(buffer));
+  }
+
+public:
+  MmalFramePool() :
+    size_(0)
+  {
+  }
+
+  int create(const uint32_t num, const uint32_t size) override
+  {
+    if (MmalUserPool::create(num, 0) != 0) {
+      return -1;
+    }
+    size_ = size;
+    return 0;
+  }
+
+  MMAL_BUFFER_HEADER_T * get_timeout(const uint32_t timeout_ms) override
+  {
+    return attach_data_buffer(MmalUserPool::get_timeout(timeout_ms));
+  }
+
+  MMAL_BUFFER_HEADER_T * get() override
+  {
+    return attach_data_buffer(MmalUserPool::get());
+  }
+
+  void put(MMAL_BUFFER_HEADER_T * const buffer) override
+  {
+    MmalUserPool::put(detach_data_buffer(buffer));
+  }
+
+  // This is effectively a realloc to the current size and will
+  // attach a buffer if none was attached before
+  // Useful when recycling a buffer directly back into a port
+  MMAL_BUFFER_HEADER_T * put_get(MMAL_BUFFER_HEADER_T * const buffer) override
+  {
+    if (buffer->alloc_size == size_)
+      return buffer;
+
+    return attach_data_buffer(detach_data_buffer(buffer));
+  }
+
+  int disable() override
+  {
+    // Avoid keeping an otherwise unused trampoline alive longer than needed
+    trampoline_ = nullptr;
+    return MmalUserPool::disable();
+  }
+
+  int port_resized(const uint32_t num, const uint32_t size) override
+  {
+    // Remember for future allocation and that is all we want to do
+    size_ = size;
+    return 0;
+  }
+
+  // As this has no locking this should only be called when disabled
+  // (in most cases this means that the port we are servicing is disabled)
+  void set_trampoline(const scoped_refptr<MmalTrampoline>& trampoline) override
+  {
+    trampoline_ = trampoline;
+  }
+};
+
+//=============================================================================
+//
+// Wrapper for an mmal port
+
+class MmalPort
+{
+  // Actually connection should be a subclass?
+  friend class MmalConnection;
+
+protected:
+public:
+  MMAL_PORT_T * port_;
+  bool killing_;
+
+  virtual void event_cb(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    LOG(ERROR) << "### Unexpected ES data";
+    mmal_buffer_header_release(buffer);
+  }
+
+  virtual void cmd_cb(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    if (buffer->cmd == MMAL_EVENT_ERROR) {
+        LOG(WARNING) << "### Mmal reports error " << *(uint32_t *)buffer->data;
+    } else if (buffer->cmd == MMAL_EVENT_FORMAT_CHANGED) {
+      mmal_log_dump_port(port_);
+      const MMAL_EVENT_FORMAT_CHANGED_T *const fc = mmal_event_format_changed_get(buffer);
+      LOG(INFO) << "Mmal format changed: size_min:" << fc->buffer_size_min <<
+        ", num_min:" << fc->buffer_num_min <<
+          ", size_rec:" << fc->buffer_size_recommended <<
+          ", num_rec:" << fc->buffer_num_recommended;
+      if (fc->format != NULL) {
+        mmal_log_dump_format(fc->format);
+      }
+    } else {
+        char s[20];
+        LOG(WARNING) << "### Mmal unexpected command: " << mmal_4cc_to_string(s, sizeof(s), buffer->cmd);
+    }
+
+    // Commands are allocated from a different pool to ES data
+    // return to sender...
+    mmal_buffer_header_release(buffer);
+  }
+
+private:
+  void callback_common(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    if (buffer->cmd != 0) {
+      // Cmd buffers are not allocated from the main pool
+      cmd_cb(buffer);
+    }
+    else
+    {
+      if (killing_) {
+        // If flushing always release the buffer
+        mmal_buffer_header_release(buffer);
+      }
+      else {
+        event_cb(buffer);
+      }
+    }
+  }
+
+  static void callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
+  {
+    MmalPort *p = static_cast<MmalPort*>((void*)port->userdata);
+
+    if (p == NULL) {
+      LOG(ERROR) << __func__ << "### Port NULL";
+    }
+    else
+    {
+      p->callback_common(buffer);
+    }
+  }
+
+public:
+  virtual int enable()
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+
+    if (killing_) {
+      LOG(ERROR) << "### port enable when killed";
+      return -1;
+    }
+
+    if ((err = mmal_port_enable(port_, callback)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_port_enable failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  virtual int disable()
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+
+    if (port_ != NULL && port_->is_enabled) {
+      err = mmal_port_disable(port_);
+    }
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  virtual int commit()
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+
+    if ((err = mmal_port_format_commit(port_)) != MMAL_SUCCESS)
+    {
+      LOG(ERROR) << "### mmal_port_format_commit failed: err=" << err;
+      mmal_log_dump_port(port_);
+    }
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  uint32_t buffer_size() const
+  {
+    return port_->buffer_size;
+  }
+
+  uint32_t buffer_num() const
+  {
+    return port_->buffer_num;
+  }
+
+  // This set of fns are overridden by MmalConnectedPort
+  // to provide max of connected ports
+  virtual uint32_t buffer_size_recommended() const
+  {
+    return port_->buffer_size_recommended;
+  }
+
+  virtual uint32_t buffer_size_min() const
+  {
+    return port_->buffer_size_recommended;
+  }
+
+  virtual uint32_t buffer_num_recommended() const
+  {
+    return port_->buffer_num_recommended;
+  }
+
+  virtual uint32_t buffer_num_min() const
+  {
+    return port_->buffer_num_min;
+  }
+
+  virtual int set_buffers(const uint32_t size, const uint32_t num)
+  {
+    port_->buffer_num = num;
+    port_->buffer_size = size;
+    return 0;
+  }
+
+  int set_buffers_recommended()
+  {
+    return set_buffers(buffer_size_recommended(), buffer_num_recommended());
+  }
+
+  int set_parameter(const uint32_t param, const uint32_t val) const
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+    if ((err = mmal_port_parameter_set_uint32(port_, param, val)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_port_parameter_set_uint32 failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  inline int set_parameter(const uint32_t param, const int val) const
+  {
+    return set_parameter(param, (uint32_t)(val));
+  }
+
+  int set_parameter(const uint32_t param, const bool val) const
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+    if ((err = mmal_port_parameter_set_boolean(port_, param, val ? MMAL_TRUE : MMAL_FALSE)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_port_parameter_set_boolean failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  int get_parameter(MMAL_PARAMETER_HEADER_T * const param) const
+  {
+    MMAL_STATUS_T err = MMAL_SUCCESS;
+    if ((err = mmal_port_parameter_get(port_, param)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_port_parameter_get failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  // class for storing the supported encodings parameter info
+  class SupportedEncodings
+  {
+    static const int max_encodings_ = 64;
+    struct {
+       MMAL_PARAMETER_HEADER_T header_;
+       MMAL_FOURCC_T encodings_[max_encodings_];
+    } supported_;
+    int n_;
+
+  public:
+    SupportedEncodings(const MmalPort& port) :
+      supported_({{MMAL_PARAMETER_SUPPORTED_ENCODINGS, sizeof(supported_)}, {0}}),
+      n_(-1)
+    {
+      if (port.get_parameter(&supported_.header_) == 0)
+      {
+        n_ = (supported_.header_.size - sizeof(supported_.header_)) /
+          sizeof(supported_.encodings_[0]);
+      }
+    }
+
+    virtual ~SupportedEncodings()
+    {
+    }
+
+    // Default copy is OK
+
+    bool is_supported(const MMAL_FOURCC_T x) const
+    {
+      // If we end up doing this a lot for any reason then use a better lookup
+      for (int i = 0; i < n_; ++i) {
+        if (x == supported_.encodings_[i]) {
+          return true;
+        }
+      }
+      return false;
+    }
+  };
+
+  SupportedEncodings get_parameter_supported_encodings() const
+  {
+    return SupportedEncodings(*this);
+  }
+
+  static MMAL_FOURCC_T color_space_to_mmal(const ColorSpace color_space)
+  {
+    switch (color_space) {
+      case ColorSpace::COLOR_SPACE_JPEG:
+        return MMAL_COLOR_SPACE_JPEG_JFIF;
+      case ColorSpace::COLOR_SPACE_HD_REC709:
+        return MMAL_COLOR_SPACE_ITUR_BT709;
+      case ColorSpace::COLOR_SPACE_SD_REC601:
+        return MMAL_COLOR_SPACE_ITUR_BT601;
+      case ColorSpace::COLOR_SPACE_UNSPECIFIED:
+        return MMAL_COLOR_SPACE_UNKNOWN;
+    }
+    return MMAL_COLOR_SPACE_UNKNOWN;
+  }
+
+  int set_video_encoding(
+    const MMAL_FOURCC_T encoding,
+    const MMAL_FOURCC_T encoding_variant = MMAL_ENCODING_VARIANT_DEFAULT,
+    const uint32_t flags = 0)
+  {
+    MMAL_ES_FORMAT_T *const format = port_->format;
+
+    format->type = MMAL_ES_TYPE_VIDEO;
+    format->encoding = encoding;
+    format->encoding_variant = encoding_variant;
+    format->flags = 0;
+    format->bitrate = 0;
+    return 0;
+  }
+
+  // Fill in all of a MMAL_VIDEO_FORMAT_T
+  int set_video_format(
+      const gfx::Size& size,
+      const gfx::Size& par = gfx::Size(),
+      const ColorSpace color_space = ColorSpace::COLOR_SPACE_UNSPECIFIED) const
+  {
+    MMAL_ES_FORMAT_T *const format = port_->format;
+    MMAL_VIDEO_FORMAT_T *const video = &format->es->video;
+    const bool isyuv = format->encoding == MMAL_ENCODING_I420;
+
+    const uint32_t w = size.width();
+    const uint32_t h = size.height();
+
+    video->width = VCOS_ALIGN_UP(w, isyuv ? 32 : 16);
+    video->height = VCOS_ALIGN_UP(h, 16);
+    video->crop.x = 0;
+    video->crop.y = 0;
+    video->crop.width = w;
+    video->crop.height = h;
+    video->frame_rate.num = 30000;  // Not in config - make something valid up
+    video->frame_rate.den = 1001;
+    video->par.num = par.width();
+    video->par.den = par.height();
+    video->color_space = color_space_to_mmal(color_space);
+    return 0;
+  }
+
+  // Disable once we forget about it
+  virtual ~MmalPort()
+  {
+    disable();
+  }
+
+  MmalPort() :
+    port_(NULL),
+    killing_(false)
+  {
+  }
+
+  virtual void set_port(MMAL_PORT_T * const port)
+  {
+    if (port_ != NULL) {
+      LOG(ERROR) << "### Port not null";
+      return;
+    }
+
+    port->userdata = (struct MMAL_PORT_USERDATA_T *)(void *)this;
+    port_ = port;
+  }
+
+  // Submit a buffer - on failure (or kill) buffer is released
+  int submit(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    MMAL_STATUS_T err;
+
+    if (killing_ || !port_->is_enabled) {
+      mmal_buffer_header_release(buffer);
+      return 0;
+    }
+
+    if ((err = mmal_port_send_buffer(port_, buffer)) != MMAL_SUCCESS)
+    {
+      // Release buffer on error
+      mmal_buffer_header_release(buffer);
+      LOG(ERROR) << "#### mmal_send_buffer (" << buffer << ") failed: err=" << err;
+    }
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  void kill()
+  {
+    killing_ = true;
+    disable();
+  }
+
+  void dump_video_format()
+  {
+    const MMAL_ES_FORMAT_T * const format = port_->format;
+    const MMAL_VIDEO_FORMAT_T *const video = &format->es->video;
+    char buf1[10], buf2[10];
+
+    LOG(ERROR) << port_->name << ": Encoding:" << mmal_4cc_to_string(buf1, sizeof(buf1), format->encoding) <<
+    ":" << mmal_4cc_to_string(buf2, sizeof(buf2), format->encoding_variant) <<
+        ", " << video->width << "x" << video->height;
+  }
+
+};
+
+// ---------------------------------------------------------------------------
+
+class MmalConnection : public base::RefCountedThreadSafe<MmalConnection>
+{
+  friend MmalConnectedPort;
+
+  bool enabled_;
+  MMAL_CONNECTION_T * connection_;
+  MmalConnectedPort * src_;
+  MmalConnectedPort * dest_;
+
+  friend base::RefCountedThreadSafe<MmalConnection>;
+  virtual ~MmalConnection()
+  {
+    if (connection_ != NULL) {
+      mmal_connection_destroy(connection_);
+    }
+  }
+
+  MmalConnection() :
+    enabled_(false),
+    connection_(NULL),
+    src_(NULL),
+    dest_(NULL)
+  {
+  }
+
+  void disconnect();
+  int connect(MmalConnectedPort * const src, MmalConnectedPort * const dest);
+
+  int enable()
+  {
+    MMAL_STATUS_T err;
+
+    if (enabled_) {
+      // Bad stuff (tm) seems to happen if we multiply en/disable connections
+      return 0;
+    }
+
+    if ((err = mmal_connection_enable(connection_)) != MMAL_SUCCESS) {
+      LOG(ERROR) << "### mmal_connection_enable failed: err=" << err;
+      return -1;
+    }
+
+    enabled_ = true;
+    return 0;
+  }
+
+  int disable()
+  {
+    MMAL_STATUS_T err;
+
+    if (!enabled_) {
+      // Bad stuff (tm) seems to happen if we multiply en/disable connections
+      return 0;
+    }
+
+    // Mark as disabled even if we fail as in this case I have no idea how
+    // to recover and retry is very unlikely to help
+    enabled_ = false;
+
+    if ((err = mmal_connection_disable(connection_)) != MMAL_SUCCESS) {
+      LOG(ERROR) << "### mmal_connection_disable failed: err=" << err;
+      return -1;
+    }
+
+    return 0;
+  }
+
+  uint32_t buffer_size_recommended() const;
+  uint32_t buffer_num_recommended() const;
+  uint32_t buffer_size_min() const;
+  uint32_t buffer_num_min() const;
+  int set_buffers(uint32_t s, uint32_t n);
+};
+
+// ----------------------------------------------------------------------------
+//
+// Port that we are expecting to be attached to another port by an MmalConnection
+
+class MmalConnectedPort : public MmalPort
+{
+  scoped_refptr<MmalConnection> connection_;
+
+public:
+  void set_connection(MmalConnection * connection)
+  {
+    connection_ = connection;
+  }
+
+  int disconnect()
+  {
+    if (connection_ != NULL) {
+      connection_->disconnect();
+    }
+    return 0;
+  }
+
+  int enable() override
+  {
+    return connection_->enable();
+  }
+
+  int disable() override
+  {
+    return connection_ == NULL ? 0 : connection_->disable();
+  }
+
+  int connect_to_src(MmalConnectedPort * const src)
+  {
+    scoped_refptr<MmalConnection> connection(new MmalConnection());
+    return connection->connect(src, this);
+  }
+
+  uint32_t buffer_size_recommended() const override
+  {
+    return connection_->buffer_size_recommended();
+  }
+
+  uint32_t buffer_num_recommended() const override
+  {
+    return connection_->buffer_num_recommended();
+  }
+
+  uint32_t buffer_size_min() const override
+  {
+    return connection_->buffer_size_min();
+  }
+
+  uint32_t buffer_num_min() const override
+  {
+    return connection_->buffer_num_min();
+  }
+
+  int set_buffers(const uint32_t s, const uint32_t n) override
+  {
+    return connection_->set_buffers(s, n);
+  }
+
+  ~MmalConnectedPort() override
+  {
+    disconnect();
+  }
+};
+
+// ----------------------------------------------------------------------------
+
+class MmalPortAndPool : public MmalPort
+{
+  typedef scoped_refptr<MmalPortAndPool> AutoRef;
+
+  MmalComponent * const component_;
+
+  scoped_ptr<MmalPool> pool_;
+
+  static bool pool_cb(MmalPortAndPool * mpp, MMAL_BUFFER_HEADER_T *buffer)
+  {
+    // As the release can cause us to commit suicide we must put the buffer
+    // back by hand before calling Release as if we try to do it afterwards
+    // the Q may have vanished and we would crash.
+    mpp->pool_->put(buffer);
+    mpp->Release();
+    return false;  // We did the put back ourselves
+  }
+
+protected:
+  virtual void buffer_event_cb(MMAL_BUFFER_HEADER_T * const buffer) = 0;
+
+private:
+  // Given that we now have ref counts that can hit zero when all buffers are
+  // returned to the pool ensure that we can't commit untimely suicide by
+  // holding a ref on ourselves until the callback is over.
+  // This could probably be ensured by careful coding of the overriding
+  // callbacks but this removes the possibility of unexpected surprises
+  void event_cb(MMAL_BUFFER_HEADER_T * const buffer) final
+  {
+    AutoRef(this)->buffer_event_cb(buffer);
+  }
+
+protected:
+  int set_pool(MmalPool *const pool, const uint32_t num)
+  {
+    pool_ = scoped_ptr<MmalPool>(pool);
+    if (pool_->create(num, port_->buffer_size) != 0) {
+      return -1;
+    }
+    pool_->set_buffer_release_cb(base::Bind(MmalPortAndPool::pool_cb, this));
+    return 0;
+  }
+
+  int set_pool(MmalPool *const pool)
+  {
+    return set_pool(pool, port_->buffer_num);
+  }
+
+public:
+  // These allow us to use scoped_refptr on this object
+  // They trampoline to the enclosing component
+  void AddRef() const;
+  void Release();
+
+  const MmalTaskRunner& task_runner() const;
+
+  template<typename T>
+  base::Callback<T> bind_to_task_runner(const base::Callback<T>& cb)
+  {
+    return base::Bind(&internal::TrampolineHelper<T>::Run,
+                      MmalTaskRunner(task_runner()), cb);
+  }
+  void task_run(const base::Closure& cb)
+  {
+    task_runner()->PostTask(FROM_HERE, cb);
+  }
+
+  MmalPortAndPool(MmalComponent * const component) :
+    component_(component)
+  {
+//    LOG(ERROR) << __func__;
+  }
+
+  ~MmalPortAndPool() override
+  {
+    disable();
+  }
+
+  int create_port_pool()
+  {
+    return set_pool(new MmalPortPool(port_));
+  }
+
+  int create_user_pool(const uint32_t buffer_num)
+  {
+    return set_pool(new MmalUserPool(), buffer_num);
+  }
+
+  MMAL_BUFFER_HEADER_T * pool_get(const bool wait = false)
+  {
+    if (pool_ == NULL) {
+      LOG(ERROR) << "### Pool not set up\n";
+      return NULL;
+    }
+
+    MMAL_BUFFER_HEADER_T * const header =  wait ?
+      pool_->get_timeout(5000) : pool_->get();
+
+    if (header != NULL) {
+      AddRef();
+    }
+
+    return header;
+  }
+
+  int pool_size() const
+  {
+    return pool_->size();
+  }
+
+  int queue_length() const
+  {
+    return pool_->length();
+  }
+
+  // Stuff all the pool entries into the port
+  int stuff()
+  {
+    MMAL_BUFFER_HEADER_T * buffer;
+    while ((buffer = pool_get()) != NULL) {
+      // When flushing/disabling we may have left stuff with lengths in the pool
+      mmal_buffer_header_reset(buffer);
+      if (submit(buffer) != 0)
+        return -1;
+    }
+    return 0;
+  }
+
+  int stuff(int stuff_count, const bool wait = false)
+  {
+    while (--stuff_count >= 0)
+    {
+      MMAL_BUFFER_HEADER_T * buffer;
+      if ((buffer = pool_get(wait)) == NULL)
+      {
+        LOG(ERROR) << "### Unexpected pool_get_failure";
+        return -1;
+      }
+
+      // When flushing/disabling we may have left stuff with lengths in the pool
+      mmal_buffer_header_reset(buffer);
+      if (submit(buffer) != 0)
+        return -1;
+    }
+    return 0;
+  }
+
+  void recycle(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    submit(pool_->put_get(buffer));
+  }
+
+  int enable() override
+  {
+    if (pool_ == nullptr)
+    {
+      LOG(ERROR) << "MmalPoolAndPort::enable: pool NULL";
+      return -1;
+    }
+
+    if (pool_->port_resized(port_->buffer_num, port_->buffer_size) != 0 ||
+        pool_->enable() != 0)
+      return -1;
+
+    return MmalPort::enable();
+  }
+
+  int disable() override
+  {
+    const int rv = MmalPort::disable();
+    return (pool_ != nullptr && pool_->disable() != 0) ? -1 : rv;
+  }
+
+  int commit() override
+  {
+    const int rv = MmalPort::commit();
+    // ** Notify pool that size may have changed
+    return rv;
+  }
+
+  void set_trampoline(scoped_refptr<MmalTrampoline>& trampoline)
+  {
+    pool_->set_trampoline(trampoline);
+  }
+};
+
+// ----------------------------------------------------------------------------
+
+class MmalVideoESPort : public MmalPortAndPool
+{
+  VideoDecoder::DecodeCB decode_cb_;
+  scoped_refptr<DecoderBuffer> submit_buffer_;
+  uint32_t submit_offset_;
+  bool low_delay_;
+
+public:
+  MmalVideoESPort(MmalComponent * const component) :
+    MmalPortAndPool(component),
+    low_delay_(false)
+  {
+  }
+  ~MmalVideoESPort() override
+  {
+  }
+
+  void set_port(MMAL_PORT_T * const port) override
+  {
+    MmalPort::set_port(port);
+  }
+
+  int config(const VideoDecoderConfig& config, const bool low_delay)
+  {
+    low_delay_ = low_delay;
+
+    MMAL_FOURCC_T encoding = MMAL_ENCODING_UNKNOWN;
+
+    switch (config.codec()) {
+      case kCodecH264:
+        encoding = MMAL_ENCODING_H264;
+        break;
+      case kCodecVC1:
+        encoding = MMAL_ENCODING_WVC1;
+        break;
+      case kCodecMPEG2:
+        encoding = MMAL_ENCODING_MP2V;
+        break;
+      case kCodecMPEG4:
+        encoding = MMAL_ENCODING_MP4V;
+        break;
+      default:
+        LOG(ERROR) << "### Unexpected video codec:" << config.codec();
+        return -1;
+    }
+
+    set_video_encoding(encoding, MMAL_ENCODING_VARIANT_DEFAULT, MMAL_ES_FORMAT_FLAG_FRAMED);
+
+    set_video_format(config.coded_size(),
+        par_from_sizes(config.coded_size(), config.natural_size()),
+        config.color_space());
+
+    return 0;
+  }
+
+private:
+  int submit_data(const uint8_t * const data, const uint32_t len,
+      const base::TimeDelta& pts,
+      const bool is_start, const bool not_pkt)
+  {
+    uint32_t bsent = 0;
+
+    MMAL_BUFFER_HEADER_T * const buffer = pool_get(not_pkt);
+    if (buffer == NULL) {
+      return 0;
+    }
+
+//    LOG(ERROR) << "-- submit len=" << len << ", pts=" << pts;
+
+    // resets length, offset, flags, pts, dts
+    mmal_buffer_header_reset(buffer);
+    buffer->cmd = 0;
+    buffer->user_data = NULL;
+
+    if (data == NULL)
+    {
+        buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS;
+        // As this is zero length avoid poking the data
+        bsent = 1; // 0 means did nothing so pick another number
+    }
+    else
+    {
+        if (is_start)
+        {
+            buffer->pts = (pts == kNoTimestamp()) ? MMAL_TIME_UNKNOWN : pts.InMicroseconds();
+//            buffer->dts = avpkt->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->dts;
+            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START | MMAL_BUFFER_HEADER_FLAG_USER0;
+        }
+
+        bsent = buffer->length = std::min(len, buffer->alloc_size);
+
+        if (mmal_buffer_header_mem_lock(buffer) != MMAL_SUCCESS)
+        {
+            LOG(ERROR) << "#### Cannot lock buffer";
+            buffer_release(buffer);
+            return -1;
+        }
+
+        memcpy(buffer->data, data, buffer->length);
+
+        mmal_buffer_header_mem_unlock(buffer);
+
+        if (len == bsent)
+            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;
+
+        if (not_pkt)
+            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;
+    }
+
+//    LOG(ERROR) << "Submit: flags=" << std::hex << buffer->flags << std::dec << ", len=" << buffer->length << ", pts=" << buffer->pts;
+
+    if (MmalPortAndPool::submit(buffer) != 0)
+    {
+      return -1;
+    }
+
+    return (int)bsent;
+  }
+
+  void submit_done(const DecodeStatus status)
+  {
+    VideoDecoder::DecodeCB cb(decode_cb_);
+
+    decode_cb_.Reset();
+    submit_buffer_ = NULL;
+
+//    LOG(ERROR) << ">>> decode_cb.Run(" << status << ")";
+    cb.Run(status);
+  }
+
+  void submit_poll()
+  {
+    if (submit_buffer_ == NULL) {
+//      LOG(ERROR) << "ES CB null";
+      return;
+    }
+
+    if (submit_buffer_->end_of_stream()) {
+      LOG(INFO) << "<<< EOS";
+
+      int bsent = submit_data(NULL, 0, kNoTimestamp(), true, false);
+
+      if (bsent != 0)
+      {
+        decode_cb_.Reset();
+        submit_buffer_ = NULL;
+
+        // The callback on EOS takes place much later & from the resizer output
+      }
+    }
+    else
+    {
+//      LOG(ERROR) << "submit";
+      const uint32_t size = submit_buffer_->data_size();
+
+      while (submit_offset_ < size) {
+        const int bsent = submit_data(submit_buffer_->data() + submit_offset_,
+            size - submit_offset_,
+            submit_buffer_->timestamp(),
+            submit_offset_ == 0, false);
+
+//        LOG(ERROR) << "es submit bsent=" << bsent << ", pql=" << queue_length();
+
+        if (bsent <= 0)
+        {
+          if (bsent != 0)
+            submit_done(DecodeStatus::DECODE_ERROR);
+          return;
+        }
+
+        submit_offset_ += bsent;
+      }
+
+      // If we've got here then we've got a finished submit_buffer_
+      // wait for pool empty before signalling "next"
+      if (!low_delay_ || queue_length() == pool_size()) {
+//        LOG(ERROR) << "submit done";
+        submit_done(DecodeStatus::OK);
+      }
+    }
+  }
+
+  void buffer_event_cb(MMAL_BUFFER_HEADER_T * const buffer) override
+  {
+    buffer_release(buffer);
+
+    task_run(base::Bind(&MmalVideoESPort::submit_poll, this));
+  }
+
+
+public:
+  int submit(const scoped_refptr<DecoderBuffer>& buffer, const VideoDecoder::DecodeCB& decode_cb)
+  {
+    if (submit_buffer_ != NULL) {
+      LOG(ERROR) << "### Submit already active";
+      return -1;
+    }
+
+    if (decode_cb.is_null()) {
+      // If null CB then assume we need sync output
+      return submit_data(buffer->data(), buffer->data_size(), buffer->timestamp(), true, true) < 0 ? -1 : 0;
+    }
+    else
+    {
+      // * If we aren't in the same thread as task_runner_ at this point
+      //   then this lot is unsafe...
+
+      submit_buffer_ = buffer;
+      submit_offset_ = 0;
+      decode_cb_ = decode_cb;
+
+      submit_poll();
+    }
+    return 0;
+  }
+
+  int disable() override
+  {
+    // Get and kill any pending submit_callback
+    if (submit_buffer_ != NULL) {
+      submit_done(DecodeStatus::ABORTED);
+    }
+    return MmalPortAndPool::disable();
+  }
+};
+
+
+// ----------------------------------------------------------------------------
+//
+// * It might be nice to split this into ZC & Copy versions but as it stands
+//   the port is declared directly in the component which makes that tricky
+
+class MmalVideoARGBPort : public MmalPortAndPool
+{
+  FrameCopyMode copy_mode_;
+  gfx::Size req_size_;
+  VideoDecoder::OutputCB output_cb_;
+  VideoDecoder::DecodeCB eos_cb_;
+  base::Lock resize_lock_;
+  bool eos_sent_;
+  bool red_pixel_;
+  scoped_refptr<MmalTrampoline> frame_trampoline_;
+  scoped_refptr<MmalCopiedVideoFrame> sliced_frame_;
+  int sliced_y_;
+  base::subtle::Atomic32 zc_buffers_in_flight_;
+  base::TimeDelta last_pts_;
+  bool debug_bench_;
+  bool resize_disabled_;
+
+  class FpS
+  {
+    static uint64_t utime()
+    {
+      struct timespec ts;
+      clock_gettime(CLOCK_MONOTONIC, &ts);
+      return (uint64_t)ts.tv_sec * 1000000 + ts.tv_nsec / 1000;
+    }
+
+    uint64_t start_time_;
+    uint64_t period_time_;
+    unsigned int frame_count_;
+
+    void do_start()
+    {
+      start_time_ = utime();
+      period_time_ = start_time_;
+    }
+
+  public:
+    FpS() :
+      start_time_(0),
+      period_time_(0),
+      frame_count_(0)
+    {
+    }
+
+    void start()
+    {
+      frame_count_ = 0;
+    }
+
+    void inc_frames()
+    {
+      if (frame_count_++ == 0)
+        do_start();
+    }
+
+    bool period_expired(const uint64_t duration_us)
+    {
+      const uint64_t now = utime();
+      if (period_time_ + duration_us <= now) {
+        period_time_ += duration_us;
+        return true;
+      }
+      return false;
+    }
+
+    std::string ToString()
+    {
+      if (start_time_ == 0) {
+        return std::string("<uninit>");
+      }
+      const uint64_t now = utime();
+      if (start_time_ == now) {
+        return std::string("<inf>");
+      }
+      const uint64_t mFpS = ((uint64_t)frame_count_ * 1000000000) / (now - start_time_);
+      std::ostringstream s;
+      s << frame_count_  << " @ "
+        << mFpS / 1000 << "." << std::setfill('0') << std::setw(3) << mFpS % 1000;
+      return s.str();
+    }
+  };
+
+  FpS fps;
+
+  void kill_trampoline()
+  {
+    if (frame_trampoline_)
+    {
+      frame_trampoline_->kill();
+      frame_trampoline_ = NULL;
+    }
+  }
+
+  // Mostly required to discard the return value
+  void posted_submit(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+//    LOG(ERROR) << "--- " << __func__;
+    submit(buffer);
+  }
+
+  void recycle_buffer(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+    mmal_buffer_header_reset(buffer);
+
+    if (resize_lock_.Try()) {
+      recycle(buffer);
+      resize_lock_.Release();
+    }
+    else
+    {
+      // Move the recycle onto the main thread which should be the one running
+      // the resize so no further locking required
+      //
+      // ??? Interaction with max_in_flight_ ???
+      task_run(base::Bind(&MmalVideoARGBPort::recycle, this, buffer));
+    }
+  }
+
+  // Unlocks buffer & recycles it
+  void zc_frame_destruction_cb(MMAL_BUFFER_HEADER_T * const buffer)
+  {
+//    LOG(ERROR) << __func__;
+    const base::subtle::Atomic32 n = base::subtle::NoBarrier_AtomicIncrement(&zc_buffers_in_flight_, -1);
+
+    if (n < pool_size() / 2) {
+      LOG(INFO) << "--- in flight low:" << n;
+    }
+
+    mmal_buffer_header_mem_unlock(buffer);
+    recycle_buffer(buffer);
+  }
+
+  // Called from trampoline on free_frame
+  // so may come from a random thread
+  void copied_frame_destruction_cb(const int buffer_count)
+  {
+    // stuff may have to wait for a buffer as the recycling
+    // cannot be protected by the trampoline lock with the current
+    // code so we have a race
+    if (stuff(buffer_count, true) == -1)
+      LOG(FATAL) << "No buffers to back up recycle request";
+  }
+
+  void resize_posted(const gfx::Size req_size)
+  {
+    if (req_size.width() <= 0 || req_size.height() <= 0 || req_size == size())
+      return;
+
+    LOG(INFO) << __func__ << "(" << req_size.ToString() << ")";
+
+    base::AutoLock lock(resize_lock_);
+    disable();
+    set_size(req_size);
+    commit();
+    if (copy_mode_ == FrameCopyMode::FRAME) {
+      set_buffers(buffer_size_recommended(), buffer_num());
+    }
+    enable();
+
+    LOG(INFO) << __func__ << " done";
+  }
+
+  void resize_cb(const gfx::Size& size)
+  {
+//    LOG(ERROR) << __func__ << "(" << size.ToString() << ")";
+
+    if (size == req_size_ || resize_disabled_) {
+      return;
+    }
+    req_size_ = size;
+
+    // Avoid running in the callback - run on our own thread
+    task_run(base::Bind(&MmalVideoARGBPort::resize_posted, this, size));
+  }
+
+public:
+  gfx::Size size() const
+  {
+    return gfx::Size(port_->format->es->video.crop.width, port_->format->es->video.crop.height);
+  }
+
+private:
+
+  void mov_frame_block(const scoped_refptr<MmalCopiedVideoFrame>& frame,
+      MMAL_BUFFER_HEADER_T * const buffer,
+      const size_t stride,
+      const size_t width,
+      const size_t start_y,
+      const int lines)
+  {
+    MMAL_STATUS_T err;
+
+    if ((err = mmal_buffer_header_mem_lock(buffer)) != MMAL_SUCCESS)
+    {
+      LOG(ERROR) << "### Unable to lock buffer; err=" << err;
+      return;
+    }
+
+    const uint8_t * s = buffer->data + buffer->type->video.offset[0];
+    const size_t d_stride = frame->stride(0);
+    uint8_t * d = frame->data(0) + start_y * d_stride;
+    const size_t line_size = width * 4;
+
+    for (int i = 0; i < lines; ++i, s += stride, d += d_stride)
+      memcpy(d, s, line_size);
+
+    // Unlock & recycles
+    mmal_buffer_header_mem_unlock(buffer);
+
+    // Count buffers used by this frame
+    frame->inc_buffer_count();
+
+    if (frame_trampoline_->recycle_buffer_in_flight(buffer)) {
+      recycle_buffer(buffer);
+    }
+  }
+
+  void emit_copied_frame(const scoped_refptr<VideoFrame>& frame)
+  {
+    if (debug_bench_) {
+      // In bench mode just drop the frame on the floor
+      return;
+    }
+    if (red_pixel_) {
+      // Mark our frames with happy red pixels
+      uint8_t * d = frame->data(0);
+      const size_t d_stride = frame->stride(0);
+
+      for (int i = 0; i != 8; ++i, d += d_stride) {
+          for (int j = 0; j != 8 * 4; j += 4) {
+              d[j+0] = 0;
+              d[j+1] = 0;
+              d[j+2] = 0xff;
+              d[j+3] = 0xff;
+          }
+      }
+    }
+
+    output_cb_.Run(frame);
+  }
+
+protected:
+  void buffer_event_cb(MMAL_BUFFER_HEADER_T * const buffer) override
+  {
+    // One might have hoped that buffer->type->video.pitch[0] held this info...
+    const int stride = mmal_encoding_width_to_stride(port_->format->encoding, port_->format->es->video.width);
+    const gfx::Size cur_size = size();
+
+//    const base::TimeDelta pts(kNoTimestamp());
+
+    const base::TimeDelta pts(buffer->pts == MMAL_TIME_UNKNOWN ?
+        kNoTimestamp() :
+        base::TimeDelta::FromMicroseconds(buffer->pts));
+
+#if 0
+    if ((buffer->flags & MMAL_BUFFER_HEADER_FLAG_FRAME_END) != 0) {
+      LOG(ERROR) << "-- Got frame from resizer: copy_mode=" << copy_mode_ << ", len=" << buffer->length <<
+          ", size = " << port_->format->es->video.width << "x" << port_->format->es->video.height << ", req=" << cur_size.ToString() <<
+          ", stride=" << buffer->type->video.pitch[0] << "/" << stride << ", pts=" << buffer->pts <<
+          ", flags=" << std::hex << buffer->flags << std::dec << ", enabled=" << port_->is_enabled <<
+          ", pts_delta=" << (pts - last_pts_).InMicroseconds();
+        ;
+    }
+#endif
+
+    if ((buffer->flags & MMAL_BUFFER_HEADER_FLAG_EOS) != 0) {
+      LOG(INFO) << ">>> EOS";
+      if (debug_bench_) {
+        LOG(ERROR) << "@@@@ EOS: fps=" << fps.ToString();
+      }
+      // Finally call the decode CB
+      if (!eos_cb_.is_null()) {
+        eos_cb_.Run(DecodeStatus::OK);
+        eos_cb_.Reset();
+        eos_sent_ = true;
+      }
+      // Remember to recycle the buffer!
+      recycle_buffer(buffer);
+      return;
+    }
+
+    if (buffer->length == 0) {
+      // Empty flushed buffer
+      recycle_buffer(buffer);
+      return;
+    }
+
+    eos_sent_ = false;
+
+    switch (copy_mode_) {
+      case FrameCopyMode::unset:
+        LOG(ERROR) << "### copy mode unset";
+        recycle_buffer(buffer);
+        break;
+
+      case FrameCopyMode::ZERO:
+      {
+        if (debug_bench_) {
+          recycle_buffer(buffer);
+          break;
+        }
+
+        mmal_buffer_header_mem_lock(buffer);
+
+        scoped_refptr<VideoFrame> frame(new MmalZeroVideoFrame(cur_size,
+          buffer->data + buffer->type->video.offset[0],
+          stride,
+          base::Bind(&MmalVideoARGBPort::resize_cb, this),
+          base::Bind(&MmalVideoARGBPort::zc_frame_destruction_cb, this, buffer),
+          pts));
+
+        base::subtle::NoBarrier_AtomicIncrement(&zc_buffers_in_flight_, 1);
+
+        if (pts != kNoTimestamp())
+          last_pts_ = pts;
+
+        output_cb_.Run(frame);
+        break;
+      }
+
+      case FrameCopyMode::FRAME:
+      {
+        // * Arguably we should be creating ARGB buffers here rather than MMAL
+        //   but we have only carved a path through the rest of the video
+        //   render stack for MMAL
+
+#if OPT_FRAME_COPY_STASHED
+        // Firmware-side frame copy
+        scoped_refptr<VideoFrame> frame(new MmalStashedVideoFrame(
+          buffer,
+          frame_trampoline_,
+          cur_size,
+          stride,
+          pts));
+
+        if (frame_trampoline_->recycle_buffer_in_flight(buffer)) {
+          recycle_buffer(buffer);
+        }
+#else
+        // Arm-side frame copy
+        scoped_refptr<MmalCopiedVideoFrame> frame(new MmalCopiedVideoFrame(
+          frame_trampoline_,
+          cur_size,
+          pts));
+
+        mov_frame_block(frame, buffer, stride, cur_size.width(), 0, cur_size.height());
+#endif
+
+        emit_copied_frame(frame);
+
+        if (pts != kNoTimestamp())
+          last_pts_ = pts;
+
+        break;
+      }
+
+      case FrameCopyMode::SLICE:
+      {
+        // Remember end of frame flag as we kill the buffer before using it
+        const bool eof = (buffer->flags & MMAL_BUFFER_HEADER_FLAG_FRAME_END) != 0;
+
+        if (sliced_frame_ == NULL) {
+          sliced_y_ = 0;
+          // pts only correct at eof
+          sliced_frame_ = new MmalCopiedVideoFrame(frame_trampoline_, cur_size);
+        }
+
+        mov_frame_block(sliced_frame_, buffer, stride, cur_size.width(), sliced_y_,
+            std::min(MMAL_SLICE_HEIGHT, sliced_frame_->rows(0) - sliced_y_));
+
+        if ((sliced_y_ += MMAL_SLICE_HEIGHT) < sliced_frame_->rows(0))
+        {
+          // Partial - stop now
+          if (eof) {
+            // Partial frame - discard
+            sliced_frame_ = NULL;
+            LOG(WARNING) << "### frame underrun";
+          }
+          return;
+        }
+        if (!eof) {
+          // Overrun
+          LOG(WARNING) << "### frame overrun";
+        }
+        sliced_frame_->set_timestamp(pts);
+
+        if (pts != kNoTimestamp())
+          last_pts_ = pts;
+
+        // Make sure sliced_frame_ is NULL before we do output callbacks
+        // that might cause us to look at it
+        scoped_refptr<VideoFrame> frame(sliced_frame_.get());
+        sliced_frame_ = NULL;
+
+        emit_copied_frame(frame);
+        break;
+      }
+    }
+
+    fps.inc_frames();
+    if (debug_bench_ && fps.period_expired(1000000))
+    {
+      LOG(ERROR) << "--- fps = " << fps.ToString();
+    }
+  }
+
+
+public:
+  MmalVideoARGBPort(MmalComponent * const component) :
+    MmalPortAndPool(component),
+    eos_sent_(false),
+    red_pixel_(false),
+    zc_buffers_in_flight_(0),
+    last_pts_(kNoTimestamp()),
+    debug_bench_(false),
+    resize_disabled_(false)
+  {
+  }
+
+  ~MmalVideoARGBPort() override
+  {
+    kill_trampoline();
+  }
+
+  int create_frame_pool()
+  {
+    return set_pool(new MmalFramePool());
+  }
+
+  void set_port(MMAL_PORT_T * const port) override
+  {
+    MmalPort::set_port(port);
+
+    port_->format->type = MMAL_ES_TYPE_VIDEO;
+  }
+
+  void set_copy_mode(const FrameCopyMode copy_mode)
+  {
+    copy_mode_ = copy_mode;
+
+    if (copy_mode_ == FrameCopyMode::SLICE) {
+      port_->format->encoding = MMAL_ENCODING_BGRA_SLICE;
+      port_->format->encoding_variant = MMAL_ENCODING_BGRA_SLICE;
+    }
+    else
+    {
+      port_->format->encoding = MMAL_ENCODING_BGRA;
+      port_->format->encoding_variant = MMAL_ENCODING_BGRA;
+    }
+  }
+
+  int set_size(const gfx::Size& req_size)
+  {
+    set_video_format(req_size, gfx::Size(), ColorSpace::COLOR_SPACE_JPEG);
+    return 0;
+  }
+
+  void set_eos_cb(const VideoDecoder::DecodeCB& eos_cb)
+  {
+    eos_cb_ = eos_cb;
+  }
+
+  int set_debug_bench(const bool enable)
+  {
+    debug_bench_ = enable;
+    return 0;
+  }
+
+  int set_resize_disabled(const bool disable)
+  {
+    resize_disabled_ = disable;
+    return 0;
+  }
+
+  void set_red_pixel(const bool red)
+  {
+    red_pixel_ = red;
+  }
+
+  bool eos_sent() const
+  {
+    return eos_sent_ && eos_cb_.is_null();
+  }
+
+public:
+  int enable() override
+  {
+    if (copy_mode_ != FrameCopyMode::ZERO)
+    {
+      kill_trampoline();  // Shouldn't be needed but good to make sure
+
+      const int buffers_per_frame = copy_mode_ != FrameCopyMode::SLICE ? 1 :
+          (port_->format->es->video.crop.height + MMAL_SLICE_HEIGHT - 1) / MMAL_SLICE_HEIGHT;
+
+      frame_trampoline_ = new MmalTrampoline(buffers_per_frame * MAX_COPY_FRAMES_IN_FLIGHT,
+          base::Bind(&MmalVideoARGBPort::resize_cb, this),
+          base::Bind(&MmalVideoARGBPort::copied_frame_destruction_cb, this));
+
+      set_trampoline(frame_trampoline_);
+    }
+
+    if (MmalPortAndPool::enable() != 0)
+      return  -1;
+
+    fps.start();
+
+    return stuff();
+  }
+
+  int enable(const VideoDecoder::OutputCB& output_cb)
+  {
+    output_cb_ = output_cb;
+    return enable();
+  }
+
+  int disable() override
+  {
+    int rv = MmalPortAndPool::disable();
+
+    // Worry about class status vars after disable to avoid race conditions
+    kill_trampoline();
+
+    sliced_frame_ = NULL;  // Forget any partial frame info
+
+    if (!eos_cb_.is_null()) {
+      LOG(INFO) << ">>> EOS (abort)";
+      eos_cb_.Run(DecodeStatus::ABORTED);
+      eos_cb_.Reset();
+    }
+    eos_sent_ = false;
+
+//    LOG(ERROR) << "@@@@ disable: fps=" << fps.ToString();
+
+    return rv;
+  }
+
+  bool is_stalling() const
+  {
+    // If trampoline is null for some reason e.g. decoder reset
+    // then assume that in_flight is 0 as it will be when we regenerate the
+    // trampoline
+    return copy_mode_ == FrameCopyMode::ZERO ?
+      base::subtle::NoBarrier_Load(&zc_buffers_in_flight_) >= pool_size() :
+      frame_trampoline_ != nullptr && frame_trampoline_->is_stalling();
+  }
+};
+
+// ---------------------------------------------------------------------------
+
+class MmalComponent : public base::RefCountedThreadSafe<MmalComponent>
+{
+protected:
+  MMAL_COMPONENT_T * component_;
+private:
+  MmalTaskRunner task_runner_;
+
+protected:
+  int create_by_name(const char * const name)
+  {
+    MMAL_STATUS_T err;
+    if ((err = mmal_component_create(name, &component_)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_component_create(" << name << ") failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  friend class base::RefCountedThreadSafe<MmalComponent>;
+  virtual ~MmalComponent()
+  {
+    if (component_ != NULL) {
+      mmal_component_release(component_);
+    }
+  }
+
+  virtual MmalConnectedPort * input_port() = 0;
+  virtual MmalConnectedPort * output_port() = 0;
+
+public:
+  MmalComponent() :
+    component_(NULL),
+    task_runner_(base::ThreadTaskRunnerHandle::Get())
+  {
+  }
+
+  const MmalTaskRunner& task_runner() const
+  {
+    return task_runner_;
+  }
+
+  int connect_to_output(scoped_refptr<MmalComponent> src)
+  {
+    MmalConnectedPort * const dest = input_port();
+    if (dest->connect_to_src(src->output_port()) != 0)
+      return -1;
+    if (dest->enable() != 0) {
+      dest->disconnect();
+      return -1;
+    }
+    return 0;
+  }
+
+  int enable()
+  {
+    MMAL_STATUS_T err;
+
+    if ((err = mmal_component_enable(component_)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_component_enable failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  int disable()
+  {
+    MMAL_STATUS_T err;
+    if ((err = mmal_component_disable(component_)) != MMAL_SUCCESS)
+      LOG(ERROR) << "### mmal_component_disable failed: err=" << err;
+
+    return err == MMAL_SUCCESS ? 0 : -1;
+  }
+
+  // Shut this component down
+  // Reclaim all resources as they return & attempt to zero our internal
+  // ref count so we will die when the decoder derefs us.
+  // The reclaim process may be async so we may die some time later
+  virtual void kill() = 0;
+};
+
+// ---------------------------------------------------------------------------
+
+class MmalVideoDecoderComponent : public MmalComponent
+{
+  MmalVideoESPort port_in_;
+  MmalConnectedPort port_out_;
+  MmalPort port_ctrl_;
+
+protected:
+  ~MmalVideoDecoderComponent() override
+  {
+#if TRACE_COMPONENT_CREATION
+    LOG(INFO) << "@@@ ~MmalVideoDecoderComponent";
+#endif
+  }
+
+  MmalConnectedPort * input_port() override
+  {
+    return NULL;
+  }
+
+  MmalConnectedPort * output_port() override
+  {
+    return &port_out_;
+  }
+
+
+public:
+  MmalVideoDecoderComponent() :
+    port_in_(this)
+  {
+#if TRACE_COMPONENT_CREATION
+    LOG(INFO) << "@@@ MmalVideoDecoderComponent";
+#endif
+  }
+
+  int create(const MmalVideoDecoder::Options& opt, const VideoDecoderConfig& config, const bool low_delay)
+  {
+    if (create_by_name(MMAL_COMPONENT_DEFAULT_VIDEO_DECODER) != 0) {
+      return -1;
+    }
+
+    // Attach control structures to ports
+    port_in_.set_port(component_->input[0]);
+    port_out_.set_port(component_->output[0]);
+    port_ctrl_.set_port(component_->control);
+
+    if (
+        port_ctrl_.enable() != 0 ||
+
+        port_in_.set_parameter(MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS, low_delay ? -5 : 120) != 0 ||
+//        port_in_.set_parameter(MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS, -3) != 0 ||
+        port_in_.config(config, low_delay) != 0 ||
+        port_in_.commit() != 0 ||
+
+//        port_out_.set_parameter(MMAL_PARAMETER_EXTRA_BUFFERS, 6) != 0 ||
+        port_out_.set_parameter(MMAL_PARAMETER_VIDEO_INTERPOLATE_TIMESTAMPS, false) != 0 ||
+        port_out_.set_video_encoding(opt.decoder_out_encoding()) != 0 ||
+        port_out_.set_video_format(config.coded_size(),
+            par_from_sizes(config.coded_size(), config.natural_size()),
+            config.color_space()) != 0 ||
+        port_out_.commit() != 0 ||
+
+        port_in_.set_buffers(0x10000, 8) != 0 ||
+        port_in_.set_parameter(MMAL_PARAMETER_ZERO_COPY, false) != 0 ||  // ### Z-Copy is bust here
+        port_in_.create_port_pool() != 0 ||
+
+        port_in_.enable() != 0)
+    {
+      goto fail;
+    }
+    return 0;
+
+fail:
+    return -1;
+  }
+
+  void kill() override
+  {
+    port_in_.kill();
+    port_out_.kill();
+  }
+
+  void reset1()
+  {
+    port_in_.disable();
+    port_out_.disable();
+  }
+
+  void reset2()
+  {
+    port_out_.enable();
+    port_in_.enable();
+  }
+
+
+  int submit(const scoped_refptr<DecoderBuffer>& buffer, const VideoDecoder::DecodeCB& decode_cb)
+  {
+    return port_in_.submit(buffer, decode_cb);
+  }
+};
+
+// ---------------------------------------------------------------------------
+
+class MmalVideoResizerComponent : public MmalComponent
+{
+  FrameCopyMode copy_mode_;
+  gfx::Size cur_size_;
+  MmalConnectedPort port_in_;
+  MmalVideoARGBPort port_out_;
+  MmalPort port_ctrl_;
+
+protected:
+  ~MmalVideoResizerComponent() override
+  {
+#if TRACE_COMPONENT_CREATION
+    LOG(INFO) << "@@@ ~MmalVideoResizerComponent";
+#endif
+  }
+
+  MmalConnectedPort * input_port() override
+  {
+    return &port_in_;
+  }
+
+  MmalConnectedPort * output_port() override
+  {
+    return NULL;
+  }
+
+
+public:
+  MmalVideoResizerComponent() :
+    copy_mode_(FrameCopyMode::unset),
+    port_out_(this)
+  {
+#if TRACE_COMPONENT_CREATION
+    LOG(INFO) << "@@@ MmalVideoResizerComponent";
+#endif
+  }
+
+  int create(const MmalVideoDecoder::Options& opt)
+  {
+    if (create_by_name(opt.resizer_component_name()) != 0) {
+      return -1;
+    }
+
+    // Attach control structures to ports
+    port_in_.set_port(component_->input[0]);
+    port_out_.set_port(component_->output[0]);
+    port_ctrl_.set_port(component_->control);
+    return 0;
+  }
+
+  bool is_copy_mode_supported(const FrameCopyMode mode) const
+  {
+    return port_out_.get_parameter_supported_encodings().is_supported(mode == FrameCopyMode::SLICE ? MMAL_ENCODING_BGRA_SLICE : MMAL_ENCODING_BGRA);
+  }
+
+  int configure(const MmalVideoDecoder::Options& opt,
+      const gfx::Size& size, const VideoDecoder::OutputCB& output_cb)
+  {
+    copy_mode_ = opt.frame_copy_mode(is_copy_mode_supported(FrameCopyMode::SLICE));
+
+    port_out_.set_copy_mode(copy_mode_);
+
+    if (port_ctrl_.enable() != 0 ||
+        port_out_.set_size(opt.debug_fixed_size_set() ? opt.debug_fixed_size() : size) != 0 ||
+        port_out_.set_resize_disabled(opt.debug_fixed_size_set()) != 0 ||
+        port_out_.set_debug_bench(opt.debug_bench()) != 0 ||
+        port_out_.commit() != 0)
+    {
+      goto fail;
+    }
+
+    switch (copy_mode_) {
+      case FrameCopyMode::SLICE:
+        if (port_out_.set_buffers(MMAL_SLICE_HEIGHT * MMAL_LIMIT_WIDTH * 4, opt.frame_buffers(copy_mode_)) != 0 ||
+          port_out_.set_parameter(MMAL_PARAMETER_ZERO_COPY, true) != 0 ||
+          port_out_.create_port_pool() != 0)
+        {
+          goto fail;
+        }
+        break;
+
+      case FrameCopyMode::FRAME:
+        // Firmware-side frame copy
+#if OPT_FRAME_COPY_STASHED
+        if (port_out_.set_buffers(port_out_.buffer_size_recommended(), opt.frame_buffers(copy_mode_)) != 0 ||
+          port_out_.set_parameter(MMAL_PARAMETER_ZERO_COPY, false) != 0 ||
+          port_out_.create_frame_pool() != 0)
+#else
+        if (port_out_.set_buffers(port_out_.buffer_size_recommended(), opt.frame_buffers(copy_mode_)) != 0 ||
+          port_out_.set_parameter(MMAL_PARAMETER_ZERO_COPY, true) != 0 ||
+          port_out_.create_port_pool() != 0)
+#endif
+        {
+          goto fail;
+        }
+        break;
+
+      case FrameCopyMode::ZERO:
+        if (port_out_.set_buffers(MMAL_LIMIT_HEIGHT * MMAL_LIMIT_WIDTH * 4, opt.frame_buffers(copy_mode_)) != 0 ||
+          port_out_.set_parameter(MMAL_PARAMETER_ZERO_COPY, true) != 0 ||
+          port_out_.create_port_pool() != 0)
+        {
+          goto fail;
+        }
+        break;
+
+      default:
+        goto fail;
+    }
+
+    if (port_out_.enable(output_cb) != 0)
+      goto fail;
+
+    cur_size_ = size;
+    return 0;
+
+fail:
+    return -1;
+  }
+
+  void kill() override
+  {
+    port_in_.kill();
+    port_out_.kill();
+  }
+
+  void reset1()
+  {
+    port_in_.disable();
+    port_out_.disable();
+  }
+
+  void reset2()
+  {
+    port_out_.enable();
+    port_in_.enable();
+  }
+
+  void set_eos_cb(const VideoDecoder::DecodeCB& eos_cb)
+  {
+    port_out_.set_eos_cb(eos_cb);
+  }
+
+  void set_red_pixel(const bool red)
+  {
+    port_out_.set_red_pixel(red);
+  }
+
+  bool is_output_stalling() const
+  {
+    return port_out_.is_stalling();
+  }
+};
+
+
+// ---------------------------------------------------------------------------
+
+void MmalConnection::disconnect()
+{
+  if (src_ == NULL || dest_ == NULL) {
+    LOG(ERROR) << "#### src or dest NULL";
+    return;
+  }
+
+  disable();
+
+  // Commit suicide by killing our refs
+  // Both ends should still exist as the destruction of either
+  // should call this fn
+  src_->set_connection(NULL);
+  dest_->set_connection(NULL);
+}
+
+int MmalConnection::connect(MmalConnectedPort * const src, MmalConnectedPort * const dest)
+{
+  MMAL_STATUS_T err;
+
+  // MMAL_CONNECTION_FLAG_KEEP_BUFFER_REQUIREMENTS means
+  // that enable will actually observe the buffer_num
+  // and size fields - otherwise it will always ignore
+  // them
+  if ((err = mmal_connection_create(&connection_, src->port_, dest->port_,
+      MMAL_CONNECTION_FLAG_KEEP_BUFFER_REQUIREMENTS | MMAL_CONNECTION_FLAG_TUNNELLING)) != MMAL_SUCCESS) {
+    LOG(ERROR) << "### mmal_connection_create failed: err=" << err;
+    connection_ = NULL;  // Just in case
+    return -1;
+  }
+
+  src->set_connection(this);
+  dest->set_connection(this);
+
+  src_ = src;
+  dest_ = dest;
+
+  // As we have asked for our choices to be respected we should make sure they
+  // are set to something sensible
+  set_buffers(buffer_size_recommended(), buffer_num_recommended());
+
+  mmal_log_dump_port(src->port_);
+  mmal_log_dump_port(dest->port_);
+  return 0;
+}
+
+uint32_t MmalConnection::buffer_size_recommended() const
+{
+  return std::max(src_->MmalPort::buffer_size_recommended(), dest_->MmalPort::buffer_size_recommended());
+}
+
+uint32_t MmalConnection::buffer_num_recommended() const
+{
+  return std::max(src_->MmalPort::buffer_num_recommended(), dest_->MmalPort::buffer_num_recommended());
+}
+
+uint32_t MmalConnection::buffer_size_min() const
+{
+  return std::max(src_->MmalPort::buffer_size_min(), dest_->MmalPort::buffer_size_min());
+}
+
+uint32_t MmalConnection::buffer_num_min() const
+{
+  return std::max(src_->MmalPort::buffer_num_min(), dest_->MmalPort::buffer_num_min());
+}
+
+int MmalConnection::set_buffers(uint32_t s, uint32_t n)
+{
+  src_->MmalPort::set_buffers(s, n);
+  dest_->MmalPort::set_buffers(s, n);
+  return 0;
+}
+
+
+// ---------------------------------------------------------------------------
+
+// Any refs required are applied to our enclosing object
+void MmalPortAndPool::AddRef() const
+{
+  component_->AddRef();
+}
+
+// Any refs required are applied to our enclosing object
+void MmalPortAndPool::Release()
+{
+  component_->Release();
+}
+
+const MmalTaskRunner& MmalPortAndPool::task_runner() const
+{
+  return component_->task_runner();
+}
+
+// ---------------------------------------------------------------------------
+
+// static
+bool MmalVideoDecoder::IsCodecSupported(VideoCodec codec) {
+//  LOG(ERROR) << "Test codec: " << codec;
+  return
+    codec == kCodecH264 ||
+    codec == kCodecVC1 ||
+    codec == kCodecMPEG2 ||
+    codec == kCodecMPEG4;
+}
+
+bool MmalVideoDecoder::IsSizeSupported(const gfx::Size& size)
+{
+  return size.width() <= MMAL_LIMIT_WIDTH &&
+    size.height() <= MMAL_LIMIT_HEIGHT &&
+    size.width() >= 32 &&
+    size.height() >= 32;
+}
+
+MmalVideoDecoder::MmalVideoDecoder() :
+  state_(MmalDecoderState::kNew),
+  counted_(false),
+  wants_extra_data_(false),
+  opt_(Options::Create()),
+  weak_factory_(this)
+{
+#if TRACE_COMPONENT_CREATION
+  LOG(INFO) << "@@@ Create Decoder pid=" << getpid() << ", ppid=" << getppid() << ", vchiq_fd=" << vchiq_init_done;
+#endif
+
+  LOG(INFO) << opt_->ToString();
+
+  if (opt_->single_process()) {
+    LOG(INFO) << "Single Process";
+
+    MMAL_STATUS_T err = mmal_vc_init();
+
+    if (err != MMAL_SUCCESS) {
+      LOG(ERROR) << "### mmal_vc_init failed: err=" << err;
+      goto fail;
+    }
+
+    vchiq_init_done = true;
+  }
+  else if (!vchiq_init_done) {
+
+    base::Pickle request;
+    request.WriteInt(content::LinuxSandbox::METHOD_OPEN_DEV_VCHIQ);
+    int vfd = -1;
+
+    uint8_t reply_buf[512];
+    const ssize_t reply_len = base::UnixDomainSocket::SendRecvMsg(
+        content::GetSandboxFD(), reply_buf, sizeof(reply_buf), &vfd, request);
+
+    if (reply_len == -1 || vfd == -1) {
+      LOG(ERROR) << "### Failed to open /dev/vchiq";
+      goto fail;
+    }
+
+    {
+      base::Pickle reply(reinterpret_cast<char*>(reply_buf), reply_len);
+      base::PickleIterator pickle_iter(reply);
+      unsigned int firmware_date;
+      if (!pickle_iter.ReadUInt32(&firmware_date))
+      {
+        LOG(ERROR) << "### Failed to get firmware date";
+      }
+
+      LOG(INFO) << "Firmware date: " << strgmtimet(firmware_date);
+    }
+
+
+    MMAL_STATUS_T err = mmal_vc_init_fd(vfd);
+
+    // The passed fd is at a minimum duped so close now
+    // we want to close on error too
+    IGNORE_EINTR(close(vfd));
+
+    if (err != MMAL_SUCCESS) {
+      LOG(ERROR) << "### mmal_vc_init_fd failed: fd=" << vfd << ", err=" << err;
+      goto fail;
+    }
+
+    vchiq_init_done = true;
+  }
+
+  state_ = MmalDecoderState::kUninitialised;
+  return;
+
+fail:
+  // We are never going to be happy - do not try
+  state_ = MmalDecoderState::kFatal;
+}
+
+MmalVideoDecoder::~MmalVideoDecoder() {
+#if TRACE_COMPONENT_CREATION
+  LOG(INFO) << "@@@ Destroy Decoder";
+#endif
+
+  uninitialise();
+
+  if (counted_) {
+    base::subtle::NoBarrier_AtomicIncrement(& decoder_count, -1);
+  }
+}
+
+
+
+std::string MmalVideoDecoder::GetDisplayName() const {
+  return "MmalVideoDecoder";
+}
+
+
+void MmalVideoDecoder::uninitialise()
+{
+  if (decoder_ != NULL) {
+    decoder_->kill();
+    decoder_ = NULL;
+  }
+  if (resizer_ != NULL) {
+    resizer_->kill();
+    resizer_ = NULL;
+  }
+
+  extra_data_ = NULL;
+  wants_extra_data_ = false;
+
+  state_ = kUninitialised;
+}
+
+// EOS callback - accessed via WeakPtr so if we are destroyed
+// whilst EOS is still pending this won't happen
+//
+// We call Reset on EOS.  This has a couple of benefits
+// 1) It reclaims memory as soon as possible (there's a decent chance we
+//    are done with this decoder now)
+// 2) It should allow us to go <decode> <eos> <decode> which is defined to
+//    work in the Decode spec (even if it doesn't seem to happen in reality)
+
+void MmalVideoDecoder::eos_cb(const DecodeCB decode_cb, DecodeStatus status)
+{
+//  LOG(ERROR) << "+++ EOS(" << status << ")";
+  Reset(base::Bind(decode_cb, status));
+}
+
+// Initializes a VideoDecoder with the given |config|, executing the
+// |init_cb| upon completion. |output_cb| is called for each output frame
+// decoded by Decode().
+//
+// If |low_delay| is true then the decoder is not allowed to queue frames,
+// except for out-of-order frames, i.e. if the next frame can be returned it
+// must be returned without waiting for Decode() to be called again.
+// Initialization should fail if |low_delay| is true and the decoder cannot
+// satisfy the requirements above.
+//
+// |cdm_context| can be used to handle encrypted buffers. May be null if the
+// stream is not encrypted.
+//
+// Note:
+// 1) The VideoDecoder will be reinitialized if it was initialized before.
+//    Upon reinitialization, all internal buffered frames will be dropped.
+// 2) This method should not be called during pending decode or reset.
+// 3) No VideoDecoder calls should be made before |init_cb| is executed.
+// 4) VideoDecoders should take care to run |output_cb| as soon as the frame
+// is ready (i.e. w/o thread trampolining) since it can strongly affect frame
+// delivery times with high-frame-rate material.  See Decode() for additional
+// notes.
+
+void MmalVideoDecoder::Initialize(const VideoDecoderConfig& config,
+                                    bool low_delay,
+                                    CdmContext* /* cdm_context */,
+                                    const InitCB& init_cb,
+                                    const OutputCB& output_cb) {
+  LOG(INFO) << "Mmal Init: low_delay=" << low_delay << ", config=" << config.AsHumanReadableString();
+
+  DCHECK(config.IsValidConfig());
+  DCHECK(!output_cb.is_null());
+
+  InitCB bound_init_cb = BindToCurrentLoop(init_cb);
+
+  // If dead - give up now
+  if (state_ <= MmalDecoderState::kFatal) {
+    LOG(ERROR) << __func__ << ": FATAL";
+    bound_init_cb.Run(false);
+    return;
+  }
+  
+  // If already inited (or failed) then kill
+  if (state_ != kUninitialised) {
+    // * This is unsubtle in the extreme
+    // and we would really prefer to wait for the kill ops to finish
+    // before continuing so we don't have an overlap where we have
+    // two sets of resizer buffers ... or preserve the resizer...
+    // or something...
+    uninitialise();
+  }
+
+  if (state_ != kUninitialised) {
+    LOG(ERROR) << __func__ << ": Unexpected state: " << state_;
+    goto fail;
+  }
+
+  // Do we support this?
+  if (config.is_encrypted() || !IsCodecSupported(config.codec()) ||
+      !IsSizeSupported(config.coded_size())) {
+//    LOG(ERROR) << "Encrypted or unsupported";
+    // No
+    goto fail;
+  }
+
+  // Check count
+  // 0 will effectively turn off mmal decode
+  if (!counted_ && base::subtle::NoBarrier_AtomicIncrement(&decoder_count, 1) > (int)opt_->max_decoders()) {
+    base::subtle::NoBarrier_AtomicIncrement(&decoder_count, -1);
+    LOG(WARNING) << __func__ << ": Exceeded decoder limit";
+    goto fail;
+  }
+  counted_ = true;
+
+  LOG(INFO) << "Decoder count:" << decoder_count << "/" << opt_->max_decoders();
+
+  // Stash for later reset
+  decoder_config_ = config;
+  low_delay_ = opt_->low_delay(low_delay);
+
+  if (config.extra_data().size() != 0)
+  {
+    extra_data_ = DecoderBuffer::CopyFrom(&config.extra_data()[0], config.extra_data().size());
+    wants_extra_data_ = true;
+  }
+
+  decoder_ = new MmalVideoDecoderComponent();
+  if (decoder_->create(*opt_, config, low_delay_) != 0)
+    goto fail;
+  if (decoder_->enable() != 0)
+    goto fail;
+
+  resizer_ = new MmalVideoResizerComponent();
+
+  if (resizer_->create(*opt_) != 0)
+    goto fail;
+
+  if (resizer_->configure(*opt_,
+      config.natural_size(),
+      BindToCurrentLoop(output_cb)) != 0)
+    goto fail;
+
+  resizer_->set_red_pixel(opt_->red_pixel());
+  if (resizer_->enable() != 0)
+    goto fail;
+
+  if (resizer_->connect_to_output(decoder_) != 0)
+    goto fail;
+
+  state_ = MmalDecoderState::kInitialised;
+
+  // Success!
+  bound_init_cb.Run(true);
+  return;
+
+
+fail:
+  LOG(INFO) << __func__ << ": FAILED";
+  state_ = std::min(state_, MmalDecoderState::kFail);
+  bound_init_cb.Run(false);
+}
+
+// Requests a |buffer| to be decoded. The status of the decoder and decoded
+// frame are returned via the provided callback. Some decoders may allow
+// decoding multiple buffers in parallel. Callers should call
+// GetMaxDecodeRequests() to get number of buffers that may be decoded in
+// parallel. Decoder must call |decode_cb| in the same order in which Decode()
+// is called.
+//
+// Implementations guarantee that the callback will not be called from within
+// this method and that |decode_cb| will not be blocked on the following
+// Decode() calls (i.e. |decode_cb| will be called even if Decode() is never
+// called again).
+//
+// After decoding is finished the decoder calls |output_cb| specified in
+// Initialize() for each decoded frame. |output_cb| is always called before
+// |decode_cb|. However, |output_cb| may be called before Decode() returns, if
+// other behavior is desired callers should ensure that |output_cb| will
+// trampoline as necessary.
+// * We will violate this ordering, but it doesn't seem to matter
+//
+// If |buffer| is an EOS buffer then the decoder must be flushed, i.e.
+// |output_cb| must be called for each frame pending in the queue and
+// |decode_cb| must be called after that. Callers will not call Decode()
+// again until after the flush completes.
+void MmalVideoDecoder::Decode(const scoped_refptr<DecoderBuffer>& buffer,
+                                const DecodeCB& decode_cb) {
+  DCHECK(buffer.get());
+  DCHECK(!decode_cb.is_null());
+
+  CHECK(decoder_ == nullptr || decoder_->task_runner()->BelongsToCurrentThread());
+
+  const bool eos_req = buffer->end_of_stream();
+
+//  LOG(ERROR) << "<<< Decode: state=" << state_ << ", buffer=" << buffer->AsHumanReadableString();
+  DecodeCB decode_cb_bound(BindToCurrentLoop(decode_cb));
+
+  // If we are in any state except running (reset, never sent data, eos)
+  // then EOS won't propagate and we should ack here & now
+  if (eos_req && state_ != MmalDecoderState::kRunning) {
+    LOG(INFO) << "<<< >>> EOS";
+    decode_cb_bound.Run(DecodeStatus::OK);
+    return;
+  }
+
+  if (state_ == MmalDecoderState::kResetEOS) {
+    // * Really we should be able to do half this work
+    //   and drop into ResetRun but the enables don't currently work
+    //   correctly for that
+
+    decoder_ = new MmalVideoDecoderComponent();
+    if (decoder_->create(*opt_, decoder_config_, low_delay_) != 0)
+      goto fail;
+    if (decoder_->enable() != 0)
+      goto fail;
+
+    if (resizer_->connect_to_output(decoder_) != 0)
+      goto fail;
+
+    resizer_->reset2();
+
+    wants_extra_data_ = (extra_data_ != NULL);
+
+    state_ = MmalDecoderState::kInitialised;
+  }
+  else if (state_ == MmalDecoderState::kResetRun) {
+    resizer_->reset2();
+    decoder_->reset2();
+    wants_extra_data_ = (extra_data_ != NULL);
+    state_ = MmalDecoderState::kInitialised;
+  }
+
+  if (state_ < MmalDecoderState::kInitialised)
+  {
+    LOG(ERROR) << "### Decode in bad state: " << state_;
+    goto fail;
+  }
+
+  if (wants_extra_data_) {
+    if (extra_data_ == NULL) {
+      LOG(ERROR) << "### extra_data_ NULL";
+      goto fail;
+    }
+
+    wants_extra_data_ = false;
+    if (decoder_->submit(extra_data_, DecodeCB()) < 0)
+      goto fail;
+  }
+
+  if (eos_req) {
+    // eos_cb must be called on the current thread
+    resizer_->set_eos_cb(BindToCurrentLoop(
+        base::Bind(&MmalVideoDecoder::eos_cb, weak_factory_.GetWeakPtr(), decode_cb)));
+
+    // The decode_cb we pass here isn't ever used - it just indicates that
+    // we want Qed submission.  * Mucky.
+    if (decoder_->submit(buffer, decode_cb_bound) < 0)
+      goto fail;
+
+    state_ = MmalDecoderState::kEOS;
+  }
+  else
+  {
+    if (decoder_->submit(buffer, decode_cb_bound) < 0)
+      goto fail;
+
+    state_ = MmalDecoderState::kRunning;
+  }
+
+//  LOG(ERROR) << ">>> Decode";
+  return;
+
+fail:
+  LOG(WARNING) << ">>> Decode: FAIL";
+  decode_cb_bound.Run(DecodeStatus::DECODE_ERROR);
+}
+
+// Resets decoder state. All pending Decode() requests will be finished or
+// aborted before |closure| is called.
+// Note: No VideoDecoder calls should be made before |closure| is executed.
+//
+// This fn shuts stuff down - restart is managed at the beginning of Decode
+
+void MmalVideoDecoder::Reset(const base::Closure& closure) {
+	switch (state_) {
+    case MmalDecoderState::kRunning:
+      LOG(INFO) << "--- Reset (running)";
+      decoder_->reset1();
+      resizer_->reset1();
+      state_ = MmalDecoderState::kResetRun;
+      break;
+
+    case MmalDecoderState::kEOS:
+      LOG(INFO) << "--- Reset (EOS)";
+      decoder_->kill();
+      decoder_ = NULL;
+      resizer_->reset1();
+      state_ = MmalDecoderState::kResetEOS;
+      break;
+
+    default:
+      LOG(INFO) << "--- Reset (null)";
+      break;
+  }
+
+  // Ensure the closure is scheduled after any callbacks triggered by
+  // the reset sequence
+  base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE, closure);
+  return;
+}
+
+bool MmalVideoDecoder::CanReadWithoutStalling() const
+{
+  return resizer_ == nullptr || !resizer_->is_output_stalling();
+}
+
+}  // namespace media
+
diff --git a/src/media/filters/mmal_video_decoder.h b/src/media/filters/mmal_video_decoder.h
new file mode 100644
index 0000000..bf398ed
--- /dev/null
+++ b/src/media/filters/mmal_video_decoder.h
@@ -0,0 +1,100 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef MEDIA_FILTERS_MMAL_VIDEO_DECODER_H_
+#define MEDIA_FILTERS_MMAL_VIDEO_DECODER_H_
+
+#include <list>
+
+#include "base/callback.h"
+#include "base/macros.h"
+#include "base/memory/scoped_ptr.h"
+#include "base/threading/thread_checker.h"
+#include "media/base/video_decoder.h"
+#include "media/base/video_decoder_config.h"
+#include "media/base/video_frame_pool.h"
+#include "base/command_line.h"
+#include "base/strings/string_number_conversions.h"
+
+struct AVCodecContext;
+struct AVFrame;
+
+namespace base {
+class SingleThreadTaskRunner;
+}
+
+namespace media {
+
+class DecoderBuffer;
+class MmalVideoDecoderComponent;
+class MmalVideoResizerComponent;
+
+class MEDIA_EXPORT MmalVideoDecoder : public VideoDecoder {
+public:
+  class Options;
+
+private:
+  enum MmalDecoderState {
+      kFatal = -2,
+      kFail = -1,
+      kNew = 0,
+      kUninitialised,
+      kReseting,
+      kResetEOS,     // Reset from EOS
+      kResetRun,     // Reset from running
+      kInitialised,  // Init but no decode yet
+      kRunning,      // Have successful decode
+      kEOS           // EOS rxed
+  };
+
+  MmalDecoderState state_;
+
+  // Have we counted this decoder (for decoder count limits) yet?
+  bool counted_;
+
+  scoped_refptr<DecoderBuffer> extra_data_;
+  bool wants_extra_data_;
+
+  scoped_refptr<MmalVideoDecoderComponent> decoder_;
+  // Resizer may persist after VideoDecoder dies if it maintains frames
+  // with shared VC memory
+  scoped_refptr<MmalVideoResizerComponent> resizer_;
+
+  VideoDecoderConfig decoder_config_;
+  bool low_delay_;
+
+  const scoped_ptr<Options> opt_;
+
+  void uninitialise();
+  void eos_cb(const DecodeCB decode_cb, DecodeStatus status);
+
+ public:
+  static bool IsCodecSupported(VideoCodec codec);
+  static bool IsSizeSupported(const gfx::Size& size);
+
+  MmalVideoDecoder();
+  ~MmalVideoDecoder() override;
+
+  // VideoDecoder implementation.
+  std::string GetDisplayName() const override;
+
+  void Initialize(const VideoDecoderConfig& config,
+                  bool low_delay,
+                  CdmContext* cdm_context,
+                  const InitCB& init_cb,
+                  const OutputCB& output_cb) override;
+  void Decode(const scoped_refptr<DecoderBuffer>& buffer,
+              const DecodeCB& decode_cb) override;
+  void Reset(const base::Closure& closure) override;
+  bool CanReadWithoutStalling() const override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(MmalVideoDecoder);
+  base::WeakPtrFactory<MmalVideoDecoder> weak_factory_;
+};
+
+}  // namespace media
+
+#endif  // MEDIA_FILTERS_MMAL_VIDEO_DECODER_H_
+
diff --git a/src/media/filters/video_cadence_estimator.cc b/src/media/filters/video_cadence_estimator.cc
index ac2beb1..ae0c539 100644
--- a/src/media/filters/video_cadence_estimator.cc
+++ b/src/media/filters/video_cadence_estimator.cc
@@ -29,10 +29,12 @@ const double kConstantFPSFactor = 0.45;
 
 // Records the number of cadence changes to UMA.
 static void HistogramCadenceChangeCount(int cadence_changes) {
+#if 0
   const int kCadenceChangeMax = 10;
   UMA_HISTOGRAM_CUSTOM_COUNTS("Media.VideoRenderer.CadenceChanges",
                               cadence_changes, 0, kCadenceChangeMax,
                               kCadenceChangeMax);
+#endif
 }
 
 // Construct a Cadence vector, a vector of integers satisfying the following
diff --git a/src/media/media.gyp b/src/media/media.gyp
index 9752856..f88fc97 100644
--- a/src/media/media.gyp
+++ b/src/media/media.gyp
@@ -96,6 +96,9 @@
       ],
       'include_dirs': [
         '..',
+                '<(sysroot)/opt/vc/include',
+                '<(sysroot)/opt/vc/include/interface/vcos/pthreads',
+                '<(sysroot)/opt/vc/include/interface/vmcs_host/linux',
       ],
       'includes': [
         'capture.gypi',
@@ -541,6 +544,8 @@
         'filters/media_source_state.h',
         'filters/memory_data_source.cc',
         'filters/memory_data_source.h',
+        'filters/mmal_video_decoder.cc',
+        'filters/mmal_video_decoder.h',
         'filters/opus_audio_decoder.cc',
         'filters/opus_audio_decoder.h',
         'filters/opus_constants.cc',
@@ -667,6 +672,8 @@
             'filters/ffmpeg_video_decoder.h',
             'filters/in_memory_url_protocol.cc',
             'filters/in_memory_url_protocol.h',
+            'filters/mmal_video_decoder.cc',
+            'filters/mmal_video_decoder.h',
           ],
           'defines': [
             'MEDIA_DISABLE_FFMPEG',
@@ -715,6 +722,8 @@
             'filters/decrypting_video_decoder.h',
             'filters/ffmpeg_video_decoder.cc',
             'filters/ffmpeg_video_decoder.h',
+            'filters/mmal_video_decoder.cc',
+            'filters/mmal_video_decoder.h',
           ],
           'sources': [
             'filters/android/media_codec_audio_decoder.cc',
diff --git a/src/media/renderers/default_renderer_factory.cc b/src/media/renderers/default_renderer_factory.cc
index e09f90e..ed6e4a5 100644
--- a/src/media/renderers/default_renderer_factory.cc
+++ b/src/media/renderers/default_renderer_factory.cc
@@ -29,6 +29,8 @@
 #include "media/filters/vpx_video_decoder.h"
 #endif
 
+#include "media/filters/mmal_video_decoder.h"
+
 namespace media {
 
 DefaultRendererFactory::DefaultRendererFactory(
@@ -86,6 +88,8 @@ ScopedVector<VideoDecoder> DefaultRendererFactory::CreateVideoDecoders(
     video_decoders.push_back(
         new GpuVideoDecoder(gpu_factories, request_surface_cb));
 
+  video_decoders.push_back(new MmalVideoDecoder());
+
 #if !defined(MEDIA_DISABLE_LIBVPX)
   video_decoders.push_back(new VpxVideoDecoder());
 #endif
@@ -94,6 +98,7 @@ ScopedVector<VideoDecoder> DefaultRendererFactory::CreateVideoDecoders(
   video_decoders.push_back(new FFmpegVideoDecoder());
 #endif
 
+
   return video_decoders;
 }
 
diff --git a/src/media/renderers/skcanvas_video_renderer.cc b/src/media/renderers/skcanvas_video_renderer.cc
index 0f51d55..ac555a8 100644
--- a/src/media/renderers/skcanvas_video_renderer.cc
+++ b/src/media/renderers/skcanvas_video_renderer.cc
@@ -83,6 +83,7 @@ class SyncTokenClientImpl : public VideoFrame::SyncTokenClient {
   DISALLOW_IMPLICIT_CONSTRUCTORS(SyncTokenClientImpl);
 };
 
+
 skia::RefPtr<SkImage> NewSkImageFromVideoFrameYUVTextures(
     const VideoFrame* video_frame,
     const Context3D& context_3d) {
@@ -208,13 +209,26 @@ class VideoImageGenerator : public SkImageGenerator {
  public:
   VideoImageGenerator(const scoped_refptr<VideoFrame>& frame)
       : SkImageGenerator(
-            SkImageInfo::MakeN32Premul(frame->visible_rect().width(),
-                                       frame->visible_rect().height())),
+            SkImageInfo::MakeN32(frame->visible_rect().width(),
+                                       frame->visible_rect().height(), kOpaque_SkAlphaType)),  // *** Was Premul
         frame_(frame) {
     DCHECK(!frame_->HasTextures());
   }
   ~VideoImageGenerator() override {}
 
+  bool installBitmapPixels(SkBitmap * const bitmap) override
+  {
+    const SkImageInfo& info = getInfo();
+    // ??? Also check size
+    if (frame_->format() != PIXEL_FORMAT_MMAL_BUFFER) {
+      return false;
+    }
+
+    bitmap->installPixels(info, frame_->data(0), frame_->stride(0));
+
+    return true;
+  }
+
  protected:
   bool onGetPixels(const SkImageInfo& info,
                    void* pixels,
@@ -326,6 +340,7 @@ SkCanvasVideoRenderer::~SkCanvasVideoRenderer() {
   ResetCache();
 }
 
+
 void SkCanvasVideoRenderer::Paint(const scoped_refptr<VideoFrame>& video_frame,
                                   SkCanvas* canvas,
                                   const gfx::RectF& dest_rect,
@@ -347,8 +362,9 @@ void SkCanvasVideoRenderer::Paint(const scoped_refptr<VideoFrame>& video_frame,
   // Paint black rectangle if there isn't a frame available or the
   // frame has an unexpected format.
   if (!video_frame.get() || video_frame->natural_size().IsEmpty() ||
-      !(media::IsYuvPlanar(video_frame->format()) ||
-        video_frame->HasTextures())) {
+    !(media::IsYuvPlanar(video_frame->format()) || video_frame->format() == PIXEL_FORMAT_MMAL_BUFFER ||
+      video_frame->HasTextures()))
+  {
     canvas->drawRect(dest, paint);
     canvas->flush();
     return;
@@ -390,7 +406,9 @@ void SkCanvasVideoRenderer::Paint(const scoped_refptr<VideoFrame>& video_frame,
   const bool need_scaling =
       dest_rect.size() !=
       gfx::SizeF(gfx::SkISizeToSize(last_image_->dimensions()));
+
   const bool need_translation = !dest_rect.origin().IsOrigin();
+
   bool need_transform = need_rotation || need_scaling || need_translation;
   if (need_transform) {
     canvas->save();
@@ -633,6 +651,7 @@ void SkCanvasVideoRenderer::ConvertVideoFrameToRGBPixels(
     case PIXEL_FORMAT_RGB32:
     case PIXEL_FORMAT_MJPEG:
     case PIXEL_FORMAT_MT21:
+    case PIXEL_FORMAT_MMAL_BUFFER:
     case PIXEL_FORMAT_UNKNOWN:
       NOTREACHED();
   }
diff --git a/src/media/video/gpu_memory_buffer_video_frame_pool.cc b/src/media/video/gpu_memory_buffer_video_frame_pool.cc
index 777a1fc..731a456 100644
--- a/src/media/video/gpu_memory_buffer_video_frame_pool.cc
+++ b/src/media/video/gpu_memory_buffer_video_frame_pool.cc
@@ -387,6 +387,7 @@ void GpuMemoryBufferVideoFramePool::PoolImpl::CreateHardwareFrame(
     case PIXEL_FORMAT_YUV420P10:
     case PIXEL_FORMAT_YUV422P10:
     case PIXEL_FORMAT_YUV444P10:
+    case PIXEL_FORMAT_MMAL_BUFFER:
     case PIXEL_FORMAT_UNKNOWN:
       frame_ready_cb.Run(video_frame);
       return;
diff --git a/src/pi-util/BUILD.txt b/src/pi-util/BUILD.txt
new file mode 100644
index 0000000..5f0f0b1
--- /dev/null
+++ b/src/pi-util/BUILD.txt
@@ -0,0 +1,119 @@
+Build notes (cross compile from Ubuntu)
+=======================================
+
+Build from a patch
+------------------
+
+# Pick somewhere to put this
+cd ~
+mkdir chromium
+cd chromium
+git clone https://chromium.googlesource.com/chromium/tools/depot_tools
+# This is needed for more recent versions of gclient as we
+# are currently set up to use ninja
+export GYP_CHROMIUM_NO_ACTION=0
+export PATH=$PATH:`pwd`/depot_tools
+# Get the main tree
+fetch chromium
+cd src
+# Checkout the version you want
+# * Fix version number
+git checkout 51.0.2704.91
+# Fix up any missing dependancies on the build m/c
+# * may well be unnecessary if you have built any other chrome
+./build/install-build-deps.sh
+./build/install-build-deps.sh --arm
+# Fetch & pull the other bits of the tree to sync.
+# As we are checking out a tag the --with_branch_heads is important
+gclient sync --with_branch_heads
+# Patch - should be completely clean if everything matchs
+# * Fix patch file to correct name / location
+cd ..
+patch -p1 < v51.0.2704.91.patch
+cd src
+# * Get a sysroot from somewhere and put it in build/linux/raspian_jessie_pi1
+# * Example below is only if you have got an appropriate one lying around
+# * Otherwise follow sysroot instructions further down
+rsync -rl previous_location/raspian_jessie_pi1-sysroot build/linux/
+# Copy an appropriate gyp_env to where it will be found
+# * Will need editing if you have picked another sysroot name
+cp pi-util/chromium.gyp_env.pi1 ../chromium.gyp_env
+# Build hooks
+gclient runhooks
+# Build chrome
+ninja -C out/Release chrome
+
+
+
+
+Sysroots (one time only)
+------------------------
+
+1st you will need to get the dev files for a bunch of libs on your pi (or
+if you can get the right files by magic on your cross-compile m/c then
+that is good too).  In src/pi-util there is a shell script
+pi-install-dev.sh which lists all the libs I think are needed along with a
+helpful apt-get install so all you should need to do is run it on an
+appropriate pi.
+
+Next the appropriate bits need to be copied to
+build/linux/<sysroot-name>-sysroot. (We use raspian_jessie_pi1 as the
+sysroot name in these instructions and in the example script files so you
+might well find it easiest to use the same name too
+
+The script pi-util/syncroot.sh that will copy the needed bits of a root to
+the right place and then fix the full path symlinks to be relative.  It
+uses rsync to copy the files so the src can contain a machine name
+
+pi-util/syncroot.sh my-pi: raspian_jessie_pi1
+
+Beware that there are ~8 rsync statements so if the rsync is operating
+over ssh then you may need to type your password 8 times...
+
+If the pi root is updated then this script can / should be rerun to update
+the sysroot.
+
+
+gyp_env (one time only)
+-------
+
+Copy an appropriate chromium.gyp_env.??? to buildhost as chromium.gyp_env
+and change its sysroot_name to whatever you chose omitting the final
+"-sysroot", so if you installed your sysroot into
+src/build/linux/raspian_jessie_pi1-sysroot you would want
+sysroot_name=raspian_jessie_pi1
+
+cp pi-util/chromium.gyp_env.pi1 ../chromium.gyp_env
+vi ../chromium.gyp_env
+
+build
+-----
+
+You will want a clean environment (i.e. no CFLAGS etc), but with
+depot_tools in your path.  Anything else will probably confuse the build.
+
+For a clean build which you will need to do if you have moved the tree,
+updated sysroot or changed chromium.gyp_env
+
+rm -rf out
+gclient runhooks
+
+Then the (re)make step is
+
+ninja -C out/Release chrome
+
+the executable (chrome) should turn up out/Release
+
+
+Other notes on the tree
+ -----------------------
+
+The git branches in use are
+
+src:                        test/use_mmal_3
+src/native_client:          test_use_mmal_3
+src/third_party/opus/src:   test/use_mmal_3
+src/third_party/pdfium:     test/use_mmal_3
+src/third_party/ffmpeg:     test/use_mmal_3
+src/third_party/skia:       test/use_mmal_2
+src/third_party/webrtc:     test/use_mmal_3
diff --git a/src/pi-util/README.txt b/src/pi-util/README.txt
new file mode 100644
index 0000000..a0896f01bc
--- /dev/null
+++ b/src/pi-util/README.txt
@@ -0,0 +1,80 @@
+Release notes
+=============
+
+This version should run with gpu-mem=64 with the default switches. Having
+said that this will only allow for 1 stream.  If you are playing >1 stream
+(even transiently) then you will need more (say gpu_mem=128) and you will
+need to set the --mmal-decoders option to the desired max number. The code
+should give up cleanly if it cannot allocate a h/w video decoder and give
+the stream to old-style ffmpeg decode, but as it stands in many cases it
+thinks it has allocated a decoder cleanly only to find that it fails when
+it tries to use it.
+
+Needs firmware from "Sep 13 2016 17:01:56" or later to work properly
+("vcgencmd version" will give the date).
+
+There are a few command-line switches - in general you shouldn't use
+them!
+
+Copy-modes
+----------
+
+These are modes for getting frames out of mmal.  Current default is
+--mmal-slice-copy if we think the firware supports it otherwise
+--mmal-frame-copy. Explicit use of a copy mode option will override the
+default regardless of whether or not we think the firmware supports the
+selected option.  Only use one of of these flags.
+
+--mmal-zero-copy         Pass gpu frames directly to chrome.  Chrome
+buffers some frames and stalls if it doesn't get them. So this option
+needs 6+ gpu frames allocated.  This is the fastest option but you
+probably want to have gpu_mem=192 if you are going to use it.  Default
+frame-buffers = 6 (8M each)
+
+--mmal-frame-copy        Copy frame at a time out of mmal to chrome. Needs
+2+ gpu frames for plausible performance.  Default frame-buffers = 2 (8M
+each).  You probably want gpu-mem=80 for 1 decoder with this option.
+
+--mmal-slice-copy        Copy frames out in 16-line slices.  Has the
+lowest memory overhead, but the highest CPU load.  If this is selected
+then --mmal-frame-buffers is the number of slice buffers. Default frame
+buffers = 16 (~122k each)
+
+--mmal-decode-opaque     Set the decoder to use opaque frames between
+decoder and resizer.  This should be faster than i420 but with current
+firmware this doesn't work properly so is disabled by default. (see
+--mmal-decode-i420)
+
+--mmal-decode-i420       Set the decoder to use I420 frames between
+decoder and resizer.  This generates an unnecessary conversion but works.
+(see --mmal-decode-opaque)
+
+--mmal-low-delay         Force "low-delay" mode on the decoder pipe.  This
+reduces the number of buffered ES frames before the decoder.  It isn't
+exactly low-delay but is definitely lower than otherwise.  May have a
+slight performance penalty and increase the risk of stuttering.
+
+--mmal-resize-isp        Use ISP resize rather than resizer.  Is noticably
+faster but the firmware doesn't actually work properly yet so disabled by
+default.  Requires --mmal-frame-copy or --mmal-zero-copy.
+
+
+
+Misc options
+------------
+
+--mmal-decoders=<n>      Set the number of mmal decoders we wil try to
+create simultainiously. Default=1. If this number is exceeded then decoder
+init will fail and chrome will fallback to ffmpeg decode.  There is no
+panalty for setting this to a large number if you wish to have "unlimited"
+decoders.  However if it is set too big and there isn't the gpu mem to
+satisfy the requirements of the decode it may fail cleanly and revert to
+software (ffmpeg) decode or init may appear to succeed and decode then
+fails in an undefined manner.
+
+--mmal-frame-buffers=<n> Set the number of gpu "frame" buffers (see
+--mmal-xxx-copy). Change with care.
+
+--mmal-red-pixel         Puts a red square in the top left of a frame
+decoded by mmal so you can tell that it is active.  Doesn't work if
+zero-copy is set.
diff --git a/src/pi-util/chromium.gyp_env.pi1 b/src/pi-util/chromium.gyp_env.pi1
new file mode 100644
index 0000000..323e414
--- /dev/null
+++ b/src/pi-util/chromium.gyp_env.pi1
@@ -0,0 +1,5 @@
+{
+'GYP_CROSSCOMPILE': '1',
+'GYP_DEFINES': 'use_system_harfbuzz=1 use_system_libjpeg=1 proprietary_codecs=1 target_arch=arm arm_float_abi=hard arm_version=6 arm_neon=0 arm_neon_optional=1 ffmpeg_branding=Chrome video_hole=0 sysroot_name=raspian_jessie_pi1'
+}
+
diff --git a/src/pi-util/chromium.gyp_env.pi2 b/src/pi-util/chromium.gyp_env.pi2
new file mode 100644
index 0000000..b626df6
--- /dev/null
+++ b/src/pi-util/chromium.gyp_env.pi2
@@ -0,0 +1,5 @@
+{
+'GYP_CROSSCOMPILE': '1',
+'GYP_DEFINES': 'use_system_harfbuzz=1 use_system_libjpeg=1 proprietary_codecs=1 target_arch=arm arm_float_abi=hard arm_version=7 arm_neon=1 ffmpeg_branding=Chrome video_hole=0 sysroot_name=raspian_jessie_pi2'
+}
+
diff --git a/src/pi-util/dodiff.py b/src/pi-util/dodiff.py
new file mode 100755
index 0000000..f90d7aa
--- /dev/null
+++ b/src/pi-util/dodiff.py
@@ -0,0 +1,35 @@
+#!/usr/bin/env python
+
+import os, sys, string, subprocess
+
+# Local
+import gitscan, pipaths
+
+def doscan():
+    revdict = gitscan.revdict()
+
+    cpath = gitscan.basepath()
+
+    for p in pipaths.pipaths:
+        os.chdir(os.path.join(cpath, p))
+        diff = subprocess.check_output(["git", "diff", revdict[p]])
+
+        header = False
+        lines = diff.split("\n")
+        # Remove terminal blank line
+        if lines[-1] == "":
+            lines.pop()
+        for line in lines:
+            if line.startswith("diff --git "):
+                header = True
+            if header:
+                line = string.replace(line, " a/", " a/" + p + "/")
+                line = string.replace(line, " b/", " b/" + p + "/")
+            if line.startswith("+++ "):
+                header = False
+            print line
+
+
+if __name__ == '__main__':
+    doscan()
+
diff --git a/src/pi-util/gitscan.py b/src/pi-util/gitscan.py
new file mode 100755
index 0000000..eb6fd99
--- /dev/null
+++ b/src/pi-util/gitscan.py
@@ -0,0 +1,51 @@
+#!/usr/bin/env python
+
+import os,subprocess
+
+# Local
+import pipaths
+
+def revdict():
+    revdict = {'src':pipaths.src_commit}
+    stuff = subprocess.check_output(["gclient", "revinfo"])
+    for line in stuff.split("\n"):
+        pathn = line.find(":")
+        commitn = line.rfind("@")
+        if pathn != -1 and commitn != -1 :
+             revdict[line[:pathn]] = line[commitn+1:]
+    return revdict
+
+def basepath():
+    cpath = os.getcwd()
+    if not cpath.endswith("/src"):
+        raise "CWD doesn't end with /src"
+
+    return cpath[:-4]
+
+if __name__ == '__main__':
+    import sys, string
+
+    nosrc = False
+
+    if sys.argv[1] == "--gitscan-no-src":
+        nosrc = True
+        del sys.argv[1]
+
+    revdict = revdict()
+
+    cpath = basepath()
+
+    for p in pipaths.pipaths:
+        if nosrc and p == "src":
+            continue
+
+        os.chdir(os.path.join(cpath, p))
+
+        gitargs = [string.replace(string.replace(a, "{PATH}", p), "{BASE}", revdict[p]) for a in sys.argv]
+        gitargs[0] = "git"
+
+        print ">>>", p
+        subprocess.check_call(gitargs)
+
+
+
diff --git a/src/pi-util/pi-install-dev.sh b/src/pi-util/pi-install-dev.sh
new file mode 100755
index 0000000..336fc26
--- /dev/null
+++ b/src/pi-util/pi-install-dev.sh
@@ -0,0 +1,34 @@
+# Install set to build appropriate root on a clean pi
+
+sudo apt-get install \
+comerr-dev \
+libasound2-dev \
+libatk1.0-dev \
+libcap-dev \
+libcups2-dev \
+libexif-dev \
+libffi-dev \
+libgconf2-dev \
+libgl1-mesa-dev \
+libgnome-keyring-dev \
+libgtk2.0-dev \
+libjpeg-dev \
+libkrb5-dev \
+libnspr4-dev \
+libnss3-dev \
+libpam0g-dev \
+libpci-dev \
+libpcre3-dev \
+libpulse-dev \
+libssl-dev \
+libudev-dev \
+libxss-dev \
+libxt-dev \
+libxtst-dev \
+mesa-common-dev
+
+# Obviously replace paths appropriately below
+# Now run pi-util/syncroot.sh on the compile m/c to grab the appropriate
+# bits of the root and fix up the paths.
+# e.g. ON COMPILE M/C in src dir:
+# pi-util/syncroot.sh my-pi: raspian_jessie_pi1
diff --git a/src/pi-util/pi1_relink.sh b/src/pi-util/pi1_relink.sh
new file mode 100755
index 0000000..958a9b3
--- /dev/null
+++ b/src/pi-util/pi1_relink.sh
@@ -0,0 +1,6 @@
+# Run from src
+cd build/linux/raspian_jessie_pi1-sysroot/usr/lib/pkgconfig
+ln -sf ../arm-linux-gnueabihf/pkgconfig/* .
+cd ../../../../../..
+pi-util/rebase_liblinks.py build/linux/raspian_jessie_pi1-sysroot
+
diff --git a/src/pi-util/pi2_relink.sh b/src/pi-util/pi2_relink.sh
new file mode 100755
index 0000000..09e104f
--- /dev/null
+++ b/src/pi-util/pi2_relink.sh
@@ -0,0 +1,6 @@
+# Run from src
+cd build/linux/raspian_jessie_pi2-sysroot/usr/lib/pkgconfig
+ln -sf ../arm-linux-gnueabihf/pkgconfig/* .
+cd ../../../../../..
+pi-util/rebase_liblinks.py build/linux/raspian_jessie_pi2-sysroot
+
diff --git a/src/pi-util/pipaths.py b/src/pi-util/pipaths.py
new file mode 100755
index 0000000..c833ab6
--- /dev/null
+++ b/src/pi-util/pipaths.py
@@ -0,0 +1,11 @@
+pipaths=[
+    "src",
+    "src/native_client",
+    "src/third_party/opus/src",
+    "src/third_party/pdfium",
+    "src/third_party/ffmpeg",
+    "src/third_party/skia",
+    "src/third_party/webrtc"]
+
+# Or maybe "master"
+src_commit="52715df2ad7c374fae6410f0a6c457f0aff3ef96"
diff --git a/src/pi-util/rebase_liblinks.py b/src/pi-util/rebase_liblinks.py
new file mode 100755
index 0000000..6a9a33f
--- /dev/null
+++ b/src/pi-util/rebase_liblinks.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python
+
+import os, sys
+from stat import *
+
+def walktree(top, callback, n, prefix):
+    '''recursively descend the directory tree rooted at top,
+       calling the callback function for each regular file'''
+
+    for f in os.listdir(top):
+        pathname = os.path.join(top, f)
+        mode = os.lstat(pathname).st_mode
+        if S_ISDIR(mode):
+            # It's a directory, recurse into it
+            walktree(pathname, callback, n+1, prefix)
+        elif S_ISLNK(mode):
+            # It's a file, call the callback function
+            callback(pathname, os.readlink(pathname), n, prefix)
+
+def visitfile(file, linkname, n, prefix):
+    if (linkname.startswith(prefix + 'lib/')):
+        newlink = "../" * n + linkname[len(prefix):]
+        print 'relinking', file, "->", newlink
+        os.remove(file)
+        os.symlink(newlink, file)
+
+if __name__ == '__main__':
+    argc = len(sys.argv)
+    if argc == 2:
+        walktree(sys.argv[1], visitfile, 0, "/")
+    elif argc == 3:
+        walktree(sys.argv[1], visitfile, 0, sys.argv[2])
+    else:
+        print "rebase_liblinks.py <local root> [<old sysroot>]"
+
+
+
diff --git a/src/pi-util/syncroot.sh b/src/pi-util/syncroot.sh
new file mode 100644
index 0000000..b9a0341
--- /dev/null
+++ b/src/pi-util/syncroot.sh
@@ -0,0 +1,45 @@
+set -e
+
+if [ "$2" == "" ]; then
+  echo Usage: $0 \<src_dir\> \<rootname\>
+  echo src_dir is a source for rsync so may contain m/c name.
+  echo e.g.: pi-util/syncroot.sh my-pi: raspian_jessie_pi1
+  exit 1
+fi
+
+DST_ROOT=`gclient root`
+DST=$DST_ROOT/src/build/linux/$2-sysroot
+SRC=$1
+
+if [ ! -d $DST_ROOT/src/build/linux ]; then
+  echo We don\'t appear to be in a Chrome build tree
+  exit 1
+fi
+
+echo Sync src:  $SRC
+echo Sync dest: $DST
+
+mkdir -p $DST/lib
+mkdir -p $DST/opt/vc/include
+mkdir -p $DST/usr/lib/pkgconfig
+mkdir -p $DST/usr/bin
+mkdir -p $DST/usr/share
+
+#### MUST NOT include /opt/vc/include/*GL*
+# Creates conflicts with GL includes inside Chrome
+
+rsync -rl $SRC/lib/arm-linux-gnueabihf $DST/lib
+rsync -rl $SRC/opt/vc/lib $DST/opt/vc
+rsync -rl $SRC/opt/vc/include/interface $DST/opt/vc/include
+rsync -rl $SRC/usr/lib/arm-linux-gnueabihf $DST/usr/lib
+rsync -rl $SRC/usr/lib/gcc $DST/usr/lib
+rsync -rl $SRC/usr/include $DST/usr
+rsync -rl $SRC/usr/share/pkgconfig $DST/usr/share
+rsync -rl $SRC/usr/bin/cups-config $DST/usr/bin
+
+cd $DST/usr/lib/pkgconfig
+ln -sf ../arm-linux-gnueabihf/pkgconfig/* .
+cd ../../../../../..
+pi-util/rebase_liblinks.py $DST
+
+
diff --git a/src/skia/skia_common.gypi b/src/skia/skia_common.gypi
index 21801cc..2b7d583 100644
--- a/src/skia/skia_common.gypi
+++ b/src/skia/skia_common.gypi
@@ -97,7 +97,7 @@
         'SK_ARM_HAS_NEON',
       ],
     }],
-    [ 'target_arch == "arm" and arm_version >= 7 and arm_neon == 0 and arm_neon_optional == 1', {
+    [ 'target_arch == "arm" and arm_version >= 6 and arm_neon == 0 and arm_neon_optional == 1', {
       'defines': [
         'SK_ARM_HAS_OPTIONAL_NEON',
       ],
diff --git a/src/skia/skia_library.gypi b/src/skia/skia_library.gypi
index fa7c23b..caff451 100644
--- a/src/skia/skia_library.gypi
+++ b/src/skia/skia_library.gypi
@@ -156,6 +156,11 @@
         '../build/android/ndk.gyp:cpu_features',
       ],
     }],
+    [ 'OS != "android" and target_arch == "arm"', {
+      'sources': [
+        '../third_party/skia/src/core/SkUtilsArm.cpp',
+      ],
+    }],
     [ 'desktop_linux == 1 or chromeos == 1', {
       'dependencies': [
         '../build/linux/system.gyp:fontconfig',
diff --git a/src/skia/skia_library_opts.gyp b/src/skia/skia_library_opts.gyp
index e1627e0..0012eb9 100644
--- a/src/skia/skia_library_opts.gyp
+++ b/src/skia/skia_library_opts.gyp
@@ -62,12 +62,12 @@
         }],
         [ 'target_arch == "arm"', {
           'conditions': [
-            [ 'arm_version >= 7', {
+            [ 'arm_version >= 6', {
               'sources': [ '<@(armv7_sources)' ],
-            }, {  # arm_version < 7
+            }, {  # arm_version < 6
               'sources': [ '<@(none_sources)' ],
             }],
-            [ 'arm_version >= 7 and (arm_neon == 1 or arm_neon_optional == 1)', {
+            [ 'arm_version >= 6 and (arm_neon == 1 or arm_neon_optional == 1)', {
               'dependencies': [
                 'skia_opts_neon',
               ]
@@ -328,10 +328,12 @@
             '-mfpu=vfp',  # remove them all, just in case.
             '-mfpu=vfpv3',
             '-mfpu=vfpv3-d16',
+	    '-march=armv6',
           ],
           'cflags': [
             '-mfpu=neon',
             '-fomit-frame-pointer',
+            '-march=armv7-a',
           ],
           'ldflags': [
             '-march=armv7-a',
diff --git a/src/third_party/WebKit/Source/wtf/SpinLock.cpp b/src/third_party/WebKit/Source/wtf/SpinLock.cpp
index 3abd17a..b775e6e 100644
--- a/src/third_party/WebKit/Source/wtf/SpinLock.cpp
+++ b/src/third_party/WebKit/Source/wtf/SpinLock.cpp
@@ -30,7 +30,11 @@
 #if CPU(X86_64) || CPU(X86)
 #define YIELD_PROCESSOR __asm__ __volatile__("pause")
 #elif CPU(ARM) || CPU(ARM64)
+#if __ARM_ARCH < 7
+#define YIELD_PROCESSOR ((void)0)
+#else
 #define YIELD_PROCESSOR __asm__ __volatile__("yield")
+#endif
 #elif CPU(MIPS)
 // The MIPS32 docs state that the PAUSE instruction is a no-op on older
 // architectures (first added in MIPS32r2). To avoid assembler errors when
diff --git a/src/third_party/boringssl/linux-arm/crypto/chacha/chacha-armv4.S b/src/third_party/boringssl/linux-arm/crypto/chacha/chacha-armv4.S
index 19a4d2c..30cb152 100644
--- a/src/third_party/boringssl/linux-arm/crypto/chacha/chacha-armv4.S
+++ b/src/third_party/boringssl/linux-arm/crypto/chacha/chacha-armv4.S
@@ -9,7 +9,8 @@
 .code	32
 #endif
 
-#if defined(__thumb2__) || defined(__clang__)
+@ #if defined(__thumb2__) || defined(__clang__)
+#if defined(__thumb2__)
 #define ldrhsb	ldrbhs
 #endif
 
diff --git a/src/third_party/tcmalloc/chromium/src/base/atomicops-internals-arm-v6plus.h b/src/third_party/tcmalloc/chromium/src/base/atomicops-internals-arm-v6plus.h
index dc06987..b7a1e1a 100644
--- a/src/third_party/tcmalloc/chromium/src/base/atomicops-internals-arm-v6plus.h
+++ b/src/third_party/tcmalloc/chromium/src/base/atomicops-internals-arm-v6plus.h
@@ -112,7 +112,14 @@ inline Atomic32 NoBarrier_AtomicIncrement(volatile Atomic32* ptr,
 }
 
 inline void MemoryBarrier() {
-  __asm__ __volatile__("dmb" : : : "memory");
+#if __ARM_ARCH >= 7
+  /* Note that this depends on ARMv7. */
+  __asm__ __volatile__("dsb");
+#else
+  /* We could support ARMv6 by instead using: */
+  __asm__ __volatile__("mcr p15, 0, %0, c7, c10, 5"
+                       : : "r" (0) : "memory");
+#endif
 }
 
 inline Atomic32 Barrier_AtomicIncrement(volatile Atomic32* ptr,
diff --git a/src/third_party/tcmalloc/chromium/src/base/cycleclock.h b/src/third_party/tcmalloc/chromium/src/base/cycleclock.h
index 0ce1638..fe6ca02 100644
--- a/src/third_party/tcmalloc/chromium/src/base/cycleclock.h
+++ b/src/third_party/tcmalloc/chromium/src/base/cycleclock.h
@@ -126,7 +126,8 @@ struct CycleClock {
 #elif defined(_MSC_VER)
     return __rdtsc();
 #elif defined(ARMV3)
-#if defined(ARMV6)  // V6 is the earliest arch that has a standard cyclecount
+//#if defined(ARMV6)  // V6 is the earliest arch that has a standard cyclecount
+#if defined(ARMV7)  // V6 is the earliest arch that has a standard cyclecount
     uint32 pmccntr;
     uint32 pmuseren;
     uint32 pmcntenset;
diff --git a/src/native_client/src/include/concurrency_ops.h b/src/native_client/src/include/concurrency_ops.h
old mode 100644
new mode 100755
index 82e313c..fdb51ef
--- a/src/native_client/src/include/concurrency_ops.h
+++ b/src/native_client/src/include/concurrency_ops.h
@@ -32,14 +32,14 @@ static INLINE void NaClWriteMemoryBarrier(void) {
 #elif NACL_ARCH(NACL_BUILD_ARCH) == NACL_arm
 
 static INLINE void NaClWriteMemoryBarrier(void) {
+#if __ARM_ARCH >= 7
   /* Note that this depends on ARMv7. */
   __asm__ __volatile__("dsb");
-
-  /*
-   * We could support ARMv6 by instead using:
-   * __asm__ __volatile__("mcr p15, 0, %0, c7, c10, 5"
-   *                      : : "r" (0) : "memory");
-   */
+#else
+  /* We could support ARMv6 by instead using: */
+  __asm__ __volatile__("mcr p15, 0, %0, c7, c10, 5"
+                       : : "r" (0) : "memory");
+#endif
 }
 
 #elif NACL_ARCH(NACL_BUILD_ARCH) == NACL_mips
diff --git a/src/third_party/opus/src/celt/arm/celt_neon_intr.c b/src/third_party/opus/src/celt/arm/celt_neon_intr.c
old mode 100644
new mode 100755
index 47dce15..a104364
--- a/src/third_party/opus/src/celt/arm/celt_neon_intr.c
+++ b/src/third_party/opus/src/celt/arm/celt_neon_intr.c
@@ -34,7 +34,9 @@
 #include "config.h"
 #endif
 
+#ifdef __ARM_NEON
 #include <arm_neon.h>
+#endif
 #include "../pitch.h"
 
 #if !defined(FIXED_POINT)
diff --git a/src/third_party/pdfium/skia/skia_library_opts.gyp b/src/third_party/pdfium/skia/skia_library_opts.gyp
index 32b69bb..9c5edb4 100644
--- a/src/third_party/pdfium/skia/skia_library_opts.gyp
+++ b/src/third_party/pdfium/skia/skia_library_opts.gyp
@@ -62,12 +62,15 @@
             }, {  # arm_version < 7
               'sources': [ '<@(none_sources)' ],
             }],
-            [ 'arm_version >= 7 and (arm_neon == 1 or arm_neon_optional == 1)', {
-              'dependencies': [
-                'skia_opts_neon',
-              ]
-            }],
+#            [ 'arm_version >= 7 and (arm_neon == 1 or arm_neon_optional == 1)', {
+#              'dependencies': [
+#                'skia_opts_neon',
+#              ]
+#            }],
           ],
+          'dependencies': [
+             'skia_opts_neon',
+          ]
           # The assembly uses the frame pointer register (r7 in Thumb/r11 in
           # ARM), the compiler doesn't like that. Explicitly remove the
           # -fno-omit-frame-pointer flag for Android, as that gets added to all
@@ -299,7 +302,8 @@
     # code. To support dynamic NEON code paths, we need to build all
     # NEON-specific sources in a separate static library. The situation
     # is very similar to the SSSE3 one.
-    ['target_arch == "arm" and (arm_neon == 1 or arm_neon_optional == 1)', {
+#    ['target_arch == "arm" and (arm_neon == 1 or arm_neon_optional == 1)', {
+    ['target_arch == "arm"', {
       'targets': [
         {
           'target_name': 'skia_opts_neon',
diff --git a/src/third_party/pdfium/third_party/third_party.gyp b/src/third_party/pdfium/third_party/third_party.gyp
index 7fd1082..01ed3b2 100644
--- a/src/third_party/pdfium/third_party/third_party.gyp
+++ b/src/third_party/pdfium/third_party/third_party.gyp
@@ -411,6 +411,20 @@
             'libtiff/tif_write.c',
             'libtiff/tif_zip.c',
           ],
+          'conditions': [
+            ['OS=="win"', {
+              'defines!': [
+                # Need to undefine the macro since it is redefined in
+                # tif_ojpeg.c and tif_jpeg.c.
+                'WIN32_LEAN_AND_MEAN',
+              ],
+            }],
+            ['use_system_libjpeg!=0', {
+              'defines': [
+                'USE_SYSTEM_LIBJPEG=1',
+              ],
+            }],
+          ],
         },
       ],
     }],
diff --git a/src/third_party/ffmpeg/chromium/config/Chrome/linux/arm/config.h b/src/third_party/ffmpeg/chromium/config/Chrome/linux/arm/config.h
old mode 100644
new mode 100755
index f6c0650..9e960a1
--- a/src/third_party/ffmpeg/chromium/config/Chrome/linux/arm/config.h
+++ b/src/third_party/ffmpeg/chromium/config/Chrome/linux/arm/config.h
@@ -40,7 +40,7 @@
 #define ARCH_X86_64 0
 #define HAVE_ARMV5TE 1
 #define HAVE_ARMV6 1
-#define HAVE_ARMV6T2 1
+#define HAVE_ARMV6T2 0
 #define HAVE_ARMV8 0
 #define HAVE_NEON 0
 #define HAVE_VFP 1
@@ -82,8 +82,8 @@
 #define HAVE_LOONGSON3 1
 #define HAVE_MMI 0
 #define HAVE_ARMV5TE_EXTERNAL 1
-#define HAVE_ARMV6_EXTERNAL 1
-#define HAVE_ARMV6T2_EXTERNAL 1
+#define HAVE_ARMV6_EXTERNAL 0
+#define HAVE_ARMV6T2_EXTERNAL 0
 #define HAVE_ARMV8_EXTERNAL 0
 #define HAVE_NEON_EXTERNAL 0
 #define HAVE_VFP_EXTERNAL 1
@@ -126,7 +126,7 @@
 #define HAVE_MMI_EXTERNAL 0
 #define HAVE_ARMV5TE_INLINE 1
 #define HAVE_ARMV6_INLINE 1
-#define HAVE_ARMV6T2_INLINE 1
+#define HAVE_ARMV6T2_INLINE 0
 #define HAVE_ARMV8_INLINE 0
 #define HAVE_NEON_INLINE 0
 #define HAVE_VFP_INLINE 1
@@ -550,7 +550,7 @@
 #define CONFIG_PIC 1
 #define CONFIG_POD2MAN 1
 #define CONFIG_RAISE_MAJOR 0
-#define CONFIG_THUMB 1
+#define CONFIG_THUMB 0
 #define CONFIG_VALGRIND_BACKTRACE 0
 #define CONFIG_XMM_CLOBBER_TEST 0
 #define CONFIG_AANDCTTABLES 0
diff --git a/src/third_party/skia/include/core/SkImageGenerator.h b/src/third_party/skia/include/core/SkImageGenerator.h
index 1a46f6b..35eb4cc 100644
--- a/src/third_party/skia/include/core/SkImageGenerator.h
+++ b/src/third_party/skia/include/core/SkImageGenerator.h
@@ -129,6 +129,11 @@ public:
      */
     bool getPixels(const SkImageInfo& info, void* pixels, size_t rowBytes);
 
+    virtual bool installBitmapPixels(SkBitmap * const bitmap)
+    {
+        return false;
+    }
+
     /**
      *  If decoding to YUV is supported, this returns true.  Otherwise, this
      *  returns false and does not modify any of the parameters.
diff --git a/src/third_party/skia/src/core/SkImageGenerator.cpp b/src/third_party/skia/src/core/SkImageGenerator.cpp
index c8c94c2..92b45fe 100644
--- a/src/third_party/skia/src/core/SkImageGenerator.cpp
+++ b/src/third_party/skia/src/core/SkImageGenerator.cpp
@@ -128,8 +128,13 @@ static bool reset_and_return_false(SkBitmap* bitmap) {
     return false;
 }
 
+
 bool SkImageGenerator::tryGenerateBitmap(SkBitmap* bitmap, const SkImageInfo* infoPtr,
                                          SkBitmap::Allocator* allocator) {
+    if (this->installBitmapPixels(bitmap)) {
+        return true;
+    }
+
     SkImageInfo info = infoPtr ? *infoPtr : this->getInfo();
     if (0 == info.getSafeSize(info.minRowBytes())) {
         return false;
diff --git a/src/third_party/skia/src/core/SkOpts.cpp b/src/third_party/skia/src/core/SkOpts.cpp
index 50659d4..1a1d73f 100644
--- a/src/third_party/skia/src/core/SkOpts.cpp
+++ b/src/third_party/skia/src/core/SkOpts.cpp
@@ -60,6 +60,8 @@ namespace SK_OPTS_NS {
        defined(SK_BUILD_FOR_ANDROID) && \
       !defined(SK_BUILD_FOR_ANDROID_FRAMEWORK)
     #include <cpu-features.h>
+#elif defined(SK_CPU_ARM32)
+    #include "SkUtilsArm.h"
 #endif
 
 namespace SkOpts {
@@ -139,6 +141,10 @@ namespace SkOpts {
            defined(SK_BUILD_FOR_ANDROID) && \
           !defined(SK_BUILD_FOR_ANDROID_FRAMEWORK)
         if (android_getCpuFeatures() & ANDROID_CPU_ARM_FEATURE_NEON) { Init_neon(); }
+    #elif defined(SK_CPU_ARM32)
+        if (sk_cpu_arm_has_neon()) {
+            Init_neon();
+        }
     #endif
     }
 
diff --git a/src/third_party/skia/src/core/SkUtilsArm.cpp b/src/third_party/skia/src/core/SkUtilsArm.cpp
index bf98fed..de3142f 100644
--- a/src/third_party/skia/src/core/SkUtilsArm.cpp
+++ b/src/third_party/skia/src/core/SkUtilsArm.cpp
@@ -17,6 +17,8 @@
 
 #if defined(SK_BUILD_FOR_ANDROID)
 #  include <cpu-features.h>
+#else
+#include <sys/auxv.h>
 #endif
 
 // A function used to determine at runtime if the target CPU supports
@@ -32,7 +34,7 @@ static bool sk_cpu_arm_check_neon(void) {
 
   result = (android_getCpuFeatures() & ANDROID_CPU_ARM_FEATURE_NEON) != 0;
 
-#else  // SK_BUILD_FOR_ANDROID
+#elif 0  // SK_BUILD_FOR_ANDROID
 
     // There is no user-accessible CPUID instruction on ARM that we can use.
     // Instead, we must parse /proc/cpuinfo and look for the 'neon' feature.
@@ -119,6 +121,12 @@ static bool sk_cpu_arm_check_neon(void) {
 
     } while (0);
 
+#else
+    // Unlike the above code getauxval does work inside a sandbox
+    // getauxval returns 0 on error which is OK
+    // Documentation suggests that getauxval(AT_HWCAP) should return a pointer
+    // to a bit array, but evidence suggests it returns a simple bit field
+    result = (getauxval(AT_HWCAP) & HWCAP_ARM_NEON) != 0;
 #endif  // SK_BUILD_FOR_ANDROID
 
     if (result) {
diff --git a/src/third_party/webrtc/build/arm_neon.gypi b/src/third_party/webrtc/build/arm_neon.gypi
index 1d1be3e..da26288 100644
--- a/src/third_party/webrtc/build/arm_neon.gypi
+++ b/src/third_party/webrtc/build/arm_neon.gypi
@@ -21,7 +21,9 @@
 
 {
   'cflags!': [
+    '-mfpu=vfp',
     '-mfpu=vfpv3-d16',
+    '-march=armv6',
   ],
   'conditions': [
     # "-mfpu=neon" is not required for arm64 in GCC.
@@ -30,6 +32,12 @@
         '-mfpu=neon',
        ],
     }],
+    ['arm_version == 6', {
+      # march=armv6 already killed but need something that might support neon
+      'cflags': [
+        '-march=armv7-a',
+       ],
+    }],
     # Disable GCC LTO on NEON targets due to compiler bug.
     # TODO(fdegans): Enable this. See crbug.com/408997.
     ['clang==0 and use_lto==1', {
diff --git a/src/third_party/webrtc/build/common.gypi b/src/third_party/webrtc/build/common.gypi
index 6ec0f1c..f8d3dfd 100644
--- a/src/third_party/webrtc/build/common.gypi
+++ b/src/third_party/webrtc/build/common.gypi
@@ -208,7 +208,7 @@
       ['target_arch=="arm" or target_arch=="arm64" or target_arch=="mipsel"', {
         'prefer_fixed_point%': 1,
       }],
-      ['(target_arch=="arm" and (arm_neon==1 or arm_neon_optional==1)) or target_arch=="arm64"', {
+      ['(target_arch=="arm" and (arm_neon==1 or (arm_version >= 6 and arm_neon_optional==1))) or target_arch=="arm64"', {
         'build_with_neon%': 1,
       }],
       ['OS!="ios" and (target_arch!="arm" or arm_version>=7) and target_arch!="mips64el"', {
@@ -338,6 +338,9 @@
               }],
             ],
           }],
+          ['arm_version==6 and arm_neon_optional==1', {
+            'defines': ['WEBRTC_DETECT_NEON',],
+          }],
         ],
       }],
       ['target_arch=="mipsel" and mips_arch_variant!="r6"', {
diff --git a/src/third_party/webrtc/modules/video_processing/deflickering.cc b/src/third_party/webrtc/modules/video_processing/deflickering.cc
index 0e936ce..d8b94ae 100644
--- a/src/third_party/webrtc/modules/video_processing/deflickering.cc
+++ b/src/third_party/webrtc/modules/video_processing/deflickering.cc
@@ -17,6 +17,8 @@
 #include "webrtc/common_audio/signal_processing/include/signal_processing_library.h"
 #include "webrtc/system_wrappers/include/sort.h"
 
+#pragma clang optimize off
+
 namespace webrtc {
 
 // Detection constants
diff --git a/src/third_party/webrtc/modules/video_processing/video_processing.gypi b/src/third_party/webrtc/modules/video_processing/video_processing.gypi
old mode 100644
new mode 100755
index 5bf0ea3..98f4869
--- a/src/third_party/webrtc/modules/video_processing/video_processing.gypi
+++ b/src/third_party/webrtc/modules/video_processing/video_processing.gypi
@@ -49,7 +49,7 @@
         ['target_arch=="ia32" or target_arch=="x64"', {
           'dependencies': [ 'video_processing_sse2', ],
         }],
-        ['target_arch=="arm" or target_arch == "arm64"', {
+        ['(target_arch=="arm" and (arm_neon==1 or arm_neon_optional==1)) or target_arch == "arm64"', {
           'dependencies': [ 'video_processing_neon', ],
         }],
       ],
@@ -79,7 +79,7 @@
         },
       ],
     }],
-    ['target_arch=="arm" or target_arch == "arm64"', {
+    ['(target_arch=="arm" and (arm_neon==1 or arm_neon_optional==1)) or target_arch == "arm64"', {
       'targets': [
         {
           'target_name': 'video_processing_neon',
diff --git a/src/third_party/webrtc/system_wrappers/system_wrappers.gyp b/src/third_party/webrtc/system_wrappers/system_wrappers.gyp
index cd6d3ea..415549d 100644
--- a/src/third_party/webrtc/system_wrappers/system_wrappers.gyp
+++ b/src/third_party/webrtc/system_wrappers/system_wrappers.gyp
@@ -122,13 +122,13 @@
           'defines': [
             'WEBRTC_THREAD_RR',
           ],
-          'conditions': [
-            ['build_with_chromium==0', {
+#          'conditions': [
+#            ['build_with_chromium==0', {
               'dependencies': [
                 'cpu_features_webrtc.gyp:cpu_features_linux',
               ],
-            }],
-          ],
+#            }],
+#          ],
           'link_settings': {
             'libraries': [ '-lrt', ],
           },
